____________________________________________________________________________________________________
Name: github_link
Type: function
Parent Type: 
Location: /home/yuesheng/flask/docs/conf.py,2473,3249
Arguments: ['name', 'rawtext', 'text', 'lineno', 'inliner', 'options=None', 'content=None']
Code: // Code for Global Scope
import packaging.version
from pallets_sphinx_themes import get_version
from pallets_sphinx_themes import ProjectLink
# Project --------------------------------------------------------------
project = "Flask"
copyright = "2010 Pallets"
author = "Pallets"
release, version = get_version("Flask")
# General --------------------------------------------------------------
default_role = "code"
extensions = [
    "sphinx.ext.autodoc",
    "sphinx.ext.extlinks",
    "sphinx.ext.intersphinx",
    "sphinxcontrib.log_cabinet",
    "sphinx_tabs.tabs",
    "pallets_sphinx_themes",
]
autodoc_member_order = "bysource"
autodoc_typehints = "description"
autodoc_preserve_defaults = True
extlinks = {
    "issue": ("https://github.com/pallets/flask/issues/%s", "#%s"),
    "pr": ("https://github.com/pallets/flask/pull/%s", "#%s"),
}
intersphinx_mapping = {
    "python": ("https://docs.python.org/3/", None),
    "werkzeug": ("https://werkzeug.palletsprojects.com/", None),
    "click": ("https://click.palletsprojects.com/", None),
    "jinja": ("https://jinja.palletsprojects.com/", None),
    "itsdangerous": ("https://itsdangerous.palletsprojects.com/", None),
    "sqlalchemy": ("https://docs.sqlalchemy.org/", None),
    "wtforms": ("https://wtforms.readthedocs.io/", None),
    "blinker": ("https://blinker.readthedocs.io/", None),
}
# HTML -----------------------------------------------------------------
html_theme = "flask"
html_theme_options = {"index_sidebar_logo": False}
html_context = {
    "project_links": [
        ProjectLink("Donate", "https://palletsprojects.com/donate"),
        ProjectLink("PyPI Releases", "https://pypi.org/project/Flask/"),
        ProjectLink("Source Code", "https://github.com/pallets/flask/"),
        ProjectLink("Issue Tracker", "https://github.com/pallets/flask/issues/"),
        ProjectLink("Chat", "https://discord.gg/pallets"),
    ]
}
html_sidebars = {
    "index": ["project.html", "localtoc.html", "searchbox.html", "ethicalads.html"],
    "**": ["localtoc.html", "relations.html", "searchbox.html", "ethicalads.html"],
}
singlehtml_sidebars = {"index": ["project.html", "localtoc.html", "ethicalads.html"]}
html_static_path = ["_static"]
html_favicon = "_static/shortcut-icon.png"
html_logo = "_static/flask-vertical.png"
html_title = f"Flask Documentation ({version})"
html_show_sourcelink = False
gettext_uuid = True
gettext_compact = False
# Local Extensions -----------------------------------------------------
# Code for function: github_link(name, rawtext, text, lineno, inliner, options=None, content=None)
# Code for function: setup(app)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_aborting
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_regression.py,15,711
Arguments: ['app', '', '', 'e']
Code: // Code for Global Scope
import flask
# Code for function: test_aborting(app, , , e)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_open_session_with_endpoint
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_session_interface.py,97,791
Arguments: ['', 'self', 'app', 'session', 'response', 'self', 'app', 'request', '']
Code: // Code for Global Scope
import flask
from flask.globals import request_ctx
from flask.sessions import SessionInterface
# Code for function: test_open_session_with_endpoint(, self, app, session, response, self, app, request, )

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_logger
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_logging.py,825,987
Arguments: ['app']
Code: // Code for Global Scope
import logging
import sys
from io import StringIO
import pytest
from flask.logging import default_handler
from flask.logging import has_level_handler
from flask.logging import wsgi_errors_stream
@pytest.fixture(autouse=True)
def reset_logging(pytestconfig):
    root_handlers = logging.root.handlers[:]
    logging.root.handlers = []
    root_level = logging.root.level

    logger = logging.getLogger("flask_test")
    logger.handlers = []
    logger.setLevel(logging.NOTSET)

    logging_plugin = pytestconfig.pluginmanager.unregister(name="logging-plugin")

    yield

    logging.root.handlers[:] = root_handlers
    logging.root.setLevel(root_level)

    logger.handlers = []
    logger.setLevel(logging.NOTSET)

    if logging_plugin:
        pytestconfig.pluginmanager.register(logging_plugin, "logging-plugin")
# Code for function: test_logger(app)
# Code for function: test_logger_debug(app)
# Code for function: test_existing_handler(app)
# Code for function: test_wsgi_errors_stream(app, client, )
# Code for function: test_has_level_handler()
# Code for function: test_log_view_exception(app, client, )

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_options_work
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_basic.py,682,945
Arguments: ['app', 'client', '']
Code: // Code for Global Scope
import gc
import re
import typing as t
import uuid
import warnings
import weakref
from contextlib import nullcontext
from datetime import datetime
from datetime import timezone
from platform import python_implementation
import pytest
import werkzeug.serving
from markupsafe import Markup
from werkzeug.exceptions import BadRequest
from werkzeug.exceptions import Forbidden
from werkzeug.exceptions import NotFound
from werkzeug.http import parse_date
from werkzeug.routing import BuildError
from werkzeug.routing import RequestRedirect
import flask
require_cpython_gc = pytest.mark.skipif(
    python_implementation() != "CPython",
    reason="Requires CPython GC behavior",
)
# Code for function: test_options_work(app, client, )
# Code for function: test_options_on_multiple_rules(app, client, , )
@pytest.mark.parametrize("method", ["get", "post", "put", "delete", "patch"])
def test_method_route(app, client, method):
    method_route = getattr(app, method)
    client_method = getattr(client, method)

    @method_route("/")
    def hello():
        return "Hello"

    assert client_method("/").data == b"Hello"
# Code for function: test_method_route_no_methods(app)
# Code for function: test_provide_automatic_options_attr(, , )
# Code for function: test_provide_automatic_options_kwarg(app, client, , )
# Code for function: test_request_dispatching(app, client, , )
# Code for function: test_disallow_string_for_allowed_methods(app)
# Code for function: test_url_mapping(app, client, , , )
# Code for function: test_werkzeug_routing(app, client, , )
# Code for function: test_endpoint_decorator(app, client, , )
# Code for function: test_session(app, client, , )
# Code for function: test_session_path(app, client, )
# Code for function: test_session_using_application_root(app, client, self, environ, start_response, , self, app, prefix)
# Code for function: test_session_using_session_settings(app, client, , )
# Code for function: test_session_using_samesite_attribute(app, client, )
# Code for function: test_missing_session(app, f, *args, **kwargs)
# Code for function: test_session_secret_key_fallbacks(app, client, , )
# Code for function: test_session_expiration(app, client, , )
# Code for function: test_session_stored_last(app, client, , response)
# Code for function: test_session_special_types(app, client, )
# Code for function: test_session_cookie_setting(app, , expect_header, )
# Code for function: test_session_vary_cookie(app, client, , , , , , , , , path, header_value="Cookie")
# Code for function: test_session_refresh_vary(app, client, , )
# Code for function: test_flashes(app, req_ctx)
# Code for function: test_extended_flashing(app, , , , , , )
# Code for function: test_request_processing(app, client, , , response)
# Code for function: test_request_preprocessing_early_return(app, client, , , , )
# Code for function: test_after_request_processing(app, client, , response)
# Code for function: test_teardown_request_handler(app, client, exc, )
# Code for function: test_teardown_request_handler_debug_mode(app, client, , exc)
# Code for function: test_teardown_request_handler_error(app, client, , exc, exc)
# Code for function: test_before_after_request_order(app, client, , response, , response, exc, exc, )
# Code for function: test_error_handling(app, client, , e, e, e, , )
# Code for function: test_error_handling_processing(app, client, resp, , e)
# Code for function: test_baseexception_error_handling(app, client, )
# Code for function: test_before_request_and_routing_errors(app, client, error, )
# Code for function: test_user_error_handling(app, client, , e)
# Code for function: test_http_error_subclass_handling(app, client, , e, , e, )
# Code for function: test_errorhandler_precedence(app, client, , e, , e)
@pytest.mark.parametrize(
    ("debug", "trap", "expect_key", "expect_abort"),
    [(False, None, True, True), (True, None, False, True), (False, True, False, False)],
)
def test_trap_bad_request_key_error(app, client, debug, trap, expect_key, expect_abort):
    app.config["DEBUG"] = debug
    app.config["TRAP_BAD_REQUEST_ERRORS"] = trap

    @app.route("/key")
    def fail():
        flask.request.form["missing_key"]

    @app.route("/abort")
    def allow_abort():
        flask.abort(400)

    if expect_key:
        rv = client.get("/key")
        assert rv.status_code == 400
        assert b"missing_key" not in rv.data
    else:
        with pytest.raises(KeyError) as exc_info:
            client.get("/key")

        assert exc_info.errisinstance(BadRequest)
        assert "missing_key" in exc_info.value.get_description()

    if expect_abort:
        rv = client.get("/abort")
        assert rv.status_code == 400
    else:
        with pytest.raises(BadRequest):
            client.get("/abort")
# Code for function: test_trapping_of_all_http_exceptions(app, client, )
# Code for function: test_error_handler_after_processor_error(app, client, e, , , response)
# Code for function: test_enctype_debug_helper(app, client, )
# Code for function: test_response_types(, app, client, , , , , , , , , )
# Code for function: test_response_type_errors(, , , , , )
# Code for function: test_make_response(app, req_ctx)
# Code for function: test_make_response_with_response_instance(app, req_ctx)
@pytest.mark.parametrize("compact", [True, False])
def test_jsonify_no_prettyprint(app, compact):
    app.json.compact = compact
    rv = app.json.response({"msg": {"submsg": "W00t"}, "msg2": "foobar"})
    data = rv.data.strip()
    assert (b" " not in data) is compact
    assert (b"\n" not in data) is compact
# Code for function: test_jsonify_mimetype(app, req_ctx)
# Code for function: test_json_dump_dataclass(app, req_ctx)
# Code for function: test_jsonify_args_and_kwargs_check(app, req_ctx)
# Code for function: test_url_generation(app, req_ctx, )
# Code for function: test_build_error_handler(app, error, endpoint, values)
# Code for function: test_build_error_handler_reraise(app, error, endpoint, values)
# Code for function: test_url_for_passes_special_values_to_build_error_handler(app, error, endpoint, values)
# Code for function: test_static_files(app, client)
# Code for function: test_static_url_path()
# Code for function: test_static_url_path_with_ending_slash()
# Code for function: test_static_url_empty_path(app)
# Code for function: test_static_url_empty_path_default(app)
# Code for function: test_static_folder_with_pathlib_path(app)
# Code for function: test_static_folder_with_ending_slash(, path)
# Code for function: test_static_route_with_host_matching()
# Code for function: test_request_locals()
@pytest.mark.parametrize(
    ("subdomain_matching", "host_matching", "expect_base", "expect_abc", "expect_xyz"),
    [
        (False, False, "default", "default", "default"),
        (True, False, "default", "abc", "<invalid>"),
        (False, True, "default", "abc", "default"),
    ],
)
def test_server_name_matching(
    subdomain_matching: bool,
    host_matching: bool,
    expect_base: str,
    expect_abc: str,
    expect_xyz: str,
) -> None:
    app = flask.Flask(
        __name__,
        subdomain_matching=subdomain_matching,
        host_matching=host_matching,
        static_host="example.test" if host_matching else None,
    )
    app.config["SERVER_NAME"] = "example.test"

    @app.route("/", defaults={"name": "default"}, host="<name>")
    @app.route("/", subdomain="<name>", host="<name>.example.test")
    def index(name: str) -> str:
        return name

    client = app.test_client()

    r = client.get(base_url="http://example.test")
    assert r.text == expect_base

    r = client.get(base_url="http://abc.example.test")
    assert r.text == expect_abc

    with pytest.warns() if subdomain_matching else nullcontext():
        r = client.get(base_url="http://xyz.other.test")

    assert r.text == expect_xyz
# Code for function: test_server_name_subdomain(, , )
@pytest.mark.parametrize("key", ["TESTING", "PROPAGATE_EXCEPTIONS", "DEBUG", None])
def test_exception_propagation(app, client, key):
    app.testing = False

    @app.route("/")
    def index():
        raise ZeroDivisionError

    if key is not None:
        app.config[key] = True

        with pytest.raises(ZeroDivisionError):
            client.get("/")
    else:
        assert client.get("/").status_code == 500
@pytest.mark.parametrize("debug", [True, False])
@pytest.mark.parametrize("use_debugger", [True, False])
@pytest.mark.parametrize("use_reloader", [True, False])
@pytest.mark.parametrize("propagate_exceptions", [None, True, False])
def test_werkzeug_passthrough_errors(
    monkeypatch, debug, use_debugger, use_reloader, propagate_exceptions, app
):
    rv = {}

    # Mocks werkzeug.serving.run_simple method
    def run_simple_mock(*args, **kwargs):
        rv["passthrough_errors"] = kwargs.get("passthrough_errors")

    monkeypatch.setattr(werkzeug.serving, "run_simple", run_simple_mock)
    app.config["PROPAGATE_EXCEPTIONS"] = propagate_exceptions
    app.run(debug=debug, use_debugger=use_debugger, use_reloader=use_reloader)
# Code for function: test_url_processors(app, client, endpoint, values, , endpoint, values, , )
# Code for function: test_inject_blueprint_url_defaults(app, page, endpoint, values)
# Code for function: test_nonascii_pathinfo(app, client, )
# Code for function: test_no_setup_after_first_request(app, client, )
# Code for function: test_routing_redirect_debugging(monkeypatch, app, client, )
# Code for function: test_route_decorator_custom_endpoint(app, client, , , )
# Code for function: test_get_method_on_g(app_ctx)
# Code for function: test_g_iteration_protocol(app_ctx)
# Code for function: test_subdomain_basic_support(, , )
# Code for function: test_subdomain_matching(, user)
# Code for function: test_subdomain_matching_with_ports(, user)
@pytest.mark.parametrize("matching", (False, True))
def test_subdomain_matching_other_name(matching):
    app = flask.Flask(__name__, subdomain_matching=matching)
    app.config["SERVER_NAME"] = "localhost.localdomain:3000"
    client = app.test_client()

    @app.route("/")
    def index():
        return "", 204

    # suppress Werkzeug 0.15 warning about name mismatch
    with warnings.catch_warnings():
        warnings.filterwarnings(
            "ignore", "Current server name", UserWarning, "flask.app"
        )
        # ip address can't match name
        rv = client.get("/", "http://127.0.0.1:3000/")
        assert rv.status_code == 404 if matching else 204

    # allow all subdomains if matching is disabled
    rv = client.get("/", "http://www.localhost.localdomain:3000/")
    assert rv.status_code == 404 if matching else 204
# Code for function: test_multi_route_rules(app, client, test="a")
# Code for function: test_multi_route_class_views(app, client, self, app, self, test="a")
# Code for function: test_run_defaults(monkeypatch, app, *args, **kwargs)
# Code for function: test_run_server_port(monkeypatch, app, hostname, port, application, *args, **kwargs)
@pytest.mark.parametrize(
    "host,port,server_name,expect_host,expect_port",
    (
        (None, None, "pocoo.org:8080", "pocoo.org", 8080),
        ("localhost", None, "pocoo.org:8080", "localhost", 8080),
        (None, 80, "pocoo.org:8080", "pocoo.org", 80),
        ("localhost", 80, "pocoo.org:8080", "localhost", 80),
        ("localhost", 0, "localhost:8080", "localhost", 0),
        (None, None, "localhost:8080", "localhost", 8080),
        (None, None, "localhost:0", "localhost", 0),
    ),
)
def test_run_from_config(
    monkeypatch, host, port, server_name, expect_host, expect_port, app
):
    def run_simple_mock(hostname, port, *args, **kwargs):
        assert hostname == expect_host
        assert port == expect_port

    monkeypatch.setattr(werkzeug.serving, "run_simple", run_simple_mock)
    app.config["SERVER_NAME"] = server_name
    app.run(host, port)
# Code for function: test_max_cookie_size(app, client, recwarn, )
@require_cpython_gc
def test_app_freed_on_zero_refcount():
    # A Flask instance should not create a reference cycle that prevents CPython
    # from freeing it when all external references to it are released (see #3761).
    gc.disable()
    try:
        app = flask.Flask(__name__)
        assert app.view_functions["static"]
        weak = weakref.ref(app)
        assert weak() is not None
        del app
        assert weak() is None
    finally:
        gc.enable()

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_environ_defaults_from_config
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_testing.py,290,686
Arguments: ['app', 'client', '']
Code: // Code for Global Scope
import importlib.metadata
import click
import pytest
import flask
from flask import appcontext_popped
from flask.cli import ScriptInfo
from flask.globals import _cv_request
from flask.json import jsonify
from flask.testing import EnvironBuilder
from flask.testing import FlaskCliRunner
# Code for function: test_environ_defaults_from_config(app, client, )
# Code for function: test_environ_defaults(app, client, app_ctx, req_ctx, )
# Code for function: test_environ_base_default(app, client, )
# Code for function: test_environ_base_modified(app, client, )
# Code for function: test_client_open_environ(app, client, request, )
# Code for function: test_specify_url_scheme(app, client, )
# Code for function: test_path_is_url(app)
# Code for function: test_environbuilder_json_dumps(app)
# Code for function: test_blueprint_with_subdomain(, )
# Code for function: test_redirect_keep_session(app, client, app_ctx, , )
# Code for function: test_session_transactions(app, client, )
# Code for function: test_session_transactions_no_null_sessions()
# Code for function: test_session_transactions_keep_context(app, client, req_ctx)
# Code for function: test_session_transaction_needs_cookies(app)
# Code for function: test_test_client_context_binding(app, client, , )
# Code for function: test_reuse_client(client)
# Code for function: test_full_url_request(app, client, )
# Code for function: test_json_request_and_response(app, client, )
# Code for function: test_client_json_no_app_context(app, client, , self, app)
# Code for function: test_subdomain(, company_id)
# Code for function: test_nosubdomain(app, client, company_id)
# Code for function: test_cli_runner_class(app)
# Code for function: test_cli_invoke(app, )
# Code for function: test_cli_custom_obj(app, , )
# Code for function: test_client_pop_all_preserved(app, req_ctx, client, )

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/tests/conftest.py,0,4319
Arguments: []
Code: // Code for Global Scope
import os
import pkgutil
import sys
import pytest
from _pytest import monkeypatch
from flask import Flask
from flask.globals import request_ctx
@pytest.fixture(scope="session", autouse=True)
def _standard_os_environ():
    """Set up ``os.environ`` at the start of the test session to have
    standard values. Returns a list of operations that is used by
    :func:`._reset_os_environ` after each test.
    """
    mp = monkeypatch.MonkeyPatch()
    out = (
        (os.environ, "FLASK_ENV_FILE", monkeypatch.notset),
        (os.environ, "FLASK_APP", monkeypatch.notset),
        (os.environ, "FLASK_DEBUG", monkeypatch.notset),
        (os.environ, "FLASK_RUN_FROM_CLI", monkeypatch.notset),
        (os.environ, "WERKZEUG_RUN_MAIN", monkeypatch.notset),
    )

    for _, key, value in out:
        if value is monkeypatch.notset:
            mp.delenv(key, False)
        else:
            mp.setenv(key, value)

    yield out
    mp.undo()
@pytest.fixture(autouse=True)
def _reset_os_environ(monkeypatch, _standard_os_environ):
    """Reset ``os.environ`` to the standard environ after each test,
    in case a test changed something without cleaning up.
    """
    monkeypatch._setitem.extend(_standard_os_environ)
@pytest.fixture
def app():
    app = Flask("flask_test", root_path=os.path.dirname(__file__))
    app.config.update(
        TESTING=True,
        SECRET_KEY="test key",
    )
    return app
@pytest.fixture
def app_ctx(app):
    with app.app_context() as ctx:
        yield ctx
@pytest.fixture
def req_ctx(app):
    with app.test_request_context() as ctx:
        yield ctx
@pytest.fixture
def client(app):
    return app.test_client()
@pytest.fixture
def test_apps(monkeypatch):
    monkeypatch.syspath_prepend(os.path.join(os.path.dirname(__file__), "test_apps"))
    original_modules = set(sys.modules.keys())

    yield

    # Remove any imports cached during the test. Otherwise "import app"
    # will work in the next test even though it's no longer on the path.
    for key in sys.modules.keys() - original_modules:
        sys.modules.pop(key)
@pytest.fixture(autouse=True)
def leak_detector():
    yield

    # make sure we're not leaking a request context since we are
    # testing flask internally in debug mode in a few cases
    leaks = []
    while request_ctx:
        leaks.append(request_ctx._get_current_object())
        request_ctx.pop()

    assert leaks == []
@pytest.fixture(params=(True, False))
def limit_loader(request, monkeypatch):
    """Patch pkgutil.get_loader to give loader without get_filename or archive.

    This provides for tests where a system has custom loaders, e.g. Google App
    Engine's HardenedModulesHook, which have neither the `get_filename` method
    nor the `archive` attribute.

    This fixture will run the testcase twice, once with and once without the
    limitation/mock.
    """
    if not request.param:
        return

    class LimitedLoader:
        def __init__(self, loader):
            self.loader = loader

        def __getattr__(self, name):
            if name in {"archive", "get_filename"}:
                raise AttributeError(f"Mocking a loader which does not have {name!r}.")
            return getattr(self.loader, name)

    old_get_loader = pkgutil.get_loader

    def get_loader(*args, **kwargs):
        return LimitedLoader(old_get_loader(*args, **kwargs))

    monkeypatch.setattr(pkgutil, "get_loader", get_loader)
@pytest.fixture
def modules_tmp_path(tmp_path, monkeypatch):
    """A temporary directory added to sys.path."""
    rv = tmp_path / "modules_tmp"
    rv.mkdir()
    monkeypatch.syspath_prepend(os.fspath(rv))
    return rv
@pytest.fixture
def modules_tmp_path_prefix(modules_tmp_path, monkeypatch):
    monkeypatch.setattr(sys, "prefix", os.fspath(modules_tmp_path))
    return modules_tmp_path
@pytest.fixture
def site_packages(modules_tmp_path, monkeypatch):
    """Create a fake site-packages."""
    py_dir = f"python{sys.version_info.major}.{sys.version_info.minor}"
    rv = modules_tmp_path / "lib" / py_dir / "site-packages"
    rv.mkdir(parents=True)
    monkeypatch.syspath_prepend(os.fspath(rv))
    return rv
@pytest.fixture
def purge_module(request):
    def inner(name):
        request.addfinalizer(lambda: sys.modules.pop(name, None))

    return inner

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: AppError
Type: class
Parent Type: 
Location: /home/yuesheng/flask/tests/test_async.py,207,242
Arguments: []
Code: class AppError(Exception):
    pass
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: BlueprintError
Type: class
Parent Type: 
Location: /home/yuesheng/flask/tests/test_async.py,245,286
Arguments: []
Code: class BlueprintError(Exception):
    pass
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: AsyncView
Type: class
Parent Type: 
Location: /home/yuesheng/flask/tests/test_async.py,289,347
Arguments: []
Code: class AsyncView(View):
    methods = ["GET", "POST"]

    # Code for function: AsyncView.dispatch_request(self)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: dispatch_request
Type: function
Parent Type: AsyncView
Location: /home/yuesheng/flask/tests/test_async.py,347,441
Arguments: ['self']
Code: async def dispatch_request(self):
        await asyncio.sleep(0)
        return request.method
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: AsyncMethodView
Type: class
Parent Type: 
Location: /home/yuesheng/flask/tests/test_async.py,444,483
Arguments: []
Code: class AsyncMethodView(MethodView):
    # Code for function: AsyncMethodView.get(self)
# Code for function: AsyncMethodView.post(self)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get
Type: function
Parent Type: AsyncMethodView
Location: /home/yuesheng/flask/tests/test_async.py,483,555
Arguments: ['self']
Code: async def get(self):
        await asyncio.sleep(0)
        return "GET"
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: post
Type: function
Parent Type: AsyncMethodView
Location: /home/yuesheng/flask/tests/test_async.py,561,635
Arguments: ['self']
Code: async def post(self):
        await asyncio.sleep(0)
        return "POST"
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_async_before_after_request
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_async.py,2192,3334
Arguments: ['', 'response', '', '', '', '', 'response']
Code: // Code for Global Scope
import asyncio
import pytest
from flask import Blueprint
from flask import Flask
from flask import request
from flask.views import MethodView
from flask.views import View
pytest.importorskip("asgiref")
# Code for class: AppError()
# Code for class: BlueprintError()
# Code for class: AsyncView()
# Code for function: AsyncView.dispatch_request(self)
# Code for class: AsyncMethodView()
# Code for function: AsyncMethodView.get(self)
# Code for function: AsyncMethodView.post(self)
@pytest.fixture(name="async_app")
def _async_app():
    app = Flask(__name__)

    @app.route("/", methods=["GET", "POST"])
    @app.route("/home", methods=["GET", "POST"])
    async def index():
        await asyncio.sleep(0)
        return request.method

    @app.errorhandler(AppError)
    async def handle(_):
        return "", 412

    @app.route("/error")
    async def error():
        raise AppError()

    blueprint = Blueprint("bp", __name__)

    @blueprint.route("/", methods=["GET", "POST"])
    async def bp_index():
        await asyncio.sleep(0)
        return request.method

    @blueprint.errorhandler(BlueprintError)
    async def bp_handle(_):
        return "", 412

    @blueprint.route("/error")
    async def bp_error():
        raise BlueprintError()

    app.register_blueprint(blueprint, url_prefix="/bp")

    app.add_url_rule("/view", view_func=AsyncView.as_view("view"))
    app.add_url_rule("/methodview", view_func=AsyncMethodView.as_view("methodview"))

    return app
@pytest.mark.parametrize("path", ["/", "/home", "/bp/", "/view", "/methodview"])
def test_async_route(path, async_app):
    test_client = async_app.test_client()
    response = test_client.get(path)
    assert b"GET" in response.get_data()
    response = test_client.post(path)
    assert b"POST" in response.get_data()
@pytest.mark.parametrize("path", ["/error", "/bp/error"])
def test_async_error_handler(path, async_app):
    test_client = async_app.test_client()
    response = test_client.get(path)
    assert response.status_code == 412
# Code for function: test_async_before_after_request(, response, , , , , response)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_error_handler_no_match
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_user_error_handler.py,211,1639
Arguments: ['app', 'client', 'e', '', '', 'e', '']
Code: def report_error(self, e):
        original = getattr(e, "original_exception", None)

        if original is not None:
            return f"wrapped {type(original).__name__}"

        return f"direct {type(e).__name__}"
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_error_handler_subclass
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_user_error_handler.py,1642,2683
Arguments: ['app', '', 'e', '', 'e', '']
Code: def test_handle_generic_http(self, app, client):
        """``HTTPException`` should only receive ``HTTPException``
        subclasses. It will receive ``404`` routing exceptions.
        """

        @app.errorhandler(HTTPException)
        def handle_http(e):
            assert isinstance(e, HTTPException)
            return str(e.code)

        assert client.get("/error").data == b"500"
        assert client.get("/abort").data == b"500"
        assert client.get("/not-found").data == b"404"
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_error_handler_http_subclass
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_user_error_handler.py,2686,3705
Arguments: ['app', 'e', 'e', '', '', '']
Code: def test_handle_generic(self, app, client):
        """Generic ``Exception`` will handle all exceptions directly,
        including ``HTTPExceptions``.
        """

        @app.errorhandler(Exception)
        def handle_exception(e):
            return self.report_error(e)

        assert client.get("/custom").data == b"direct Custom"
        assert client.get("/error").data == b"direct KeyError"
        assert client.get("/abort").data == b"direct InternalServerError"
        assert client.get("/not-found").data == b"direct NotFound"
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_error_handler_blueprint
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_user_error_handler.py,3708,4300
Arguments: ['app', 'e', '', 'e', '']
Code: class TestGenericHandlers:
    """Test how very generic handlers are dispatched to."""

    class Custom(Exception):
        pass

    @pytest.fixture()
    def app(self, app):
        @app.route("/custom")
        def do_custom():
            raise self.Custom()

        @app.route("/error")
        def do_error():
            raise KeyError()

        @app.route("/abort")
        def do_abort():
            flask.abort(500)

        @app.route("/raise")
        def do_raise():
            raise InternalServerError()

        app.config["PROPAGATE_EXCEPTIONS"] = False
        return app

    # Code for function: TestGenericHandlers.report_error(self, e)
# Code for function: TestGenericHandlers.test_handle_generic_http(self, app, client, e)
# Code for function: TestGenericHandlers.test_handle_generic(self, app, client, e)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_default_error_handler
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_user_error_handler.py,4303,5785
Arguments: ['', 'e', '', 'e', '', 'e', 'e', '', '']
Code: // Code for Global Scope
import pytest
from werkzeug.exceptions import Forbidden
from werkzeug.exceptions import HTTPException
from werkzeug.exceptions import InternalServerError
from werkzeug.exceptions import NotFound
import flask
# Code for function: test_error_handler_no_match(app, client, e, , , e, )
# Code for function: test_error_handler_subclass(app, , e, , e, )
# Code for function: test_error_handler_http_subclass(app, e, e, , , )
# Code for function: test_error_handler_blueprint(app, e, , e, )
# Code for function: test_default_error_handler(, e, , e, , e, e, , )
# Code for class: TestGenericHandlers()
# Code for function: TestGenericHandlers.report_error(self, e)
# Code for function: TestGenericHandlers.test_handle_generic_http(self, app, client, e)
# Code for function: TestGenericHandlers.test_handle_generic(self, app, client, e)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: FakePath
Type: class
Parent Type: 
Location: /home/yuesheng/flask/tests/test_helpers.py,119,314
Arguments: ['self', 'path']
Code: class FakePath:
    """Fake object to represent a ``PathLike object``.

    This represents a ``pathlib.Path`` object in python 3.
    See: https://www.python.org/dev/peps/pep-0519/
    """

    # Code for function: FakePath.__init__(self, path)
# Code for function: FakePath.__fspath__(self)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: FakePath
Location: /home/yuesheng/flask/tests/test_helpers.py,314,364
Arguments: ['self', 'path']
Code: def __init__(self, path):
        self.path = path
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __fspath__
Type: function
Parent Type: FakePath
Location: /home/yuesheng/flask/tests/test_helpers.py,370,416
Arguments: ['self']
Code: def __fspath__(self):
        return self.path
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: PyBytesIO
Type: class
Parent Type: 
Location: /home/yuesheng/flask/tests/test_helpers.py,419,440
Arguments: ['self', '*args', '**kwargs']
Code: class PyBytesIO:
    # Code for function: PyBytesIO.__init__(self, *args, **kwargs)
# Code for function: PyBytesIO.__getattr__(self, name)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: PyBytesIO
Location: /home/yuesheng/flask/tests/test_helpers.py,440,523
Arguments: ['self', '*args', '**kwargs']
Code: def __init__(self, *args, **kwargs):
        self._io = io.BytesIO(*args, **kwargs)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __getattr__
Type: function
Parent Type: PyBytesIO
Location: /home/yuesheng/flask/tests/test_helpers.py,529,596
Arguments: ['self', 'name']
Code: def __getattr__(self, name):
        return getattr(self._io, name)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: TestSendfile
Type: class
Parent Type: 
Location: /home/yuesheng/flask/tests/test_helpers.py,599,623
Arguments: []
Code: class TestSendfile:
    # Code for function: TestSendfile.test_send_file(self, app, req_ctx)
# Code for function: TestSendfile.test_static_file(self, app, req_ctx, self, filename)
# Code for function: TestSendfile.test_send_from_directory(self, app, req_ctx)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_send_file
Type: function
Parent Type: TestSendfile
Location: /home/yuesheng/flask/tests/test_helpers.py,623,951
Arguments: ['self', 'app', 'req_ctx']
Code: def test_send_file(self, app, req_ctx):
        rv = flask.send_file("static/index.html")
        assert rv.direct_passthrough
        assert rv.mimetype == "text/html"

        with app.open_resource("static/index.html") as f:
            rv.direct_passthrough = False
            assert rv.data == f.read()

        rv.close()
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_static_file
Type: function
Parent Type: TestSendfile
Location: /home/yuesheng/flask/tests/test_helpers.py,957,2441
Arguments: ['self', 'app', 'req_ctx', 'self', 'filename']
Code: def test_static_file(self, app, req_ctx):
        # Default max_age is None.

        # Test with static file handler.
        rv = app.send_static_file("index.html")
        assert rv.cache_control.max_age is None
        rv.close()

        # Test with direct use of send_file.
        rv = flask.send_file("static/index.html")
        assert rv.cache_control.max_age is None
        rv.close()

        app.config["SEND_FILE_MAX_AGE_DEFAULT"] = 3600

        # Test with static file handler.
        rv = app.send_static_file("index.html")
        assert rv.cache_control.max_age == 3600
        rv.close()

        # Test with direct use of send_file.
        rv = flask.send_file("static/index.html")
        assert rv.cache_control.max_age == 3600
        rv.close()

        # Test with pathlib.Path.
        rv = app.send_static_file(FakePath("index.html"))
        assert rv.cache_control.max_age == 3600
        rv.close()

        class StaticFileApp(flask.Flask):
            def get_send_file_max_age(self, filename):
                return 10

        app = StaticFileApp(__name__)

        with app.test_request_context():
            # Test with static file handler.
            rv = app.send_static_file("index.html")
            assert rv.cache_control.max_age == 10
            rv.close()

            # Test with direct use of send_file.
            rv = flask.send_file("static/index.html")
            assert rv.cache_control.max_age == 10
            rv.close()
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_send_from_directory
Type: function
Parent Type: TestSendfile
Location: /home/yuesheng/flask/tests/test_helpers.py,2447,2790
Arguments: ['self', 'app', 'req_ctx']
Code: def test_send_from_directory(self, app, req_ctx):
        app.root_path = os.path.join(
            os.path.dirname(__file__), "test_apps", "subdomaintestmodule"
        )
        rv = flask.send_from_directory("static", "hello.txt")
        rv.direct_passthrough = False
        assert rv.data.strip() == b"Hello Subdomain"
        rv.close()
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: TestUrlFor
Type: class
Parent Type: 
Location: /home/yuesheng/flask/tests/test_helpers.py,2793,2815
Arguments: []
Code: class TestUrlFor:
    # Code for function: TestUrlFor.test_url_for_with_anchor(self, app, req_ctx, )
# Code for function: TestUrlFor.test_url_for_with_scheme(self, app, req_ctx, )
# Code for function: TestUrlFor.test_url_for_with_scheme_not_external(self, app, req_ctx)
# Code for function: TestUrlFor.test_url_for_with_alternating_schemes(self, app, req_ctx, )
# Code for function: TestUrlFor.test_url_with_method(self, app, req_ctx, self, self, id=None)
# Code for function: TestUrlFor.test_url_for_with_self(self, app, req_ctx, self)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_url_for_with_anchor
Type: function
Parent Type: TestUrlFor
Location: /home/yuesheng/flask/tests/test_helpers.py,2815,3000
Arguments: ['self', 'app', 'req_ctx', '']
Code: def test_url_for_with_anchor(self, app, req_ctx):
        @app.route("/")
        def index():
            return "42"

        assert flask.url_for("index", _anchor="x y") == "/#x%20y"
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_url_for_with_scheme
Type: function
Parent Type: TestUrlFor
Location: /home/yuesheng/flask/tests/test_helpers.py,3006,3256
Arguments: ['self', 'app', 'req_ctx', '']
Code: def test_url_for_with_scheme(self, app, req_ctx):
        @app.route("/")
        def index():
            return "42"

        assert (
            flask.url_for("index", _external=True, _scheme="https")
            == "https://localhost/"
        )
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_url_for_with_scheme_not_external
Type: function
Parent Type: TestUrlFor
Location: /home/yuesheng/flask/tests/test_helpers.py,3262,3669
Arguments: ['self', 'app', 'req_ctx']
Code: def test_url_for_with_scheme_not_external(self, app, req_ctx):
        app.add_url_rule("/", endpoint="index")

        # Implicit external with scheme.
        url = flask.url_for("index", _scheme="https")
        assert url == "https://localhost/"

        # Error when external=False with scheme
        with pytest.raises(ValueError):
            flask.url_for("index", _scheme="https", _external=False)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_url_for_with_alternating_schemes
Type: function
Parent Type: TestUrlFor
Location: /home/yuesheng/flask/tests/test_helpers.py,3675,4092
Arguments: ['self', 'app', 'req_ctx', '']
Code: def test_url_for_with_alternating_schemes(self, app, req_ctx):
        @app.route("/")
        def index():
            return "42"

        assert flask.url_for("index", _external=True) == "http://localhost/"
        assert (
            flask.url_for("index", _external=True, _scheme="https")
            == "https://localhost/"
        )
        assert flask.url_for("index", _external=True) == "http://localhost/"
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_url_with_method
Type: function
Parent Type: TestUrlFor
Location: /home/yuesheng/flask/tests/test_helpers.py,4098,4915
Arguments: ['self', 'app', 'req_ctx', 'self', 'self', 'id=None']
Code: def test_url_with_method(self, app, req_ctx):
        from flask.views import MethodView

        class MyView(MethodView):
            def get(self, id=None):
                if id is None:
                    return "List"
                return f"Get {id:d}"

            def post(self):
                return "Create"

        myview = MyView.as_view("myview")
        app.add_url_rule("/myview/", methods=["GET"], view_func=myview)
        app.add_url_rule("/myview/<int:id>", methods=["GET"], view_func=myview)
        app.add_url_rule("/myview/create", methods=["POST"], view_func=myview)

        assert flask.url_for("myview", _method="GET") == "/myview/"
        assert flask.url_for("myview", id=42, _method="GET") == "/myview/42"
        assert flask.url_for("myview", _method="POST") == "/myview/create"
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_url_for_with_self
Type: function
Parent Type: TestUrlFor
Location: /home/yuesheng/flask/tests/test_helpers.py,4921,5104
Arguments: ['self', 'app', 'req_ctx', 'self']
Code: def test_url_for_with_self(self, app, req_ctx):
        @app.route("/<self>")
        def index(self):
            return "42"

        assert flask.url_for("index", self="2") == "/2"
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_redirect_no_app
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_helpers.py,5107,5281
Arguments: ['']
Code: def test_name_with_import_error(self, modules_tmp_path):
        (modules_tmp_path / "importerror.py").write_text("raise NotImplementedError()")
        try:
            flask.Flask("importerror")
        except NotImplementedError:
            AssertionError("Flask(import_name) is importing import_name.")
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_redirect_with_app
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_helpers.py,5284,5496
Arguments: ['app', 'location', 'code=302']
Code: class TestNoImports:
    """Test Flasks are created without import.

    Avoiding ``__import__`` helps create Flask instances where there are errors
    at import time.  Those runtime errors will be apparent to the user soon
    enough, but tools which build Flask instances meta-programmatically benefit
    from a Flask which does not ``__import__``.  Instead of importing to
    retrieve file paths or metadata on a module or package, use the pkgutil and
    imp modules in the Python standard library.
    """

    # Code for function: TestNoImports.test_name_with_import_error(self, modules_tmp_path)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_abort_no_app
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_helpers.py,5499,5669
Arguments: ['']
Code: def test_streaming_with_context(self, app, client):
        @app.route("/")
        def index():
            def generate():
                yield "Hello "
                yield flask.request.args["name"]
                yield "!"

            return flask.Response(flask.stream_with_context(generate()))

        rv = client.get("/?name=World")
        assert rv.data == b"Hello World!"
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_app_aborter_class
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_helpers.py,5672,5906
Arguments: ['']
Code: def test_streaming_with_context_as_decorator(self, app, client):
        @app.route("/")
        def index():
            @flask.stream_with_context
            def generate(hello):
                yield hello
                yield flask.request.args["name"]
                yield "!"

            return flask.Response(generate("Hello "))

        rv = client.get("/?name=World")
        assert rv.data == b"Hello World!"
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_abort_with_app
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_helpers.py,5909,6138
Arguments: ['app']
Code: def test_streaming_with_context_and_custom_close(self, app, client):
        called = []

        class Wrapper:
            def __init__(self, gen):
                self._gen = gen

            def __iter__(self):
                return self

            def close(self):
                called.append(42)

            def __next__(self):
                return next(self._gen)

            next = __next__

        @app.route("/")
        def index():
            def generate():
                yield "Hello "
                yield flask.request.args["name"]
                yield "!"

            return flask.Response(flask.stream_with_context(Wrapper(generate())))

        rv = client.get("/?name=World")
        assert rv.data == b"Hello World!"
        assert called == [42]
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: TestNoImports
Type: class
Parent Type: 
Location: /home/yuesheng/flask/tests/test_helpers.py,6141,6660
Arguments: []
Code: class TestStreaming:
    # Code for function: TestStreaming.test_streaming_with_context(self, app, client, , )
# Code for function: TestStreaming.test_streaming_with_context_as_decorator(self, app, client, , hello)
# Code for function: TestStreaming.test_streaming_with_context_and_custom_close(self, app, client, self, gen, self, self, self, , )
# Code for function: TestStreaming.test_stream_keeps_session(self, app, client, , )

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_name_with_import_error
Type: function
Parent Type: TestNoImports
Location: /home/yuesheng/flask/tests/test_helpers.py,6660,6967
Arguments: ['self', 'modules_tmp_path']
Code: def test_stream_keeps_session(self, app, client):
        @app.route("/")
        def index():
            flask.session["test"] = "flask"

            @flask.stream_with_context
            def gen():
                yield flask.session["test"]

            return flask.Response(gen())

        rv = client.get("/")
        assert rv.data == b"flask"
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_streaming_with_context
Type: function
Parent Type: TestStreaming
Location: /home/yuesheng/flask/tests/test_helpers.py,6995,7382
Arguments: ['self', 'app', 'client', '', '']
Code: def test_make_response(self):
        app = flask.Flask(__name__)
        with app.test_request_context():
            rv = flask.helpers.make_response()
            assert rv.status_code == 200
            assert rv.mimetype == "text/html"

            rv = flask.helpers.make_response("Hello")
            assert rv.status_code == 200
            assert rv.data == b"Hello"
            assert rv.mimetype == "text/html"
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_streaming_with_context_as_decorator
Type: function
Parent Type: TestStreaming
Location: /home/yuesheng/flask/tests/test_helpers.py,7388,7810
Arguments: ['self', 'app', 'client', '', 'hello']
Code: class TestHelpers:
    @pytest.mark.parametrize(
        ("debug", "expect"),
        [
            ("", False),
            ("0", False),
            ("False", False),
            ("No", False),
            ("True", True),
        ],
    )
    def test_get_debug_flag(self, monkeypatch, debug, expect):
        monkeypatch.setenv("FLASK_DEBUG", debug)
        assert get_debug_flag() == expect

    # Code for function: TestHelpers.test_make_response(self)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_streaming_with_context_and_custom_close
Type: function
Parent Type: TestStreaming
Location: /home/yuesheng/flask/tests/test_helpers.py,7816,8599
Arguments: ['self', 'app', 'client', 'self', 'gen', 'self', 'self', 'self', '', '']
Code: // Code for Global Scope
import io
import os
import pytest
import werkzeug.exceptions
import flask
from flask.helpers import get_debug_flag
# Code for class: FakePath(self, path)
# Code for function: FakePath.__init__(self, path)
# Code for function: FakePath.__fspath__(self)
# Code for class: PyBytesIO(self, *args, **kwargs)
# Code for function: PyBytesIO.__init__(self, *args, **kwargs)
# Code for function: PyBytesIO.__getattr__(self, name)
# Code for class: TestSendfile()
# Code for function: TestSendfile.test_send_file(self, app, req_ctx)
# Code for function: TestSendfile.test_static_file(self, app, req_ctx, self, filename)
# Code for function: TestSendfile.test_send_from_directory(self, app, req_ctx)
# Code for class: TestUrlFor()
# Code for function: TestUrlFor.test_url_for_with_anchor(self, app, req_ctx, )
# Code for function: TestUrlFor.test_url_for_with_scheme(self, app, req_ctx, )
# Code for function: TestUrlFor.test_url_for_with_scheme_not_external(self, app, req_ctx)
# Code for function: TestUrlFor.test_url_for_with_alternating_schemes(self, app, req_ctx, )
# Code for function: TestUrlFor.test_url_with_method(self, app, req_ctx, self, self, id=None)
# Code for function: TestUrlFor.test_url_for_with_self(self, app, req_ctx, self)
# Code for function: test_redirect_no_app()
# Code for function: test_redirect_with_app(app, location, code=302)
# Code for function: test_abort_no_app()
# Code for function: test_app_aborter_class()
# Code for function: test_abort_with_app(app)
# Code for class: TestNoImports()
# Code for function: TestNoImports.test_name_with_import_error(self, modules_tmp_path)
# Code for class: TestStreaming()
# Code for function: TestStreaming.test_streaming_with_context(self, app, client, , )
# Code for function: TestStreaming.test_streaming_with_context_as_decorator(self, app, client, , hello)
# Code for function: TestStreaming.test_streaming_with_context_and_custom_close(self, app, client, self, gen, self, self, self, , )
# Code for function: TestStreaming.test_stream_keeps_session(self, app, client, , )
# Code for class: TestHelpers()
# Code for function: TestHelpers.test_make_response(self)
@pytest.mark.parametrize("mode", ("r", "rb", "rt"))
def test_open_resource(mode):
    app = flask.Flask(__name__)

    with app.open_resource("static/index.html", mode) as f:
        assert "<h1>Hello World!</h1>" in str(f.read())
@pytest.mark.parametrize("mode", ("w", "x", "a", "r+"))
def test_open_resource_exceptions(mode):
    app = flask.Flask(__name__)

    with pytest.raises(ValueError):
        app.open_resource("static/index.html", mode)
@pytest.mark.parametrize("encoding", ("utf-8", "utf-16-le"))
def test_open_resource_with_encoding(tmp_path, encoding):
    app = flask.Flask(__name__, root_path=os.fspath(tmp_path))
    (tmp_path / "test").write_text("test", encoding=encoding)

    with app.open_resource("test", mode="rt", encoding=encoding) as f:
        assert f.read() == "test"

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_blueprint_specific_error_handling
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_blueprints.py,119,1215
Arguments: ['app', 'client', '', '', 'e', 'e', '', 'e']
Code: // Code for Global Scope
import pytest
from jinja2 import TemplateNotFound
from werkzeug.http import parse_cache_control_header
import flask
# Code for function: test_blueprint_specific_error_handling(app, client, , , e, e, , e)
# Code for function: test_blueprint_specific_user_error_handling(app, client, , , e, e)
# Code for function: test_blueprint_app_error_handling(app, client, e, , )
@pytest.mark.parametrize(
    ("prefix", "rule", "url"),
    (
        ("", "/", "/"),
        ("/", "", "/"),
        ("/", "/", "/"),
        ("/foo", "", "/foo"),
        ("/foo/", "", "/foo/"),
        ("", "/bar", "/bar"),
        ("/foo/", "/bar", "/foo/bar"),
        ("/foo/", "bar", "/foo/bar"),
        ("/foo", "/bar", "/foo/bar"),
        ("/foo/", "//bar", "/foo/bar"),
        ("/foo//", "/bar", "/foo/bar"),
    ),
)
def test_blueprint_prefix_slash(app, client, prefix, rule, url):
    bp = flask.Blueprint("test", __name__, url_prefix=prefix)

    @bp.route(rule)
    def index():
        return "", 204

    app.register_blueprint(bp)
    assert client.get(url).status_code == 204
# Code for function: test_blueprint_url_defaults(app, client, bar, bar, baz)
# Code for function: test_blueprint_url_processors(app, client, endpoint, values, endpoint, values, , )
# Code for function: test_templates_and_static(test_apps)
# Code for function: test_default_static_max_age(app, self, filename)
# Code for function: test_templates_list(test_apps)
# Code for function: test_dotted_name_not_allowed(app, client)
# Code for function: test_empty_name_not_allowed(app, client)
# Code for function: test_dotted_names_from_app(app, client, , )
# Code for function: test_empty_url_defaults(app, client, page)
# Code for function: test_route_decorator_custom_endpoint(app, client, , , , , )
# Code for function: test_route_decorator_custom_endpoint_with_dots(app, client, )
# Code for function: test_endpoint_decorator(app, client, )
# Code for function: test_template_filter(app, s)
# Code for function: test_add_template_filter(app, s)
# Code for function: test_template_filter_with_name(app, s)
# Code for function: test_add_template_filter_with_name(app, s)
# Code for function: test_template_filter_with_template(app, client, s, )
# Code for function: test_template_filter_after_route_with_template(app, client, s, )
# Code for function: test_add_template_filter_with_template(app, client, s, )
# Code for function: test_template_filter_with_name_and_template(app, client, s, )
# Code for function: test_add_template_filter_with_name_and_template(app, client, s, )
# Code for function: test_template_test(app, value)
# Code for function: test_add_template_test(app, value)
# Code for function: test_template_test_with_name(app, value)
# Code for function: test_add_template_test_with_name(app, value)
# Code for function: test_template_test_with_template(app, client, , value)
# Code for function: test_template_test_after_route_with_template(app, client, , value)
# Code for function: test_add_template_test_with_template(app, client, , value)
# Code for function: test_template_test_with_name_and_template(app, client, value, )
# Code for function: test_add_template_test_with_name_and_template(app, client, , value)
# Code for function: test_context_processing(app, client, , , , , )
# Code for function: test_template_global(app, )
# Code for function: test_request_processing(app, client, response, exc, , )
# Code for function: test_app_request_processing(app, client, exc, , , response)
# Code for function: test_app_url_processors(app, client, , endpoint, values, , endpoint, values)
# Code for function: test_nested_blueprint(app, client, , e, , , , e, , )
# Code for function: test_nested_callback_order(e=None, , , e=None, , app, client, e=None, e=None, , , , , e=None, , e=None, , , )
@pytest.mark.parametrize(
    "parent_init, child_init, parent_registration, child_registration",
    [
        ("/parent", "/child", None, None),
        ("/parent", None, None, "/child"),
        (None, None, "/parent", "/child"),
        ("/other", "/something", "/parent", "/child"),
    ],
)
def test_nesting_url_prefixes(
    parent_init,
    child_init,
    parent_registration,
    child_registration,
    app,
    client,
) -> None:
    parent = flask.Blueprint("parent", __name__, url_prefix=parent_init)
    child = flask.Blueprint("child", __name__, url_prefix=child_init)

    @child.route("/")
    def index():
        return "index"

    parent.register_blueprint(child, url_prefix=child_registration)
    app.register_blueprint(parent, url_prefix=parent_registration)

    response = client.get("/parent/child/")
    assert response.status_code == 200
# Code for function: test_nesting_subdomains(app, client, )
# Code for function: test_child_and_parent_subdomain(app, client, )
# Code for function: test_unique_blueprint_names(app, client)
# Code for function: test_self_registration(app, client)
# Code for function: test_blueprint_renaming(app, client, , , , _: Exception)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_context_processing
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_templating.py,136,441
Arguments: ['app', 'client', '', '']
Code: // Code for Global Scope
import logging
import pytest
import werkzeug.serving
from jinja2 import TemplateNotFound
from markupsafe import Markup
import flask
# Code for function: test_context_processing(app, client, , )
# Code for function: test_original_win(app, client, )
# Code for function: test_simple_stream(app, client, )
# Code for function: test_request_less_rendering(app, app_ctx, )
# Code for function: test_standard_context(app, client, )
# Code for function: test_escaping(app, client, )
# Code for function: test_no_escaping(app, client, )
# Code for function: test_escaping_without_template_filename(app, client, req_ctx)
# Code for function: test_macros(app, req_ctx)
# Code for function: test_template_filter(app, s)
# Code for function: test_add_template_filter(app, s)
# Code for function: test_template_filter_with_name(app, s)
# Code for function: test_add_template_filter_with_name(app, s)
# Code for function: test_template_filter_with_template(app, client, s, )
# Code for function: test_add_template_filter_with_template(app, client, s, )
# Code for function: test_template_filter_with_name_and_template(app, client, , s)
# Code for function: test_add_template_filter_with_name_and_template(app, client, , s)
# Code for function: test_template_test(app, value)
# Code for function: test_add_template_test(app, value)
# Code for function: test_template_test_with_name(app, value)
# Code for function: test_add_template_test_with_name(app, value)
# Code for function: test_template_test_with_template(app, client, value, )
# Code for function: test_add_template_test_with_template(app, client, , value)
# Code for function: test_template_test_with_name_and_template(app, client, value, )
# Code for function: test_add_template_test_with_name_and_template(app, client, , value)
# Code for function: test_add_template_global(app, app_ctx, )
# Code for function: test_custom_template_loader(client, , self)
# Code for function: test_iterable_loader(app, client, , )
# Code for function: test_templates_auto_reload(app)
# Code for function: test_templates_auto_reload_debug_run(app, monkeypatch, *args, **kwargs)
# Code for function: test_template_loader_debugging(test_apps, monkeypatch, self, record)
# Code for function: test_custom_jinja_env()

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_teardown_on_pop
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_reqctx.py,265,525
Arguments: ['app', 'exception']
Code: // Code for Global Scope
import warnings
import pytest
import flask
from flask.globals import request_ctx
from flask.sessions import SecureCookieSessionInterface
from flask.sessions import SessionInterface
try:
    from greenlet import greenlet
except ImportError:
    greenlet = None
# Code for function: test_teardown_on_pop(app, exception)
# Code for function: test_teardown_with_previous_exception(app, exception)
# Code for function: test_teardown_with_handled_exception(app, exception)
# Code for function: test_proper_test_request_context(app, , )
# Code for function: test_context_binding(app, , )
# Code for function: test_context_test(app)
# Code for function: test_manual_context_binding(app, )
@pytest.mark.skipif(greenlet is None, reason="greenlet not installed")
class TestGreenletContextCopying:
    def test_greenlet_context_copying(self, app, client):
        greenlets = []

        @app.route("/")
        def index():
            flask.session["fizz"] = "buzz"
            reqctx = request_ctx.copy()

            def g():
                assert not flask.request
                assert not flask.current_app
                with reqctx:
                    assert flask.request
                    assert flask.current_app == app
                    assert flask.request.path == "/"
                    assert flask.request.args["foo"] == "bar"
                    assert flask.session.get("fizz") == "buzz"
                assert not flask.request
                return 42

            greenlets.append(greenlet(g))
            return "Hello World!"

        rv = client.get("/?foo=bar")
        assert rv.data == b"Hello World!"

        result = greenlets[0].run()
        assert result == 42

    def test_greenlet_context_copying_api(self, app, client):
        greenlets = []

        @app.route("/")
        def index():
            flask.session["fizz"] = "buzz"

            @flask.copy_current_request_context
            def g():
                assert flask.request
                assert flask.current_app == app
                assert flask.request.path == "/"
                assert flask.request.args["foo"] == "bar"
                assert flask.session.get("fizz") == "buzz"
                return 42

            greenlets.append(greenlet(g))
            return "Hello World!"

        rv = client.get("/?foo=bar")
        assert rv.data == b"Hello World!"

        result = greenlets[0].run()
        assert result == 42
# Code for function: test_session_error_pops_context(, , self, app, request)
# Code for function: test_session_dynamic_cookie_name(, , self, app, , , )
# Code for function: test_bad_environ_raises_bad_request()
# Code for function: test_environ_for_valid_idna_completes(, )
# Code for function: test_normal_environ_completes(, )

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_max_content_length
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_request.py,152,512
Arguments: ['app: Flask', 'client: FlaskClient', 'error', '']
Code: // Code for Global Scope
from __future__ import annotations
from flask import Flask
from flask import Request
from flask import request
from flask.testing import FlaskClient
# Code for function: test_max_content_length(app: Flask, client: FlaskClient, error, )
# Code for function: test_limit_config(app: Flask)
# Code for function: test_trusted_hosts_config(app: Flask, )

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: common_test
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_views.py,79,384
Arguments: ['app']
Code: // Code for Global Scope
import pytest
from werkzeug.http import parse_set_header
import flask.views
# Code for function: common_test(app)
# Code for function: test_basic_view(app, self)
# Code for function: test_method_based_view(app, self, self)
# Code for function: test_view_patching(app, self, self, self, self)
# Code for function: test_view_inheritance(app, client, self, self, self)
# Code for function: test_view_decorators(app, client, self, f, *args, **kwargs)
# Code for function: test_view_provide_automatic_options_attr(, self, self, self)
# Code for function: test_implicit_head(app, client, self)
# Code for function: test_explicit_head(app, client, self, self)
# Code for function: test_endpoint_override(app, self)
# Code for function: test_methods_var_inheritance(app, client, self, self)
# Code for function: test_multiple_inheritance(app, client, self, self)
# Code for function: test_remove_method_from_parent(app, client, self, self)
# Code for function: test_init_once(app, client, self, self)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_json_bad_requests
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_json.py,696,980
Arguments: ['app', 'client', '']
Code: def __init__(self, hours, name):
        self.__offset = datetime.timedelta(hours=hours)
        self.__name = name
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_json_custom_mimetypes
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_json.py,983,1241
Arguments: ['app', 'client', '']
Code: def utcoffset(self, dt):
        return self.__offset
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_json_dump_to_file
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_json.py,1510,1719
Arguments: ['app', 'app_ctx']
Code: def tzname(self, dt):
        return self.__name
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_jsonify_dicts
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_json.py,2111,2679
Arguments: ['app', 'client', '', '']
Code: def dst(self, dt):
        return datetime.timedelta()
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_jsonify_arrays
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_json.py,2682,3305
Arguments: ['app', 'client', '', '']
Code: class FixedOffset(datetime.tzinfo):
    """Fixed offset in hours east from UTC.

    This is a slight adaptation of the ``FixedOffset`` example found in
    https://docs.python.org/2.7/library/datetime.html.
    """

    # Code for function: FixedOffset.__init__(self, hours, name)
# Code for function: FixedOffset.utcoffset(self, dt)
# Code for function: FixedOffset.tzname(self, dt)
# Code for function: FixedOffset.dst(self, dt)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: FixedOffset
Location: /home/yuesheng/flask/tests/test_json.py,3838,3953
Arguments: ['self', 'hours', 'name']
Code: // Code for Global Scope
import datetime
import decimal
import io
import uuid
import pytest
from werkzeug.http import http_date
import flask
from flask import json
from flask.json.provider import DefaultJSONProvider
@pytest.mark.parametrize("debug", (True, False))
def test_bad_request_debug_message(app, client, debug):
    app.config["DEBUG"] = debug
    app.config["TRAP_BAD_REQUEST_ERRORS"] = False

    @app.route("/json", methods=["POST"])
    def post_json():
        flask.request.get_json()
        return None

    rv = client.post("/json", data=None, content_type="application/json")
    assert rv.status_code == 400
    contains = b"Failed to decode JSON object" in rv.data
    assert contains == debug
# Code for function: test_json_bad_requests(app, client, )
# Code for function: test_json_custom_mimetypes(app, client, )
@pytest.mark.parametrize(
    "test_value,expected", [(True, '"\\u2603"'), (False, '"\u2603"')]
)
def test_json_as_unicode(test_value, expected, app, app_ctx):
    app.json.ensure_ascii = test_value
    rv = app.json.dumps("\N{SNOWMAN}")
    assert rv == expected
# Code for function: test_json_dump_to_file(app, app_ctx)
@pytest.mark.parametrize(
    "test_value", [0, -1, 1, 23, 3.14, "s", "longer string", True, False, None]
)
def test_jsonify_basic_types(test_value, app, client):
    url = "/jsonify_basic_types"
    app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))
    rv = client.get(url)
    assert rv.mimetype == "application/json"
    assert flask.json.loads(rv.data) == test_value
# Code for function: test_jsonify_dicts(app, client, , )
# Code for function: test_jsonify_arrays(app, client, , )
@pytest.mark.parametrize(
    "value", [datetime.datetime(1973, 3, 11, 6, 30, 45), datetime.date(1975, 1, 5)]
)
def test_jsonify_datetime(app, client, value):
    @app.route("/")
    def index():
        return flask.jsonify(value=value)

    r = client.get()
    assert r.json["value"] == http_date(value)
# Code for class: FixedOffset(self, hours, name)
# Code for function: FixedOffset.__init__(self, hours, name)
# Code for function: FixedOffset.utcoffset(self, dt)
# Code for function: FixedOffset.tzname(self, dt)
# Code for function: FixedOffset.dst(self, dt)
@pytest.mark.parametrize("tz", (("UTC", 0), ("PST", -8), ("KST", 9)))
def test_jsonify_aware_datetimes(tz):
    """Test if aware datetime.datetime objects are converted into GMT."""
    tzinfo = FixedOffset(hours=tz[1], name=tz[0])
    dt = datetime.datetime(2017, 1, 1, 12, 34, 56, tzinfo=tzinfo)
    gmt = FixedOffset(hours=0, name="GMT")
    expected = dt.astimezone(gmt).strftime('"%a, %d %b %Y %H:%M:%S %Z"')
    assert flask.json.dumps(dt) == expected
# Code for function: test_jsonify_uuid_types(app, client)
# Code for function: test_json_decimal()
# Code for function: test_json_attr(app, client, )
# Code for function: test_tojson_filter(app, req_ctx)
# Code for function: test_json_customization(app, client, self, s, **kwargs, o, self, val, self, obj, )
# Code for function: _has_encoding(name)
# Code for function: test_json_key_sorting(app, client, )
# Code for function: test_html_method(, self)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_basic_url_generation
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_appctx.py,102,388
Arguments: ['app', '']
Code: // Code for Global Scope
import pytest
import flask
from flask.globals import app_ctx
from flask.globals import request_ctx
# Code for function: test_basic_url_generation(app, )
# Code for function: test_url_generation_requires_server_name(app)
# Code for function: test_url_generation_without_context_fails()
# Code for function: test_request_context_means_app_context(app)
# Code for function: test_app_context_provides_current_app(app)
# Code for function: test_app_tearing_down(app, exception)
# Code for function: test_app_tearing_down_with_previous_exception(app, exception)
# Code for function: test_app_tearing_down_with_handled_exception_by_except_block(app, exception)
# Code for function: test_app_tearing_down_with_handled_exception_by_app_handler(app, client, , exception, f)
# Code for function: test_app_tearing_down_with_unhandled_exception(app, client, , exception)
# Code for function: test_app_ctx_globals_methods(app, app_ctx)
# Code for function: test_custom_app_ctx_globals_class(app, self)
# Code for function: test_context_refcounts(app, client, error=None, , error=None)
# Code for function: test_clean_pop(app, error=None, error=None)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_template_rendered
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_signals.py,15,594
Arguments: ['app', 'client', 'sender', 'template', 'context', '']
Code: // Code for Global Scope
import flask
# Code for function: test_template_rendered(app, client, sender, template, context, )
# Code for function: test_before_render_template(, , sender, template, context)
# Code for function: test_request_signals(, response, , sender, response, sender, )
# Code for function: test_request_exception_signal(, sender, exception, )
# Code for function: test_appcontext_signals(app, client, sender, **kwargs, , sender, **kwargs)
# Code for function: test_flash_signal(app, sender, message, category, )
# Code for function: test_appcontext_tearing_down_signal(app, client, sender, exc, )

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_suppressed_exception_logging
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_subclassing.py,40,474
Arguments: ['', '', 'self', 'exc_info']
Code: // Code for Global Scope
from io import StringIO
import flask
# Code for function: test_suppressed_exception_logging(, , self, exc_info)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: common_object_test
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_config.py,131,282
Arguments: ['app']
Code: // Code for Global Scope
import json
import os
import pytest
import flask
# config keys used for the TestConfig
TEST_KEY = "foo"
SECRET_KEY = "config"
# Code for function: common_object_test(app)
# Code for function: test_config_from_pyfile()
# Code for function: test_config_from_object()
# Code for function: test_config_from_file_json()
# Code for function: test_config_from_file_toml()
# Code for function: test_from_prefixed_env(monkeypatch)
# Code for function: test_from_prefixed_env_custom_prefix(monkeypatch)
# Code for function: test_from_prefixed_env_nested(monkeypatch)
# Code for function: test_config_from_mapping()
# Code for function: test_config_from_class()
# Code for function: test_config_from_envvar(monkeypatch)
# Code for function: test_config_from_envvar_missing(monkeypatch)
# Code for function: test_config_missing()
# Code for function: test_config_missing_file()
# Code for function: test_custom_config_class()
# Code for function: test_session_lifetime()
# Code for function: test_get_namespace()
@pytest.mark.parametrize("encoding", ["utf-8", "iso-8859-15", "latin-1"])
def test_from_pyfile_weird_encoding(tmp_path, encoding):
    f = tmp_path / "my_config.py"
    f.write_text(f'# -*- coding: {encoding} -*-\nTEST_VALUE = "föö"\n', encoding)
    app = flask.Flask(__name__)
    app.config.from_pyfile(os.fspath(f))
    value = app.config["TEST_VALUE"]
    assert value == "föö"

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_explicit_instance_paths
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_instance_config.py,41,348
Arguments: ['modules_tmp_path']
Code: // Code for Global Scope
import os
import pytest
import flask
# Code for function: test_explicit_instance_paths(modules_tmp_path)
# Code for function: test_uninstalled_module_paths(modules_tmp_path, purge_module)
# Code for function: test_uninstalled_package_paths(modules_tmp_path, purge_module)
# Code for function: test_uninstalled_namespace_paths(tmp_path, monkeypatch, purge_module, package)
# Code for function: test_installed_module_paths(modules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages, limit_loader)
# Code for function: test_installed_package_paths(limit_loader, modules_tmp_path, modules_tmp_path_prefix, purge_module, monkeypatch)
# Code for function: test_prefix_package_paths(limit_loader, modules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_custom_converters
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_converters.py,124,693
Arguments: ['app', 'client', 'args', 'self', 'value', 'self', 'value']
Code: // Code for Global Scope
from werkzeug.routing import BaseConverter
from flask import request
from flask import session
from flask import url_for
# Code for function: test_custom_converters(app, client, args, self, value, self, value)
# Code for function: test_context_available(app, client, name, self, value)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_duplicate_tag
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_json_tag.py,649,935
Arguments: ['']
Code: // Code for Global Scope
from datetime import datetime
from datetime import timezone
from uuid import uuid4
import pytest
from markupsafe import Markup
from flask.json.tag import JSONTag
from flask.json.tag import TaggedJSONSerializer
@pytest.mark.parametrize(
    "data",
    (
        {" t": (1, 2, 3)},
        {" t__": b"a"},
        {" di": " di"},
        {"x": (1, 2, 3), "y": 4},
        (1, 2, 3),
        [(1, 2, 3)],
        b"\xff",
        Markup("<html>"),
        uuid4(),
        datetime.now(tz=timezone.utc).replace(microsecond=0),
    ),
)
def test_dump_load_unchanged(data):
    s = TaggedJSONSerializer()
    assert s.loads(s.dumps(data)) == data
# Code for function: test_duplicate_tag()
# Code for function: test_custom_tag(, self, value, self, value, self, data, self, value)
# Code for function: test_tag_interface()
# Code for function: test_tag_order()

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_cli_name
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_cli.py,964,1156
Arguments: ['test_apps']
Code: def expect_order(self, order, output):
        # skip the header and match the start of each row
        for expect, line in zip(order, output.splitlines()[2:]):
            # do this instead of startswith for nicer pytest output
            assert line[: len(expect)] == expect
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_find_best_app
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_cli.py,1159,3074
Arguments: ['test_apps', '**kwargs', '', '', '', '', 'foo', 'bar', '']
Code: def test_simple(self, invoke):
        result = invoke(["routes"])
        assert result.exit_code == 0
        self.expect_order(["aaa_post", "static", "yyy_get_post"], result.output)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_locate_app_suppress_raise
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_cli.py,5729,6028
Arguments: ['test_apps']
Code: def test_sort(self, app, invoke):
        default_output = invoke(["routes"]).output
        endpoint_output = invoke(["routes", "-s", "endpoint"]).output
        assert default_output == endpoint_output
        self.expect_order(
            ["static", "yyy_get_post", "aaa_post"],
            invoke(["routes", "-s", "methods"]).output,
        )
        self.expect_order(
            ["yyy_get_post", "static", "aaa_post"],
            invoke(["routes", "-s", "rule"]).output,
        )
        match_order = [r.endpoint for r in app.url_map.iter_rules()]
        self.expect_order(match_order, invoke(["routes", "-s", "match"]).output)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_get_version
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_cli.py,6031,6472
Arguments: ['test_apps', 'capsys', 'self']
Code: def test_all_methods(self, invoke):
        output = invoke(["routes"]).output
        assert "GET, HEAD, OPTIONS, POST" not in output
        output = invoke(["routes", "--all-methods"]).output
        assert "GET, HEAD, OPTIONS, POST" in output
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_scriptinfo
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_cli.py,6475,7691
Arguments: ['test_apps', 'monkeypatch', '']
Code: def test_no_routes(self, runner):
        app = Flask(__name__, static_folder=None)
        cli = FlaskGroup(create_app=lambda: app)
        result = runner.invoke(cli, ["routes"])
        assert result.exit_code == 0
        assert "No routes were registered." in result.output
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_app_cli_has_app_context
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_cli.py,7694,8342
Arguments: ['app', 'runner', 'value', 'ctx', 'param', 'value']
Code: def test_subdomain(self, runner):
        app = Flask(__name__, static_folder=None)
        app.add_url_rule("/a", subdomain="a", endpoint="a")
        app.add_url_rule("/b", subdomain="b", endpoint="b")
        cli = FlaskGroup(create_app=lambda: app)
        result = runner.invoke(cli, ["routes"])
        assert result.exit_code == 0
        assert "Subdomain" in result.output
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_with_appcontext
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_cli.py,8345,8654
Arguments: ['runner', '']
Code: def test_host(self, runner):
        app = Flask(__name__, static_folder=None, host_matching=True)
        app.add_url_rule("/a", host="a", endpoint="a")
        app.add_url_rule("/b", host="b", endpoint="b")
        cli = FlaskGroup(create_app=lambda: app)
        result = runner.invoke(cli, ["routes"])
        assert result.exit_code == 0
        assert "Host" in result.output
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_appgroup_app_context
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_cli.py,8657,9294
Arguments: ['runner', '', '', '', '']
Code: class TestRoutes:
    @pytest.fixture
    def app(self):
        app = Flask(__name__)
        app.add_url_rule(
            "/get_post/<int:x>/<int:y>",
            methods=["GET", "POST"],
            endpoint="yyy_get_post",
        )
        app.add_url_rule("/zzz_post", methods=["POST"], endpoint="aaa_post")
        return app

    @pytest.fixture
    def invoke(self, app, runner):
        cli = FlaskGroup(create_app=lambda: app)
        return partial(runner.invoke, cli)

    # Code for function: TestRoutes.expect_order(self, order, output)
# Code for function: TestRoutes.test_simple(self, invoke)
# Code for function: TestRoutes.test_sort(self, app, invoke)
# Code for function: TestRoutes.test_all_methods(self, invoke)
# Code for function: TestRoutes.test_no_routes(self, runner)
# Code for function: TestRoutes.test_subdomain(self, runner)
# Code for function: TestRoutes.test_host(self, runner)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_flaskgroup_app_context
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_cli.py,9297,9679
Arguments: ['runner', '**params', '', '']
Code: // Code for Global Scope
# This file was part of Flask-CLI and was modified under the terms of
# its Revised BSD License. Copyright © 2015 CERN.
import importlib.metadata
import os
import platform
import ssl
import sys
import types
from functools import partial
from pathlib import Path
import click
import pytest
from _pytest.monkeypatch import notset
from click.testing import CliRunner
from flask import Blueprint
from flask import current_app
from flask import Flask
from flask.cli import AppGroup
from flask.cli import find_best_app
from flask.cli import FlaskGroup
from flask.cli import get_version
from flask.cli import load_dotenv
from flask.cli import locate_app
from flask.cli import NoAppException
from flask.cli import prepare_import
from flask.cli import run_command
from flask.cli import ScriptInfo
from flask.cli import with_appcontext
cwd = Path.cwd()
test_path = (Path(__file__) / ".." / "test_apps").resolve()
@pytest.fixture
def runner():
    return CliRunner()
# Code for function: test_cli_name(test_apps)
# Code for function: test_find_best_app(test_apps, **kwargs, , , , , foo, bar, )
@pytest.mark.parametrize(
    "value,path,result",
    (
        ("test", cwd, "test"),
        ("test.py", cwd, "test"),
        ("a/test", cwd / "a", "test"),
        ("test/__init__.py", cwd, "test"),
        ("test/__init__", cwd, "test"),
        # nested package
        (
            test_path / "cliapp" / "inner1" / "__init__",
            test_path,
            "cliapp.inner1",
        ),
        (
            test_path / "cliapp" / "inner1" / "inner2",
            test_path,
            "cliapp.inner1.inner2",
        ),
        # dotted name
        ("test.a.b", cwd, "test.a.b"),
        (test_path / "cliapp.app", test_path, "cliapp.app"),
        # not a Python file, will be caught during import
        (test_path / "cliapp" / "message.txt", test_path, "cliapp.message.txt"),
    ),
)
def test_prepare_import(request, value, path, result):
    """Expect the correct path to be set and the correct import and app names
    to be returned.

    :func:`prepare_exec_for_file` has a side effect where the parent directory
    of the given import is added to :data:`sys.path`. This is reset after the
    test runs.
    """
    original_path = sys.path[:]

    def reset_path():
        sys.path[:] = original_path

    request.addfinalizer(reset_path)

    assert prepare_import(value) == result
    assert sys.path[0] == str(path)
@pytest.mark.parametrize(
    "iname,aname,result",
    (
        ("cliapp.app", None, "testapp"),
        ("cliapp.app", "testapp", "testapp"),
        ("cliapp.factory", None, "app"),
        ("cliapp.factory", "create_app", "app"),
        ("cliapp.factory", "create_app()", "app"),
        ("cliapp.factory", 'create_app2("foo", "bar")', "app2_foo_bar"),
        # trailing comma space
        ("cliapp.factory", 'create_app2("foo", "bar", )', "app2_foo_bar"),
        # strip whitespace
        ("cliapp.factory", " create_app () ", "app"),
    ),
)
def test_locate_app(test_apps, iname, aname, result):
    assert locate_app(iname, aname).name == result
@pytest.mark.parametrize(
    "iname,aname",
    (
        ("notanapp.py", None),
        ("cliapp/app", None),
        ("cliapp.app", "notanapp"),
        # not enough arguments
        ("cliapp.factory", 'create_app2("foo")'),
        # invalid identifier
        ("cliapp.factory", "create_app("),
        # no app returned
        ("cliapp.factory", "no_app"),
        # nested import error
        ("cliapp.importerrorapp", None),
        # not a Python file
        ("cliapp.message.txt", None),
    ),
)
def test_locate_app_raises(test_apps, iname, aname):
    with pytest.raises(NoAppException):
        locate_app(iname, aname)
# Code for function: test_locate_app_suppress_raise(test_apps)
# Code for function: test_get_version(test_apps, capsys, self)
# Code for function: test_scriptinfo(test_apps, monkeypatch, )
# Code for function: test_app_cli_has_app_context(app, runner, value, ctx, param, value)
# Code for function: test_with_appcontext(runner, )
# Code for function: test_appgroup_app_context(runner, , , , )
# Code for function: test_flaskgroup_app_context(runner, **params, , )
@pytest.mark.parametrize("set_debug_flag", (True, False))
def test_flaskgroup_debug(runner, set_debug_flag):
    def create_app():
        app = Flask("flaskgroup")
        app.debug = True
        return app

    @click.group(cls=FlaskGroup, create_app=create_app, set_debug_flag=set_debug_flag)
    def cli(**params):
        pass

    @cli.command()
    def test():
        click.echo(str(current_app.debug))

    result = runner.invoke(cli, ["test"])
    assert result.exit_code == 0
    assert result.output == f"{not set_debug_flag}\n"
# Code for function: test_flaskgroup_nested(app, runner, )
# Code for function: test_no_command_echo_loading_error()
# Code for function: test_help_echo_loading_error()
# Code for function: test_help_echo_exception(, )
# Code for class: TestRoutes()
# Code for function: TestRoutes.expect_order(self, order, output)
# Code for function: TestRoutes.test_simple(self, invoke)
# Code for function: TestRoutes.test_sort(self, app, invoke)
# Code for function: TestRoutes.test_all_methods(self, invoke)
# Code for function: TestRoutes.test_no_routes(self, runner)
# Code for function: TestRoutes.test_subdomain(self, runner)
# Code for function: TestRoutes.test_host(self, runner)
# Code for function: dotenv_not_available()
need_dotenv = pytest.mark.skipif(
    dotenv_not_available(), reason="dotenv is not installed"
)
@need_dotenv
def test_load_dotenv(monkeypatch):
    # can't use monkeypatch.delitem since the keys don't exist yet
    for item in ("FOO", "BAR", "SPAM", "HAM"):
        monkeypatch._setitem.append((os.environ, item, notset))

    monkeypatch.setenv("EGGS", "3")
    monkeypatch.chdir(test_path)
    assert load_dotenv()
    assert Path.cwd() == test_path
    # .flaskenv doesn't overwrite .env
    assert os.environ["FOO"] == "env"
    # set only in .flaskenv
    assert os.environ["BAR"] == "bar"
    # set only in .env
    assert os.environ["SPAM"] == "1"
    # set manually, files don't overwrite
    assert os.environ["EGGS"] == "3"
    # test env file encoding
    assert os.environ["HAM"] == "火腿"
    # Non existent file should not load
    assert not load_dotenv("non-existent-file", load_defaults=False)
@need_dotenv
def test_dotenv_path(monkeypatch):
    for item in ("FOO", "BAR", "EGGS"):
        monkeypatch._setitem.append((os.environ, item, notset))

    load_dotenv(test_path / ".flaskenv")
    assert Path.cwd() == cwd
    assert "FOO" in os.environ
# Code for function: test_dotenv_optional(monkeypatch)
@need_dotenv
def test_disable_dotenv_from_env(monkeypatch, runner):
    monkeypatch.chdir(test_path)
    monkeypatch.setitem(os.environ, "FLASK_SKIP_DOTENV", "1")
    runner.invoke(FlaskGroup())
    assert "FOO" not in os.environ
# Code for function: test_run_cert_path()
# Code for function: test_run_cert_adhoc(monkeypatch)
# Code for function: test_run_cert_import(monkeypatch)
# Code for function: test_run_cert_no_ssl(monkeypatch)
# Code for function: test_cli_blueprints(app, , , , )
# Code for function: test_cli_empty(app)
# Code for function: test_run_exclude_patterns()

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/tests/type_check/typing_error_handler.py,0,646
Arguments: []
Code: // Code for Global Scope
from __future__ import annotations
from http import HTTPStatus
from werkzeug.exceptions import BadRequest
from werkzeug.exceptions import NotFound
from flask import Flask
app = Flask(__name__)
@app.errorhandler(400)
@app.errorhandler(HTTPStatus.BAD_REQUEST)
@app.errorhandler(BadRequest)
def handle_400(e: BadRequest) -> str:
    return ""
@app.errorhandler(ValueError)
def handle_custom(e: ValueError) -> str:
    return ""
@app.errorhandler(ValueError)
def handle_accept_base(e: Exception) -> str:
    return ""
@app.errorhandler(BadRequest)
@app.errorhandler(404)
def handle_multiple(e: BadRequest | NotFound) -> str:
    return ""

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/tests/type_check/typing_app_decorators.py,0,588
Arguments: []
Code: // Code for Global Scope
from __future__ import annotations
from flask import Flask
from flask import Response
app = Flask(__name__)
@app.after_request
def after_sync(response: Response) -> Response:
    return Response()
@app.after_request
async def after_async(response: Response) -> Response:
    return Response()
@app.before_request
def before_sync() -> None: ...
@app.before_request
async def before_async() -> None: ...
@app.teardown_appcontext
def teardown_sync(exc: BaseException | None) -> None: ...
@app.teardown_appcontext
async def teardown_async(exc: BaseException | None) -> None: ...

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/tests/type_check/typing_route.py,0,2531
Arguments: []
Code: // Code for Global Scope
from __future__ import annotations
import typing as t
from http import HTTPStatus
from flask import Flask
from flask import jsonify
from flask import stream_template
from flask.templating import render_template
from flask.views import View
from flask.wrappers import Response
app = Flask(__name__)
@app.route("/str")
def hello_str() -> str:
    return "<p>Hello, World!</p>"
@app.route("/bytes")
def hello_bytes() -> bytes:
    return b"<p>Hello, World!</p>"
@app.route("/json")
def hello_json() -> Response:
    return jsonify("Hello, World!")
@app.route("/json/dict")
def hello_json_dict() -> dict[str, t.Any]:
    return {"response": "Hello, World!"}
@app.route("/json/dict")
def hello_json_list() -> list[t.Any]:
    return [{"message": "Hello"}, {"message": "World"}]
# Code for class: StatusJSON()
@app.route("/typed-dict")
def typed_dict() -> StatusJSON:
    return {"status": "ok"}
@app.route("/generator")
def hello_generator() -> t.Generator[str, None, None]:
    def show() -> t.Generator[str, None, None]:
        for x in range(100):
            yield f"data:{x}\n\n"

    return show()
@app.route("/generator-expression")
def hello_generator_expression() -> t.Iterator[bytes]:
    return (f"data:{x}\n\n".encode() for x in range(100))
@app.route("/iterator")
def hello_iterator() -> t.Iterator[str]:
    return iter([f"data:{x}\n\n" for x in range(100)])
@app.route("/status")
@app.route("/status/<int:code>")
def tuple_status(code: int = 200) -> tuple[str, int]:
    return "hello", code
@app.route("/status-enum")
def tuple_status_enum() -> tuple[str, int]:
    return "hello", HTTPStatus.OK
@app.route("/headers")
def tuple_headers() -> tuple[str, dict[str, str]]:
    return "Hello, World!", {"Content-Type": "text/plain"}
@app.route("/template")
@app.route("/template/<name>")
def return_template(name: str | None = None) -> str:
    return render_template("index.html", name=name)
@app.route("/template")
def return_template_stream() -> t.Iterator[str]:
    return stream_template("index.html", name="Hello")
@app.route("/async")
async def async_route() -> str:
    return "Hello"
# Code for class: RenderTemplateView(self: RenderTemplateView, template_name: str)
# Code for function: RenderTemplateView.__init__(self: RenderTemplateView, template_name: str)
# Code for function: RenderTemplateView.dispatch_request(self: RenderTemplateView)
app.add_url_rule(
    "/about",
    view_func=RenderTemplateView.as_view("about_page", template_name="about.html"),
)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: StatusJSON
Type: class
Parent Type: 
Location: /home/yuesheng/flask/tests/type_check/typing_route.py,788,834
Arguments: []
Code: class StatusJSON(t.TypedDict):
    status: str
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: RenderTemplateView
Type: class
Parent Type: 
Location: /home/yuesheng/flask/tests/type_check/typing_route.py,2154,2190
Arguments: ['self: RenderTemplateView', 'template_name: str']
Code: class RenderTemplateView(View):
    # Code for function: RenderTemplateView.__init__(self: RenderTemplateView, template_name: str)
# Code for function: RenderTemplateView.dispatch_request(self: RenderTemplateView)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: RenderTemplateView
Location: /home/yuesheng/flask/tests/type_check/typing_route.py,2190,2300
Arguments: ['self: RenderTemplateView', 'template_name: str']
Code: def __init__(self: RenderTemplateView, template_name: str) -> None:
        self.template_name = template_name
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: dispatch_request
Type: function
Parent Type: RenderTemplateView
Location: /home/yuesheng/flask/tests/type_check/typing_route.py,2306,2411
Arguments: ['self: RenderTemplateView']
Code: def dispatch_request(self: RenderTemplateView) -> str:
        return render_template(self.template_name)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/tests/test_apps/blueprintapp/__init__.py,0,255
Arguments: []
Code: // Code for Global Scope
from flask import Flask
app = Flask(__name__)
app.config["DEBUG"] = True
from blueprintapp.apps.admin import admin
# noqa: E402
from blueprintapp.apps.frontend import frontend
# noqa: E402
app.register_blueprint(admin)
app.register_blueprint(frontend)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/tests/test_apps/blueprintapp/apps/admin/__init__.py,0,365
Arguments: []
Code: // Code for Global Scope
from flask import Blueprint
from flask import render_template
admin = Blueprint(
    "admin",
    __name__,
    url_prefix="/admin",
    template_folder="templates",
    static_folder="static",
)
@admin.route("/")
def index():
    return render_template("admin/index.html")
@admin.route("/index2")
def index2():
    return render_template("./admin/index.html")

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/tests/test_apps/blueprintapp/apps/frontend/__init__.py,0,326
Arguments: []
Code: // Code for Global Scope
from flask import Blueprint
from flask import render_template
frontend = Blueprint("frontend", __name__, template_folder="templates")
@frontend.route("/")
def index():
    return render_template("frontend/index.html")
@frontend.route("/missing")
def missing_template():
    return render_template("missing_template.html")

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/tests/test_apps/subdomaintestmodule/__init__.py,0,72
Arguments: []
Code: // Code for Global Scope
from flask import Module
mod = Module(__name__, "foo", subdomain="foo")

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/tests/test_apps/helloworld/wsgi.py,0,35
Arguments: []
Code: // Code for Global Scope
from hello import app
# noqa: F401

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/tests/test_apps/helloworld/hello.py,0,103
Arguments: []
Code: // Code for Global Scope
from flask import Flask
app = Flask(__name__)
@app.route("/")
def hello():
    return "Hello World!"

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/tests/test_apps/cliapp/importerrorapp.py,0,72
Arguments: []
Code: // Code for Global Scope
from flask import Flask
raise ImportError()
testapp = Flask("testapp")

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/tests/test_apps/cliapp/app.py,0,51
Arguments: []
Code: // Code for Global Scope
from flask import Flask
testapp = Flask("testapp")

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/tests/test_apps/cliapp/multiapp.py,0,66
Arguments: []
Code: // Code for Global Scope
from flask import Flask
app1 = Flask("app1")
app2 = Flask("app2")

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: create_app
Type: function
Parent Type: 
Location: /home/yuesheng/flask/tests/test_apps/cliapp/factory.py,26,67
Arguments: ['']
Code: // Code for Global Scope
from flask import Flask
# Code for function: create_app()
# Code for function: create_app2(foo, bar)
# Code for function: no_app()

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/tests/test_apps/cliapp/inner1/__init__.py,0,54
Arguments: []
Code: // Code for Global Scope
from flask import Flask
application = Flask(__name__)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/tests/test_apps/cliapp/inner1/inner2/flask.py,0,46
Arguments: []
Code: // Code for Global Scope
from flask import Flask
app = Flask(__name__)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/src/flask/__init__.py,0,2071
Arguments: []
Code: // Code for Global Scope
from . import json as json
from .app import Flask as Flask
from .blueprints import Blueprint as Blueprint
from .config import Config as Config
from .ctx import after_this_request as after_this_request
from .ctx import copy_current_request_context as copy_current_request_context
from .ctx import has_app_context as has_app_context
from .ctx import has_request_context as has_request_context
from .globals import current_app as current_app
from .globals import g as g
from .globals import request as request
from .globals import session as session
from .helpers import abort as abort
from .helpers import flash as flash
from .helpers import get_flashed_messages as get_flashed_messages
from .helpers import get_template_attribute as get_template_attribute
from .helpers import make_response as make_response
from .helpers import redirect as redirect
from .helpers import send_file as send_file
from .helpers import send_from_directory as send_from_directory
from .helpers import stream_with_context as stream_with_context
from .helpers import url_for as url_for
from .json import jsonify as jsonify
from .signals import appcontext_popped as appcontext_popped
from .signals import appcontext_pushed as appcontext_pushed
from .signals import appcontext_tearing_down as appcontext_tearing_down
from .signals import before_render_template as before_render_template
from .signals import got_request_exception as got_request_exception
from .signals import message_flashed as message_flashed
from .signals import request_finished as request_finished
from .signals import request_started as request_started
from .signals import request_tearing_down as request_tearing_down
from .signals import template_rendered as template_rendered
from .templating import render_template as render_template
from .templating import render_template_string as render_template_string
from .templating import stream_template as stream_template
from .templating import stream_template_string as stream_template_string
from .wrappers import Request as Request
from .wrappers import Response as Response

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _AppCtxGlobals
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/ctx.py,635,1212
Arguments: []
Code: class _AppCtxGlobals:
    """A plain object. Used as a namespace for storing data during an
    application context.

    Creating an app context automatically creates this object, which is
    made available as the :data:`g` proxy.

    .. describe:: 'key' in g

        Check whether an attribute is present.

        .. versionadded:: 0.10

    .. describe:: iter(g)

        Return an iterator over the attribute names.

        .. versionadded:: 0.10
    """

    # Define attr methods to let mypy know this is a namespace object
    # that has arbitrary attributes.

    # Code for function: _AppCtxGlobals.__getattr__(self, name: str)
# Code for function: _AppCtxGlobals.__setattr__(self, name: str, value: t.Any)
# Code for function: _AppCtxGlobals.__delattr__(self, name: str)
# Code for function: _AppCtxGlobals.get(self, name: str, default: t.Any | None = None)
# Code for function: _AppCtxGlobals.pop(self, name: str, default: t.Any = _sentinel)
# Code for function: _AppCtxGlobals.setdefault(self, name: str, default: t.Any = None)
# Code for function: _AppCtxGlobals.__contains__(self, item: str)
# Code for function: _AppCtxGlobals.__iter__(self)
# Code for function: _AppCtxGlobals.__repr__(self)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __getattr__
Type: function
Parent Type: _AppCtxGlobals
Location: /home/yuesheng/flask/src/flask/ctx.py,1212,1380
Arguments: ['self', 'name: str']
Code: def __getattr__(self, name: str) -> t.Any:
        try:
            return self.__dict__[name]
        except KeyError:
            raise AttributeError(name) from None
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __setattr__
Type: function
Parent Type: _AppCtxGlobals
Location: /home/yuesheng/flask/src/flask/ctx.py,1386,1477
Arguments: ['self', 'name: str', 'value: t.Any']
Code: def __setattr__(self, name: str, value: t.Any) -> None:
        self.__dict__[name] = value
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __delattr__
Type: function
Parent Type: _AppCtxGlobals
Location: /home/yuesheng/flask/src/flask/ctx.py,1483,1647
Arguments: ['self', 'name: str']
Code: def __delattr__(self, name: str) -> None:
        try:
            del self.__dict__[name]
        except KeyError:
            raise AttributeError(name) from None
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get
Type: function
Parent Type: _AppCtxGlobals
Location: /home/yuesheng/flask/src/flask/ctx.py,1653,2018
Arguments: ['self', 'name: str', 'default: t.Any | None = None']
Code: def get(self, name: str, default: t.Any | None = None) -> t.Any:
        """Get an attribute by name, or a default value. Like
        :meth:`dict.get`.

        :param name: Name of attribute to get.
        :param default: Value to return if the attribute is not present.

        .. versionadded:: 0.10
        """
        return self.__dict__.get(name, default)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: pop
Type: function
Parent Type: _AppCtxGlobals
Location: /home/yuesheng/flask/src/flask/ctx.py,2024,2511
Arguments: ['self', 'name: str', 'default: t.Any = _sentinel']
Code: def pop(self, name: str, default: t.Any = _sentinel) -> t.Any:
        """Get and remove an attribute by name. Like :meth:`dict.pop`.

        :param name: Name of attribute to pop.
        :param default: Value to return if the attribute is not present,
            instead of raising a ``KeyError``.

        .. versionadded:: 0.11
        """
        if default is _sentinel:
            return self.__dict__.pop(name)
        else:
            return self.__dict__.pop(name, default)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: setdefault
Type: function
Parent Type: _AppCtxGlobals
Location: /home/yuesheng/flask/src/flask/ctx.py,2517,2960
Arguments: ['self', 'name: str', 'default: t.Any = None']
Code: def setdefault(self, name: str, default: t.Any = None) -> t.Any:
        """Get the value of an attribute if it is present, otherwise
        set and return a default value. Like :meth:`dict.setdefault`.

        :param name: Name of attribute to get.
        :param default: Value to set and return if the attribute is not
            present.

        .. versionadded:: 0.11
        """
        return self.__dict__.setdefault(name, default)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __contains__
Type: function
Parent Type: _AppCtxGlobals
Location: /home/yuesheng/flask/src/flask/ctx.py,2966,3045
Arguments: ['self', 'item: str']
Code: def __contains__(self, item: str) -> bool:
        return item in self.__dict__
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __iter__
Type: function
Parent Type: _AppCtxGlobals
Location: /home/yuesheng/flask/src/flask/ctx.py,3051,3124
Arguments: ['self']
Code: def __iter__(self) -> t.Iterator[str]:
        return iter(self.__dict__)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __repr__
Type: function
Parent Type: _AppCtxGlobals
Location: /home/yuesheng/flask/src/flask/ctx.py,3130,3305
Arguments: ['self']
Code: def __repr__(self) -> str:
        ctx = _cv_app.get(None)
        if ctx is not None:
            return f"<flask.g of '{ctx.app.name}'>"
        return object.__repr__(self)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: after_this_request
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/ctx.py,3308,4386
Arguments: ['f: ft.AfterRequestCallable[t.Any]', '']
Code: def __init__(self, app: Flask) -> None:
        self.app = app
        self.url_adapter = app.create_url_adapter(None)
        self.g: _AppCtxGlobals = app.app_ctx_globals_class()
        self._cv_tokens: list[contextvars.Token[AppContext]] = []
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: copy_current_request_context
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/ctx.py,4440,5833
Arguments: ['f: F', '*args: t.Any', '**kwargs: t.Any']
Code: def push(self) -> None:
        """Binds the app context to the current context."""
        self._cv_tokens.append(_cv_app.set(self))
        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: has_request_context
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/ctx.py,5836,6944
Arguments: ['']
Code: def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the app context."""
        try:
            if len(self._cv_tokens) == 1:
                if exc is _sentinel:
                    exc = sys.exc_info()[1]
                self.app.do_teardown_appcontext(exc)
        finally:
            ctx = _cv_app.get()
            _cv_app.reset(self._cv_tokens.pop())

        if ctx is not self:
            raise AssertionError(
                f"Popped wrong app context. ({ctx!r} instead of {self!r})"
            )

        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: has_app_context
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/ctx.py,6947,7221
Arguments: ['']
Code: def __enter__(self) -> AppContext:
        self.push()
        return self
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: AppContext
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/ctx.py,7224,7490
Arguments: ['self', 'app: Flask']
Code: def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)

        if app_ctx is None or app_ctx.app is not self.app:
            app_ctx = self.app.app_context()
            app_ctx.push()
        else:
            app_ctx = None

        self._cv_tokens.append((_cv_request.set(self), app_ctx))

        # Open the session at the moment that the request context is available.
        # This allows a custom open_session method to use the request context.
        # Only open a new session if this is the first time the request was
        # pushed, otherwise stream_with_context loses the session.
        if self.session is None:
            session_interface = self.app.session_interface
            self.session = session_interface.open_session(self.app, self.request)

            if self.session is None:
                self.session = session_interface.make_null_session(self.app)

        # Match the request URL after loading the session, so that the
        # session is available in custom URL converters.
        if self.url_adapter is not None:
            self.match_request()
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: AppContext
Location: /home/yuesheng/flask/src/flask/ctx.py,7490,7735
Arguments: ['self', 'app: Flask']
Code: def __exit__(
        self,
        exc_type: type | None,
        exc_value: BaseException | None,
        tb: TracebackType | None,
    ) -> None:
        self.pop(exc_value)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: push
Type: function
Parent Type: AppContext
Location: /home/yuesheng/flask/src/flask/ctx.py,7741,7952
Arguments: ['self']
Code: class AppContext:
    """The app context contains application-specific information. An app
    context is created and pushed at the beginning of each request if
    one is not already active. An app context is also pushed when
    running CLI commands.
    """

    # Code for function: AppContext.__init__(self, app: Flask)
# Code for function: AppContext.push(self)
# Code for function: AppContext.pop(self, exc: BaseException | None = _sentinel)
# Code for function: AppContext.__enter__(self)
# Code for function: AppContext.__exit__(self, exc_type: type | None, exc_value: BaseException | None, tb: TracebackType | None, )

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: pop
Type: function
Parent Type: AppContext
Location: /home/yuesheng/flask/src/flask/ctx.py,7958,8589
Arguments: ['self', 'exc: BaseException | None = _sentinel']
Code: def __init__(
        self,
        app: Flask,
        environ: WSGIEnvironment,
        request: Request | None = None,
        session: SessionMixin | None = None,
    ) -> None:
        self.app = app
        if request is None:
            request = app.request_class(environ)
            request.json_module = app.json
        self.request: Request = request
        self.url_adapter = None
        try:
            self.url_adapter = app.create_url_adapter(self.request)
        except HTTPException as e:
            self.request.routing_exception = e
        self.flashes: list[tuple[str, str]] | None = None
        self.session: SessionMixin | None = session
        # Functions that should be executed after the request on the response
        # object.  These will be called before the regular "after_request"
        # functions.
        self._after_request_functions: list[ft.AfterRequestCallable[t.Any]] = []

        self._cv_tokens: list[
            tuple[contextvars.Token[RequestContext], AppContext | None]
        ] = []
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __enter__
Type: function
Parent Type: AppContext
Location: /home/yuesheng/flask/src/flask/ctx.py,8595,8669
Arguments: ['self']
Code: def copy(self) -> RequestContext:
        """Creates a copy of this request context with the same request object.
        This can be used to move a request context to a different greenlet.
        Because the actual request object is the same this cannot be used to
        move a request context to a different thread unless access to the
        request object is locked.

        .. versionadded:: 0.10

        .. versionchanged:: 1.1
           The current session object is used instead of reloading the original
           data. This prevents `flask.session` pointing to an out-of-date object.
        """
        return self.__class__(
            self.app,
            environ=self.request.environ,
            request=self.request,
            session=self.session,
        )
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __exit__
Type: function
Parent Type: AppContext
Location: /home/yuesheng/flask/src/flask/ctx.py,8675,8851
Arguments: ['self', 'exc_type: type | None', 'exc_value: BaseException | None', 'tb: TracebackType | None', '']
Code: def match_request(self) -> None:
        """Can be overridden by a subclass to hook into the matching
        of the request.
        """
        try:
            result = self.url_adapter.match(return_rule=True)  # type: ignore
            self.request.url_rule, self.request.view_args = result  # type: ignore
        except HTTPException as e:
            self.request.routing_exception = e
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: RequestContext
Location: /home/yuesheng/flask/src/flask/ctx.py,9879,10922
Arguments: ['self', 'app: Flask', 'environ: WSGIEnvironment', 'request: Request | None = None', 'session: SessionMixin | None = None', '']
Code: def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.

        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
        clear_request = len(self._cv_tokens) == 1

        try:
            if clear_request:
                if exc is _sentinel:
                    exc = sys.exc_info()[1]
                self.app.do_teardown_request(exc)

                request_close = getattr(self.request, "close", None)
                if request_close is not None:
                    request_close()
        finally:
            ctx = _cv_request.get()
            token, app_ctx = self._cv_tokens.pop()
            _cv_request.reset(token)

            # get rid of circular dependencies at the end of the request
            # so that we don't require the GC to be active.
            if clear_request:
                ctx.request.environ["werkzeug.request"] = None

            if app_ctx is not None:
                app_ctx.pop(exc)

            if ctx is not self:
                raise AssertionError(
                    f"Popped wrong request context. ({ctx!r} instead of {self!r})"
                )
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: copy
Type: function
Parent Type: RequestContext
Location: /home/yuesheng/flask/src/flask/ctx.py,10928,11714
Arguments: ['self']
Code: def __enter__(self) -> RequestContext:
        self.push()
        return self
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: match_request
Type: function
Parent Type: RequestContext
Location: /home/yuesheng/flask/src/flask/ctx.py,11720,12113
Arguments: ['self']
Code: def __exit__(
        self,
        exc_type: type | None,
        exc_value: BaseException | None,
        tb: TracebackType | None,
    ) -> None:
        self.pop(exc_value)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: push
Type: function
Parent Type: RequestContext
Location: /home/yuesheng/flask/src/flask/ctx.py,12119,13323
Arguments: ['self']
Code: def __repr__(self) -> str:
        return (
            f"<{type(self).__name__} {self.request.url!r}"
            f" [{self.request.method}] of {self.app.name}>"
        )
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: pop
Type: function
Parent Type: RequestContext
Location: /home/yuesheng/flask/src/flask/ctx.py,13329,14675
Arguments: ['self', 'exc: BaseException | None = _sentinel']
Code: class RequestContext:
    """The request context contains per-request information. The Flask
    app creates and pushes it at the beginning of the request, then pops
    it at the end of the request. It will create the URL adapter and
    request object for the WSGI environment provided.

    Do not attempt to use this class directly, instead use
    :meth:`~flask.Flask.test_request_context` and
    :meth:`~flask.Flask.request_context` to create this object.

    When the request context is popped, it will evaluate all the
    functions registered on the application for teardown execution
    (:meth:`~flask.Flask.teardown_request`).

    The request context is automatically popped at the end of the
    request. When using the interactive debugger, the context will be
    restored so ``request`` is still accessible. Similarly, the test
    client can preserve the context after the request ends. However,
    teardown functions may already have closed some resources such as
    database connections.
    """

    # Code for function: RequestContext.__init__(self, app: Flask, environ: WSGIEnvironment, request: Request | None = None, session: SessionMixin | None = None, )
# Code for function: RequestContext.copy(self)
# Code for function: RequestContext.match_request(self)
# Code for function: RequestContext.push(self)
# Code for function: RequestContext.pop(self, exc: BaseException | None = _sentinel)
# Code for function: RequestContext.__enter__(self)
# Code for function: RequestContext.__exit__(self, exc_type: type | None, exc_value: BaseException | None, tb: TracebackType | None, )
# Code for function: RequestContext.__repr__(self)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __enter__
Type: function
Parent Type: RequestContext
Location: /home/yuesheng/flask/src/flask/ctx.py,14681,14759
Arguments: ['self']
Code: // Code for Global Scope
from __future__ import annotations
import contextvars
import sys
import typing as t
from functools import update_wrapper
from types import TracebackType
from werkzeug.exceptions import HTTPException
from . import typing as ft
from .globals import _cv_app
from .globals import _cv_request
from .signals import appcontext_popped
from .signals import appcontext_pushed
if t.TYPE_CHECKING:  # pragma: no cover
    from _typeshed.wsgi import WSGIEnvironment

    from .app import Flask
    from .sessions import SessionMixin
    from .wrappers import Request
# a singleton sentinel value for parameter defaults
_sentinel = object()
# Code for class: _AppCtxGlobals()
# Code for function: _AppCtxGlobals.__getattr__(self, name: str)
# Code for function: _AppCtxGlobals.__setattr__(self, name: str, value: t.Any)
# Code for function: _AppCtxGlobals.__delattr__(self, name: str)
# Code for function: _AppCtxGlobals.get(self, name: str, default: t.Any | None = None)
# Code for function: _AppCtxGlobals.pop(self, name: str, default: t.Any = _sentinel)
# Code for function: _AppCtxGlobals.setdefault(self, name: str, default: t.Any = None)
# Code for function: _AppCtxGlobals.__contains__(self, item: str)
# Code for function: _AppCtxGlobals.__iter__(self)
# Code for function: _AppCtxGlobals.__repr__(self)
# Code for function: after_this_request(f: ft.AfterRequestCallable[t.Any], )
F = t.TypeVar("F", bound=t.Callable[..., t.Any])
# Code for function: copy_current_request_context(f: F, *args: t.Any, **kwargs: t.Any)
# Code for function: has_request_context()
# Code for function: has_app_context()
# Code for class: AppContext(self, app: Flask)
# Code for function: AppContext.__init__(self, app: Flask)
# Code for function: AppContext.push(self)
# Code for function: AppContext.pop(self, exc: BaseException | None = _sentinel)
# Code for function: AppContext.__enter__(self)
# Code for function: AppContext.__exit__(self, exc_type: type | None, exc_value: BaseException | None, tb: TracebackType | None, )
# Code for class: RequestContext(self, app: Flask, environ: WSGIEnvironment, request: Request | None = None, session: SessionMixin | None = None, )
# Code for function: RequestContext.__init__(self, app: Flask, environ: WSGIEnvironment, request: Request | None = None, session: SessionMixin | None = None, )
# Code for function: RequestContext.copy(self)
# Code for function: RequestContext.match_request(self)
# Code for function: RequestContext.push(self)
# Code for function: RequestContext.pop(self, exc: BaseException | None = _sentinel)
# Code for function: RequestContext.__enter__(self)
# Code for function: RequestContext.__exit__(self, exc_type: type | None, exc_value: BaseException | None, tb: TracebackType | None, )
# Code for function: RequestContext.__repr__(self)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/src/flask/globals.py,0,1712
Arguments: []
Code: // Code for Global Scope
from __future__ import annotations
import typing as t
from contextvars import ContextVar
from werkzeug.local import LocalProxy
if t.TYPE_CHECKING:  # pragma: no cover
    from .app import Flask
    from .ctx import _AppCtxGlobals
    from .ctx import AppContext
    from .ctx import RequestContext
    from .sessions import SessionMixin
    from .wrappers import Request
_no_app_msg = """\
Working outside of application context.

This typically means that you attempted to use functionality that needed
the current application. To solve this, set up an application context
with app.app_context(). See the documentation for more information.\
"""
_cv_app: ContextVar[AppContext] = ContextVar("flask.app_ctx")
app_ctx: AppContext = LocalProxy(  # type: ignore[assignment]
    _cv_app, unbound_message=_no_app_msg
)
current_app: Flask = LocalProxy(  # type: ignore[assignment]
    _cv_app, "app", unbound_message=_no_app_msg
)
g: _AppCtxGlobals = LocalProxy(  # type: ignore[assignment]
    _cv_app, "g", unbound_message=_no_app_msg
)
_no_req_msg = """\
Working outside of request context.

This typically means that you attempted to use functionality that needed
an active HTTP request. Consult the documentation on testing for
information about how to avoid this problem.\
"""
_cv_request: ContextVar[RequestContext] = ContextVar("flask.request_ctx")
request_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]
    _cv_request, unbound_message=_no_req_msg
)
request: Request = LocalProxy(  # type: ignore[assignment]
    _cv_request, "request", unbound_message=_no_req_msg
)
session: SessionMixin = LocalProxy(  # type: ignore[assignment]
    _cv_request, "session", unbound_message=_no_req_msg
)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/src/flask/__main__.py,0,29
Arguments: []
Code: // Code for Global Scope
from .cli import main
main()

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get_debug_flag
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/helpers.py,647,941
Arguments: ['']
Code: // Code for Global Scope
from __future__ import annotations
import importlib.util
import os
import sys
import typing as t
from datetime import datetime
from functools import cache
from functools import update_wrapper
import werkzeug.utils
from werkzeug.exceptions import abort as _wz_abort
from werkzeug.utils import redirect as _wz_redirect
from werkzeug.wrappers import Response as BaseResponse
from .globals import _cv_request
from .globals import current_app
from .globals import request
from .globals import request_ctx
from .globals import session
from .signals import message_flashed
if t.TYPE_CHECKING:  # pragma: no cover
    from .wrappers import Response
# Code for function: get_debug_flag()
# Code for function: get_load_dotenv(default: bool = True)
@t.overload
def stream_with_context(
    generator_or_function: t.Iterator[t.AnyStr],
) -> t.Iterator[t.AnyStr]: ...
@t.overload
def stream_with_context(
    generator_or_function: t.Callable[..., t.Iterator[t.AnyStr]],
) -> t.Callable[[t.Iterator[t.AnyStr]], t.Iterator[t.AnyStr]]: ...
# Code for function: stream_with_context(generator_or_function: t.Iterator[t.AnyStr] | t.Callable[..., t.Iterator[t.AnyStr]], , *args: t.Any, **kwargs: t.Any, )
# Code for function: make_response(*args: t.Any)
# Code for function: url_for(endpoint: str, *, _anchor: str | None = None, _method: str | None = None, _scheme: str | None = None, _external: bool | None = None, **values: t.Any, )
# Code for function: redirect(location: str, code: int = 302, Response: type[BaseResponse] | None = None)
# Code for function: abort(code: int | BaseResponse, *args: t.Any, **kwargs: t.Any)
# Code for function: get_template_attribute(template_name: str, attribute: str)
# Code for function: flash(message: str, category: str = "message")
# Code for function: get_flashed_messages(with_categories: bool = False, category_filter: t.Iterable[str] = ())
# Code for function: _prepare_send_file_kwargs(**kwargs: t.Any)
# Code for function: send_file(path_or_file: os.PathLike[t.AnyStr] | str | t.BinaryIO, mimetype: str | None = None, as_attachment: bool = False, download_name: str | None = None, conditional: bool = True, etag: bool | str = True, last_modified: datetime | int | float | None = None, max_age: None | (int | t.Callable[[str | None], int | None]) = None, )
# Code for function: send_from_directory(directory: os.PathLike[str] | str, path: os.PathLike[str] | str, **kwargs: t.Any, )
# Code for function: get_root_path(import_name: str)
@cache
def _split_blueprint_path(name: str) -> list[str]:
    out: list[str] = [name]

    if "." in name:
        out.extend(_split_blueprint_path(name.rpartition(".")[0]))

    return out

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/src/flask/blueprints.py,0,4540
Arguments: []
Code: // Code for Global Scope
from __future__ import annotations
import os
import typing as t
from datetime import timedelta
from .cli import AppGroup
from .globals import current_app
from .helpers import send_from_directory
from .sansio.blueprints import Blueprint as SansioBlueprint
from .sansio.blueprints import BlueprintSetupState as BlueprintSetupState
# noqa
from .sansio.scaffold import _sentinel
if t.TYPE_CHECKING:  # pragma: no cover
    from .wrappers import Response
# Code for class: Blueprint(self, name: str, import_name: str, static_folder: str | os.PathLike[str] | None = None, static_url_path: str | None = None, template_folder: str | os.PathLike[str] | None = None, url_prefix: str | None = None, subdomain: str | None = None, url_defaults: dict[str, t.Any] | None = None, root_path: str | None = None, cli_group: str | None = _sentinel, # type: ignore)
# Code for function: Blueprint.__init__(self, name: str, import_name: str, static_folder: str | os.PathLike[str] | None = None, static_url_path: str | None = None, template_folder: str | os.PathLike[str] | None = None, url_prefix: str | None = None, subdomain: str | None = None, url_defaults: dict[str, t.Any] | None = None, root_path: str | None = None, cli_group: str | None = _sentinel, # type: ignore)
# Code for function: Blueprint.get_send_file_max_age(self, filename: str | None)
# Code for function: Blueprint.send_static_file(self, filename: str)
# Code for function: Blueprint.open_resource(self, resource: str, mode: str = "rb", encoding: str | None = "utf-8")

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Blueprint
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/blueprints.py,456,494
Arguments: ['self', 'name: str', 'import_name: str', 'static_folder: str | os.PathLike[str] | None = None', 'static_url_path: str | None = None', 'template_folder: str | os.PathLike[str] | None = None', 'url_prefix: str | None = None', 'subdomain: str | None = None', 'url_defaults: dict[str', 't.Any] | None = None', 'root_path: str | None = None', 'cli_group: str | None = _sentinel', '# type: ignore']
Code: class Blueprint(SansioBlueprint):
    # Code for function: Blueprint.__init__(self, name: str, import_name: str, static_folder: str | os.PathLike[str] | None = None, static_url_path: str | None = None, template_folder: str | os.PathLike[str] | None = None, url_prefix: str | None = None, subdomain: str | None = None, url_defaults: dict[str, t.Any] | None = None, root_path: str | None = None, cli_group: str | None = _sentinel, # type: ignore)
# Code for function: Blueprint.get_send_file_max_age(self, filename: str | None)
# Code for function: Blueprint.send_static_file(self, filename: str)
# Code for function: Blueprint.open_resource(self, resource: str, mode: str = "rb", encoding: str | None = "utf-8")

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: Blueprint
Location: /home/yuesheng/flask/src/flask/blueprints.py,494,1693
Arguments: ['self', 'name: str', 'import_name: str', 'static_folder: str | os.PathLike[str] | None = None', 'static_url_path: str | None = None', 'template_folder: str | os.PathLike[str] | None = None', 'url_prefix: str | None = None', 'subdomain: str | None = None', 'url_defaults: dict[str', 't.Any] | None = None', 'root_path: str | None = None', 'cli_group: str | None = _sentinel', '# type: ignore']
Code: def __init__(
        self,
        name: str,
        import_name: str,
        static_folder: str | os.PathLike[str] | None = None,
        static_url_path: str | None = None,
        template_folder: str | os.PathLike[str] | None = None,
        url_prefix: str | None = None,
        subdomain: str | None = None,
        url_defaults: dict[str, t.Any] | None = None,
        root_path: str | None = None,
        cli_group: str | None = _sentinel,  # type: ignore
    ) -> None:
        super().__init__(
            name,
            import_name,
            static_folder,
            static_url_path,
            template_folder,
            url_prefix,
            subdomain,
            url_defaults,
            root_path,
            cli_group,
        )

        #: The Click command group for registering CLI commands for this
        #: object. The commands are available from the ``flask`` command
        #: once the application has been discovered and blueprints have
        #: been registered.
        self.cli = AppGroup()

        # Set the name of the Click group in case someone wants to add
        # the app's commands to another CLI tool.
        self.cli.name = self.name
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get_send_file_max_age
Type: function
Parent Type: Blueprint
Location: /home/yuesheng/flask/src/flask/blueprints.py,1699,2660
Arguments: ['self', 'filename: str | None']
Code: def get_send_file_max_age(self, filename: str | None) -> int | None:
        """Used by :func:`send_file` to determine the ``max_age`` cache
        value for a given file path if it wasn't passed.

        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from
        the configuration of :data:`~flask.current_app`. This defaults
        to ``None``, which tells the browser to use conditional requests
        instead of a timed cache, which is usually preferable.

        Note this is a duplicate of the same method in the Flask
        class.

        .. versionchanged:: 2.0
            The default configuration is ``None`` instead of 12 hours.

        .. versionadded:: 0.9
        """
        value = current_app.config["SEND_FILE_MAX_AGE_DEFAULT"]

        if value is None:
            return None

        if isinstance(value, timedelta):
            return int(value.total_seconds())

        return value  # type: ignore[no-any-return]
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: send_static_file
Type: function
Parent Type: Blueprint
Location: /home/yuesheng/flask/src/flask/blueprints.py,2666,3481
Arguments: ['self', 'filename: str']
Code: def send_static_file(self, filename: str) -> Response:
        """The view function used to serve files from
        :attr:`static_folder`. A route is automatically registered for
        this view at :attr:`static_url_path` if :attr:`static_folder` is
        set.

        Note this is a duplicate of the same method in the Flask
        class.

        .. versionadded:: 0.5

        """
        if not self.has_static_folder:
            raise RuntimeError("'static_folder' must be set to serve static_files.")

        # send_file only knows to call get_send_file_max_age on the app,
        # call it here so it works for blueprints too.
        max_age = self.get_send_file_max_age(filename)
        return send_from_directory(
            t.cast(str, self.static_folder), filename, max_age=max_age
        )
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: open_resource
Type: function
Parent Type: Blueprint
Location: /home/yuesheng/flask/src/flask/blueprints.py,3487,4540
Arguments: ['self', 'resource: str', 'mode: str = "rb"', 'encoding: str | None = "utf-8"']
Code: def open_resource(
        self, resource: str, mode: str = "rb", encoding: str | None = "utf-8"
    ) -> t.IO[t.AnyStr]:
        """Open a resource file relative to :attr:`root_path` for reading. The
        blueprint-relative equivalent of the app's :meth:`~.Flask.open_resource`
        method.

        :param resource: Path to the resource relative to :attr:`root_path`.
        :param mode: Open the file in this mode. Only reading is supported,
            valid values are ``"r"`` (or ``"rt"``) and ``"rb"``.
        :param encoding: Open the file with this encoding when opening in text
            mode. This is ignored when opening in binary mode.

        .. versionchanged:: 3.1
            Added the ``encoding`` parameter.
        """
        if mode not in {"r", "rt", "rb"}:
            raise ValueError("Resources can only be opened for reading.")

        path = os.path.join(self.root_path, resource)

        if mode == "rb":
            return open(path, mode)  # pyright: ignore

        return open(path, mode, encoding=encoding)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _make_timedelta
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/app.py,2508,2691
Arguments: ['value: timedelta | int | None']
Code: def __init__(
        self,
        import_name: str,
        static_url_path: str | None = None,
        static_folder: str | os.PathLike[str] | None = "static",
        static_host: str | None = None,
        host_matching: bool = False,
        subdomain_matching: bool = False,
        template_folder: str | os.PathLike[str] | None = "templates",
        instance_path: str | None = None,
        instance_relative_config: bool = False,
        root_path: str | None = None,
    ):
        super().__init__(
            import_name=import_name,
            static_url_path=static_url_path,
            static_folder=static_folder,
            static_host=static_host,
            host_matching=host_matching,
            subdomain_matching=subdomain_matching,
            template_folder=template_folder,
            instance_path=instance_path,
            instance_relative_config=instance_relative_config,
            root_path=root_path,
        )

        #: The Click command group for registering CLI commands for this
        #: object. The commands are available from the ``flask`` command
        #: once the application has been discovered and blueprints have
        #: been registered.
        self.cli = cli.AppGroup()

        # Set the name of the Click group in case someone wants to add
        # the app's commands to another CLI tool.
        self.cli.name = self.name

        # Add a static route using the provided static_url_path, static_host,
        # and static_folder if there is a configured static_folder.
        # Note we do this without checking if static_folder exists.
        # For one, it might be created while the server is running (e.g. during
        # development). Also, Google App Engine stores static files somewhere
        if self.has_static_folder:
            assert (
                bool(static_host) == host_matching
            ), "Invalid static_host/host_matching combination"
            # Use a weakref to avoid creating a reference cycle between the app
            # and the view function (see #3761).
            self_ref = weakref.ref(self)
            self.add_url_rule(
                f"{self.static_url_path}/<path:filename>",
                endpoint="static",
                host=static_host,
                view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950
            )
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Flask
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/app.py,2694,9384
Arguments: ['self', 'import_name: str', 'static_url_path: str | None = None', 'static_folder: str | os.PathLike[str] | None = "static"', 'static_host: str | None = None', 'host_matching: bool = False', 'subdomain_matching: bool = False', 'template_folder: str | os.PathLike[str] | None = "templates"', 'instance_path: str | None = None', 'instance_relative_config: bool = False', 'root_path: str | None = None', '']
Code: // Code for Global Scope
from __future__ import annotations
import collections.abc as cabc
import os
import sys
import typing as t
import weakref
from datetime import timedelta
from inspect import iscoroutinefunction
from itertools import chain
from types import TracebackType
from urllib.parse import quote as _url_quote
import click
from werkzeug.datastructures import Headers
from werkzeug.datastructures import ImmutableDict
from werkzeug.exceptions import BadRequestKeyError
from werkzeug.exceptions import HTTPException
from werkzeug.exceptions import InternalServerError
from werkzeug.routing import BuildError
from werkzeug.routing import MapAdapter
from werkzeug.routing import RequestRedirect
from werkzeug.routing import RoutingException
from werkzeug.routing import Rule
from werkzeug.serving import is_running_from_reloader
from werkzeug.wrappers import Response as BaseResponse
from werkzeug.wsgi import get_host
from . import cli
from . import typing as ft
from .ctx import AppContext
from .ctx import RequestContext
from .globals import _cv_app
from .globals import _cv_request
from .globals import current_app
from .globals import g
from .globals import request
from .globals import request_ctx
from .globals import session
from .helpers import get_debug_flag
from .helpers import get_flashed_messages
from .helpers import get_load_dotenv
from .helpers import send_from_directory
from .sansio.app import App
from .sansio.scaffold import _sentinel
from .sessions import SecureCookieSessionInterface
from .sessions import SessionInterface
from .signals import appcontext_tearing_down
from .signals import got_request_exception
from .signals import request_finished
from .signals import request_started
from .signals import request_tearing_down
from .templating import Environment
from .wrappers import Request
from .wrappers import Response
if t.TYPE_CHECKING:  # pragma: no cover
    from _typeshed.wsgi import StartResponse
    from _typeshed.wsgi import WSGIEnvironment

    from .testing import FlaskClient
    from .testing import FlaskCliRunner
    from .typing import HeadersValue
T_shell_context_processor = t.TypeVar(
    "T_shell_context_processor", bound=ft.ShellContextProcessorCallable
)
T_teardown = t.TypeVar("T_teardown", bound=ft.TeardownCallable)
T_template_filter = t.TypeVar("T_template_filter", bound=ft.TemplateFilterCallable)
T_template_global = t.TypeVar("T_template_global", bound=ft.TemplateGlobalCallable)
T_template_test = t.TypeVar("T_template_test", bound=ft.TemplateTestCallable)
# Code for function: _make_timedelta(value: timedelta | int | None)
# Code for class: Flask(self, import_name: str, static_url_path: str | None = None, static_folder: str | os.PathLike[str] | None = "static", static_host: str | None = None, host_matching: bool = False, subdomain_matching: bool = False, template_folder: str | os.PathLike[str] | None = "templates", instance_path: str | None = None, instance_relative_config: bool = False, root_path: str | None = None, )
# Code for function: Flask.__init__(self, import_name: str, static_url_path: str | None = None, static_folder: str | os.PathLike[str] | None = "static", static_host: str | None = None, host_matching: bool = False, subdomain_matching: bool = False, template_folder: str | os.PathLike[str] | None = "templates", instance_path: str | None = None, instance_relative_config: bool = False, root_path: str | None = None, )
# Code for function: Flask.get_send_file_max_age(self, filename: str | None)
# Code for function: Flask.send_static_file(self, filename: str)
# Code for function: Flask.open_resource(self, resource: str, mode: str = "rb", encoding: str | None = None)
# Code for function: Flask.open_instance_resource(self, resource: str, mode: str = "rb", encoding: str | None = "utf-8")
# Code for function: Flask.create_jinja_environment(self)
# Code for function: Flask.create_url_adapter(self, request: Request | None)
# Code for function: Flask.raise_routing_exception(self, request: Request)
# Code for function: Flask.update_template_context(self, context: dict[str, t.Any])
# Code for function: Flask.make_shell_context(self)
# Code for function: Flask.run(self, host: str | None = None, port: int | None = None, debug: bool | None = None, load_dotenv: bool = True, **options: t.Any, )
# Code for function: Flask.test_client(self, use_cookies: bool = True, **kwargs: t.Any)
# Code for function: Flask.test_cli_runner(self, **kwargs: t.Any)
# Code for function: Flask.handle_http_exception(self, e: HTTPException)
# Code for function: Flask.handle_user_exception(self, e: Exception)
# Code for function: Flask.handle_exception(self, e: Exception)
# Code for function: Flask.log_exception(self, exc_info: (tuple[type, BaseException, TracebackType] | tuple[None, None, None]), )
# Code for function: Flask.dispatch_request(self)
# Code for function: Flask.full_dispatch_request(self)
# Code for function: Flask.finalize_request(self, rv: ft.ResponseReturnValue | HTTPException, from_error_handler: bool = False, )
# Code for function: Flask.make_default_options_response(self)
# Code for function: Flask.ensure_sync(self, func: t.Callable[..., t.Any])
# Code for function: Flask.async_to_sync(self, func: t.Callable[..., t.Coroutine[t.Any, t.Any, t.Any]])
# Code for function: Flask.url_for(self, /, endpoint: str, *, _anchor: str | None = None, _method: str | None = None, _scheme: str | None = None, _external: bool | None = None, **values: t.Any, )
# Code for function: Flask.make_response(self, rv: ft.ResponseReturnValue)
# Code for function: Flask.preprocess_request(self)
# Code for function: Flask.process_response(self, response: Response)
# Code for function: Flask.do_teardown_request(self, exc: BaseException | None = _sentinel, # type: ignore[assignment])
# Code for function: Flask.do_teardown_appcontext(self, exc: BaseException | None = _sentinel, # type: ignore[assignment])
# Code for function: Flask.app_context(self)
# Code for function: Flask.request_context(self, environ: WSGIEnvironment)
# Code for function: Flask.test_request_context(self, *args: t.Any, **kwargs: t.Any)
# Code for function: Flask.wsgi_app(self, environ: WSGIEnvironment, start_response: StartResponse)
# Code for function: Flask.__call__(self, environ: WSGIEnvironment, start_response: StartResponse)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,9384,11766
Arguments: ['self', 'import_name: str', 'static_url_path: str | None = None', 'static_folder: str | os.PathLike[str] | None = "static"', 'static_host: str | None = None', 'host_matching: bool = False', 'subdomain_matching: bool = False', 'template_folder: str | os.PathLike[str] | None = "templates"', 'instance_path: str | None = None', 'instance_relative_config: bool = False', 'root_path: str | None = None', '']
Code: def get_send_file_max_age(self, filename: str | None) -> int | None:
        """Used by :func:`send_file` to determine the ``max_age`` cache
        value for a given file path if it wasn't passed.

        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from
        the configuration of :data:`~flask.current_app`. This defaults
        to ``None``, which tells the browser to use conditional requests
        instead of a timed cache, which is usually preferable.

        Note this is a duplicate of the same method in the Flask
        class.

        .. versionchanged:: 2.0
            The default configuration is ``None`` instead of 12 hours.

        .. versionadded:: 0.9
        """
        value = current_app.config["SEND_FILE_MAX_AGE_DEFAULT"]

        if value is None:
            return None

        if isinstance(value, timedelta):
            return int(value.total_seconds())

        return value  # type: ignore[no-any-return]
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get_send_file_max_age
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,11772,12733
Arguments: ['self', 'filename: str | None']
Code: def send_static_file(self, filename: str) -> Response:
        """The view function used to serve files from
        :attr:`static_folder`. A route is automatically registered for
        this view at :attr:`static_url_path` if :attr:`static_folder` is
        set.

        Note this is a duplicate of the same method in the Flask
        class.

        .. versionadded:: 0.5

        """
        if not self.has_static_folder:
            raise RuntimeError("'static_folder' must be set to serve static_files.")

        # send_file only knows to call get_send_file_max_age on the app,
        # call it here so it works for blueprints too.
        max_age = self.get_send_file_max_age(filename)
        return send_from_directory(
            t.cast(str, self.static_folder), filename, max_age=max_age
        )
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: send_static_file
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,12739,13554
Arguments: ['self', 'filename: str']
Code: def open_resource(
        self, resource: str, mode: str = "rb", encoding: str | None = None
    ) -> t.IO[t.AnyStr]:
        """Open a resource file relative to :attr:`root_path` for reading.

        For example, if the file ``schema.sql`` is next to the file
        ``app.py`` where the ``Flask`` app is defined, it can be opened
        with:

        .. code-block:: python

            with app.open_resource("schema.sql") as f:
                conn.executescript(f.read())

        :param resource: Path to the resource relative to :attr:`root_path`.
        :param mode: Open the file in this mode. Only reading is supported,
            valid values are ``"r"`` (or ``"rt"``) and ``"rb"``.
        :param encoding: Open the file with this encoding when opening in text
            mode. This is ignored when opening in binary mode.

        .. versionchanged:: 3.1
            Added the ``encoding`` parameter.
        """
        if mode not in {"r", "rt", "rb"}:
            raise ValueError("Resources can only be opened for reading.")

        path = os.path.join(self.root_path, resource)

        if mode == "rb":
            return open(path, mode)  # pyright: ignore

        return open(path, mode, encoding=encoding)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: open_resource
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,13560,14797
Arguments: ['self', 'resource: str', 'mode: str = "rb"', 'encoding: str | None = None']
Code: def open_instance_resource(
        self, resource: str, mode: str = "rb", encoding: str | None = "utf-8"
    ) -> t.IO[t.AnyStr]:
        """Open a resource file relative to the application's instance folder
        :attr:`instance_path`. Unlike :meth:`open_resource`, files in the
        instance folder can be opened for writing.

        :param resource: Path to the resource relative to :attr:`instance_path`.
        :param mode: Open the file in this mode.
        :param encoding: Open the file with this encoding when opening in text
            mode. This is ignored when opening in binary mode.

        .. versionchanged:: 3.1
            Added the ``encoding`` parameter.
        """
        path = os.path.join(self.instance_path, resource)

        if "b" in mode:
            return open(path, mode)

        return open(path, mode, encoding=encoding)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: open_instance_resource
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,14803,15671
Arguments: ['self', 'resource: str', 'mode: str = "rb"', 'encoding: str | None = "utf-8"']
Code: def create_jinja_environment(self) -> Environment:
        """Create the Jinja environment based on :attr:`jinja_options`
        and the various Jinja-related methods of the app. Changing
        :attr:`jinja_options` after this will have no effect. Also adds
        Flask-related globals and filters to the environment.

        .. versionchanged:: 0.11
           ``Environment.auto_reload`` set in accordance with
           ``TEMPLATES_AUTO_RELOAD`` configuration option.

        .. versionadded:: 0.5
        """
        options = dict(self.jinja_options)

        if "autoescape" not in options:
            options["autoescape"] = self.select_jinja_autoescape

        if "auto_reload" not in options:
            auto_reload = self.config["TEMPLATES_AUTO_RELOAD"]

            if auto_reload is None:
                auto_reload = self.debug

            options["auto_reload"] = auto_reload

        rv = self.jinja_environment(self, **options)
        rv.globals.update(
            url_for=self.url_for,
            get_flashed_messages=get_flashed_messages,
            config=self.config,
            # request, session and g are normally added with the
            # context processor for efficiency reasons but for imported
            # templates we also want the proxies in there.
            request=request,
            session=session,
            g=g,
        )
        rv.policies["json.dumps_function"] = self.json.dumps
        return rv
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: create_jinja_environment
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,15677,17141
Arguments: ['self']
Code: def create_url_adapter(self, request: Request | None) -> MapAdapter | None:
        """Creates a URL adapter for the given request. The URL adapter
        is created at a point where the request context is not yet set
        up so the request is passed explicitly.

        .. versionchanged:: 3.1
            If :data:`SERVER_NAME` is set, it does not restrict requests to
            only that domain, for both ``subdomain_matching`` and
            ``host_matching``.

        .. versionchanged:: 1.0
            :data:`SERVER_NAME` no longer implicitly enables subdomain
            matching. Use :attr:`subdomain_matching` instead.

        .. versionchanged:: 0.9
           This can be called outside a request when the URL adapter is created
           for an application context.

        .. versionadded:: 0.6
        """
        if request is not None:
            if (trusted_hosts := self.config["TRUSTED_HOSTS"]) is not None:
                request.trusted_hosts = trusted_hosts

            # Check trusted_hosts here until bind_to_environ does.
            request.host = get_host(request.environ, request.trusted_hosts)  # pyright: ignore
            subdomain = None
            server_name = self.config["SERVER_NAME"]

            if self.url_map.host_matching:
                # Don't pass SERVER_NAME, otherwise it's used and the actual
                # host is ignored, which breaks host matching.
                server_name = None
            elif not self.subdomain_matching:
                # Werkzeug doesn't implement subdomain matching yet. Until then,
                # disable it by forcing the current subdomain to the default, or
                # the empty string.
                subdomain = self.url_map.default_subdomain or ""

            return self.url_map.bind_to_environ(
                request.environ, server_name=server_name, subdomain=subdomain
            )

        # Need at least SERVER_NAME to match/build outside a request.
        if self.config["SERVER_NAME"] is not None:
            return self.url_map.bind(
                self.config["SERVER_NAME"],
                script_name=self.config["APPLICATION_ROOT"],
                url_scheme=self.config["PREFERRED_URL_SCHEME"],
            )

        return None
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: create_url_adapter
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,17147,19421
Arguments: ['self', 'request: Request | None']
Code: def raise_routing_exception(self, request: Request) -> t.NoReturn:
        """Intercept routing exceptions and possibly do something else.

        In debug mode, intercept a routing redirect and replace it with
        an error if the body will be discarded.

        With modern Werkzeug this shouldn't occur, since it now uses a
        308 status which tells the browser to resend the method and
        body.

        .. versionchanged:: 2.1
            Don't intercept 307 and 308 redirects.

        :meta private:
        :internal:
        """
        if (
            not self.debug
            or not isinstance(request.routing_exception, RequestRedirect)
            or request.routing_exception.code in {307, 308}
            or request.method in {"GET", "HEAD", "OPTIONS"}
        ):
            raise request.routing_exception  # type: ignore[misc]

        from .debughelpers import FormDataRoutingRedirect

        raise FormDataRoutingRedirect(request)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: raise_routing_exception
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,19427,20397
Arguments: ['self', 'request: Request']
Code: def update_template_context(self, context: dict[str, t.Any]) -> None:
        """Update the template context with some commonly used variables.
        This injects request, session, config and g into the template
        context as well as everything template context processors want
        to inject.  Note that the as of Flask 0.6, the original values
        in the context will not be overridden if a context processor
        decides to return a value with the same key.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """
        names: t.Iterable[str | None] = (None,)

        # A template may be rendered outside a request context.
        if request:
            names = chain(names, reversed(request.blueprints))

        # The values passed to render_template take precedence. Keep a
        # copy to re-apply after all context functions.
        orig_ctx = context.copy()

        for name in names:
            if name in self.template_context_processors:
                for func in self.template_context_processors[name]:
                    context.update(self.ensure_sync(func)())

        context.update(orig_ctx)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: update_template_context
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,20403,21624
Arguments: ['self', 'context: dict[str', 't.Any]']
Code: def make_shell_context(self) -> dict[str, t.Any]:
        """Returns the shell context for an interactive shell for this
        application.  This runs all the registered shell context
        processors.

        .. versionadded:: 0.11
        """
        rv = {"app": self, "g": g}
        for processor in self.shell_context_processors:
            rv.update(processor())
        return rv
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: make_shell_context
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,21630,22023
Arguments: ['self']
Code: def run(
        self,
        host: str | None = None,
        port: int | None = None,
        debug: bool | None = None,
        load_dotenv: bool = True,
        **options: t.Any,
    ) -> None:
        """Runs the application on a local development server.

        Do not use ``run()`` in a production setting. It is not intended to
        meet security and performance requirements for a production server.
        Instead, see :doc:`/deploying/index` for WSGI server recommendations.

        If the :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        If you want to run the application in debug mode, but disable the
        code execution on the interactive debugger, you can pass
        ``use_evalex=False`` as parameter.  This will keep the debugger's
        traceback screen active, but disable code execution.

        It is not recommended to use this function for development with
        automatic reloading as this is badly supported.  Instead you should
        be using the :command:`flask` command line script's ``run`` support.

        .. admonition:: Keep in Mind

           Flask will suppress any server error with a generic error page
           unless it is in debug mode.  As such to enable just the
           interactive debugger without the code reloading, you have to
           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.
           Setting ``use_debugger`` to ``True`` without being in debug mode
           won't catch any exceptions because there won't be any to
           catch.

        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to
            have the server available externally as well. Defaults to
            ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable
            if present.
        :param port: the port of the webserver. Defaults to ``5000`` or the
            port defined in the ``SERVER_NAME`` config variable if present.
        :param debug: if given, enable or disable debug mode. See
            :attr:`debug`.
        :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`
            files to set environment variables. Will also change the working
            directory to the directory containing the first file found.
        :param options: the options to be forwarded to the underlying Werkzeug
            server. See :func:`werkzeug.serving.run_simple` for more
            information.

        .. versionchanged:: 1.0
            If installed, python-dotenv will be used to load environment
            variables from :file:`.env` and :file:`.flaskenv` files.

            The :envvar:`FLASK_DEBUG` environment variable will override :attr:`debug`.

            Threaded mode is enabled by default.

        .. versionchanged:: 0.10
            The default port is now picked from the ``SERVER_NAME``
            variable.
        """
        # Ignore this call so that it doesn't start another server if
        # the 'flask run' command is used.
        if os.environ.get("FLASK_RUN_FROM_CLI") == "true":
            if not is_running_from_reloader():
                click.secho(
                    " * Ignoring a call to 'app.run()' that would block"
                    " the current 'flask' CLI command.\n"
                    "   Only call 'app.run()' in an 'if __name__ =="
                    ' "__main__"\' guard.',
                    fg="red",
                )

            return

        if get_load_dotenv(load_dotenv):
            cli.load_dotenv()

            # if set, env var overrides existing value
            if "FLASK_DEBUG" in os.environ:
                self.debug = get_debug_flag()

        # debug passed to method overrides all other sources
        if debug is not None:
            self.debug = bool(debug)

        server_name = self.config.get("SERVER_NAME")
        sn_host = sn_port = None

        if server_name:
            sn_host, _, sn_port = server_name.partition(":")

        if not host:
            if sn_host:
                host = sn_host
            else:
                host = "127.0.0.1"

        if port or port == 0:
            port = int(port)
        elif sn_port:
            port = int(sn_port)
        else:
            port = 5000

        options.setdefault("use_reloader", self.debug)
        options.setdefault("use_debugger", self.debug)
        options.setdefault("threaded", True)

        cli.show_server_banner(self.debug, self.name)

        from werkzeug.serving import run_simple

        try:
            run_simple(t.cast(str, host), port, self, **options)
        finally:
            # reset the first request information if the development server
            # reset normally.  This makes it possible to restart the server
            # without reloader and that stuff from an interactive shell.
            self._got_first_request = False
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: run
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,22029,27004
Arguments: ['self', 'host: str | None = None', 'port: int | None = None', 'debug: bool | None = None', 'load_dotenv: bool = True', '**options: t.Any', '']
Code: def test_client(self, use_cookies: bool = True, **kwargs: t.Any) -> FlaskClient:
        """Creates a test client for this application.  For information
        about unit testing head over to :doc:`/testing`.

        Note that if you are testing for assertions or exceptions in your
        application code, you must set ``app.testing = True`` in order for the
        exceptions to propagate to the test client.  Otherwise, the exception
        will be handled by the application (not visible to the test client) and
        the only indication of an AssertionError or other exception will be a
        500 status code response to the test client.  See the :attr:`testing`
        attribute.  For example::

            app.testing = True
            client = app.test_client()

        The test client can be used in a ``with`` block to defer the closing down
        of the context until the end of the ``with`` block.  This is useful if
        you want to access the context locals for testing::

            with app.test_client() as c:
                rv = c.get('/?vodka=42')
                assert request.args['vodka'] == '42'

        Additionally, you may pass optional keyword arguments that will then
        be passed to the application's :attr:`test_client_class` constructor.
        For example::

            from flask.testing import FlaskClient

            class CustomClient(FlaskClient):
                def __init__(self, *args, **kwargs):
                    self._authentication = kwargs.pop("authentication")
                    super(CustomClient,self).__init__( *args, **kwargs)

            app.test_client_class = CustomClient
            client = app.test_client(authentication='Basic ....')

        See :class:`~flask.testing.FlaskClient` for more information.

        .. versionchanged:: 0.4
           added support for ``with`` block usage for the client.

        .. versionadded:: 0.7
           The `use_cookies` parameter was added as well as the ability
           to override the client to be used by setting the
           :attr:`test_client_class` attribute.

        .. versionchanged:: 0.11
           Added `**kwargs` to support passing additional keyword arguments to
           the constructor of :attr:`test_client_class`.
        """
        cls = self.test_client_class
        if cls is None:
            from .testing import FlaskClient as cls
        return cls(  # type: ignore
            self, self.response_class, use_cookies=use_cookies, **kwargs
        )
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_client
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,27010,29533
Arguments: ['self', 'use_cookies: bool = True', '**kwargs: t.Any']
Code: def test_cli_runner(self, **kwargs: t.Any) -> FlaskCliRunner:
        """Create a CLI runner for testing CLI commands.
        See :ref:`testing-cli`.

        Returns an instance of :attr:`test_cli_runner_class`, by default
        :class:`~flask.testing.FlaskCliRunner`. The Flask app object is
        passed as the first argument.

        .. versionadded:: 1.0
        """
        cls = self.test_cli_runner_class

        if cls is None:
            from .testing import FlaskCliRunner as cls

        return cls(self, **kwargs)  # type: ignore
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_cli_runner
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,29539,30089
Arguments: ['self', '**kwargs: t.Any']
Code: def handle_http_exception(
        self, e: HTTPException
    ) -> HTTPException | ft.ResponseReturnValue:
        """Handles an HTTP exception.  By default this will invoke the
        registered error handlers and fall back to returning the
        exception as response.

        .. versionchanged:: 1.0.3
            ``RoutingException``, used internally for actions such as
             slash redirects during routing, is not passed to error
             handlers.

        .. versionchanged:: 1.0
            Exceptions are looked up by code *and* by MRO, so
            ``HTTPException`` subclasses can be handled with a catch-all
            handler for the base ``HTTPException``.

        .. versionadded:: 0.3
        """
        # Proxy exceptions don't have error codes.  We want to always return
        # those unchanged as errors
        if e.code is None:
            return e

        # RoutingExceptions are used internally to trigger routing
        # actions, such as slash redirects raising RequestRedirect. They
        # are not raised or handled in user code.
        if isinstance(e, RoutingException):
            return e

        handler = self._find_error_handler(e, request.blueprints)
        if handler is None:
            return e
        return self.ensure_sync(handler)(e)  # type: ignore[no-any-return]
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: handle_http_exception
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,30095,31435
Arguments: ['self', 'e: HTTPException']
Code: def handle_user_exception(
        self, e: Exception
    ) -> HTTPException | ft.ResponseReturnValue:
        """This method is called whenever an exception occurs that
        should be handled. A special case is :class:`~werkzeug
        .exceptions.HTTPException` which is forwarded to the
        :meth:`handle_http_exception` method. This function will either
        return a response value or reraise the exception with the same
        traceback.

        .. versionchanged:: 1.0
            Key errors raised from request data like ``form`` show the
            bad key in debug mode rather than a generic bad request
            message.

        .. versionadded:: 0.7
        """
        if isinstance(e, BadRequestKeyError) and (
            self.debug or self.config["TRAP_BAD_REQUEST_ERRORS"]
        ):
            e.show_exception = True

        if isinstance(e, HTTPException) and not self.trap_http_exception(e):
            return self.handle_http_exception(e)

        handler = self._find_error_handler(e, request.blueprints)

        if handler is None:
            raise

        return self.ensure_sync(handler)(e)  # type: ignore[no-any-return]
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: handle_user_exception
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,31441,32612
Arguments: ['self', 'e: Exception']
Code: def handle_exception(self, e: Exception) -> Response:
        """Handle an exception that did not have an error handler
        associated with it, or that was raised from an error handler.
        This always causes a 500 ``InternalServerError``.

        Always sends the :data:`got_request_exception` signal.

        If :data:`PROPAGATE_EXCEPTIONS` is ``True``, such as in debug
        mode, the error will be re-raised so that the debugger can
        display it. Otherwise, the original exception is logged, and
        an :exc:`~werkzeug.exceptions.InternalServerError` is returned.

        If an error handler is registered for ``InternalServerError`` or
        ``500``, it will be used. For consistency, the handler will
        always receive the ``InternalServerError``. The original
        unhandled exception is available as ``e.original_exception``.

        .. versionchanged:: 1.1.0
            Always passes the ``InternalServerError`` instance to the
            handler, setting ``original_exception`` to the unhandled
            error.

        .. versionchanged:: 1.1.0
            ``after_request`` functions and other finalization is done
            even for the default 500 response when there is no handler.

        .. versionadded:: 0.3
        """
        exc_info = sys.exc_info()
        got_request_exception.send(self, _async_wrapper=self.ensure_sync, exception=e)
        propagate = self.config["PROPAGATE_EXCEPTIONS"]

        if propagate is None:
            propagate = self.testing or self.debug

        if propagate:
            # Re-raise if called with an active exception, otherwise
            # raise the passed in exception.
            if exc_info[1] is e:
                raise

            raise e

        self.log_exception(exc_info)
        server_error: InternalServerError | ft.ResponseReturnValue
        server_error = InternalServerError(original_exception=e)
        handler = self._find_error_handler(server_error, request.blueprints)

        if handler is not None:
            server_error = self.ensure_sync(handler)(server_error)

        return self.finalize_request(server_error, from_error_handler=True)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: handle_exception
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,32618,34795
Arguments: ['self', 'e: Exception']
Code: def log_exception(
        self,
        exc_info: (tuple[type, BaseException, TracebackType] | tuple[None, None, None]),
    ) -> None:
        """Logs an exception.  This is called by :meth:`handle_exception`
        if debugging is disabled and right before the handler is called.
        The default implementation logs the exception as error on the
        :attr:`logger`.

        .. versionadded:: 0.8
        """
        self.logger.error(
            f"Exception on {request.path} [{request.method}]", exc_info=exc_info
        )
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: log_exception
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,34801,35339
Arguments: ['self', 'exc_info: (tuple[type', 'BaseException', 'TracebackType] | tuple[None', 'None', 'None])', '']
Code: def dispatch_request(self) -> ft.ResponseReturnValue:
        """Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.

        .. versionchanged:: 0.7
           This no longer does the exception handling, this code was
           moved to the new :meth:`full_dispatch_request`.
        """
        req = request_ctx.request
        if req.routing_exception is not None:
            self.raise_routing_exception(req)
        rule: Rule = req.url_rule  # type: ignore[assignment]
        # if we provide automatic options for this URL and the
        # request came with the OPTIONS method, reply automatically
        if (
            getattr(rule, "provide_automatic_options", False)
            and req.method == "OPTIONS"
        ):
            return self.make_default_options_response()
        # otherwise dispatch to the handler for that endpoint
        view_args: dict[str, t.Any] = req.view_args  # type: ignore[assignment]
        return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: dispatch_request
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,35345,36607
Arguments: ['self']
Code: def full_dispatch_request(self) -> Response:
        """Dispatches the request and on top of that performs request
        pre and postprocessing as well as HTTP exception catching and
        error handling.

        .. versionadded:: 0.7
        """
        self._got_first_request = True

        try:
            request_started.send(self, _async_wrapper=self.ensure_sync)
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
        except Exception as e:
            rv = self.handle_user_exception(e)
        return self.finalize_request(rv)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: full_dispatch_request
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,36613,37223
Arguments: ['self']
Code: def finalize_request(
        self,
        rv: ft.ResponseReturnValue | HTTPException,
        from_error_handler: bool = False,
    ) -> Response:
        """Given the return value from a view function this finalizes
        the request by converting it into a response and invoking the
        postprocessing functions.  This is invoked for both normal
        request dispatching as well as error handlers.

        Because this means that it might be called as a result of a
        failure a special safe mode is available which can be enabled
        with the `from_error_handler` flag.  If enabled, failures in
        response processing will be logged and otherwise ignored.

        :internal:
        """
        response = self.make_response(rv)
        try:
            response = self.process_response(response)
            request_finished.send(
                self, _async_wrapper=self.ensure_sync, response=response
            )
        except Exception:
            if not from_error_handler:
                raise
            self.logger.exception(
                "Request finalizing failed with an error while handling an error"
            )
        return response
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: finalize_request
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,37229,38419
Arguments: ['self', 'rv: ft.ResponseReturnValue | HTTPException', 'from_error_handler: bool = False', '']
Code: def make_default_options_response(self) -> Response:
        """This method is called to create the default ``OPTIONS`` response.
        This can be changed through subclassing to change the default
        behavior of ``OPTIONS`` responses.

        .. versionadded:: 0.7
        """
        adapter = request_ctx.url_adapter
        methods = adapter.allowed_methods()  # type: ignore[union-attr]
        rv = self.response_class()
        rv.allow.update(methods)
        return rv
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: make_default_options_response
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,38425,38910
Arguments: ['self']
Code: def ensure_sync(self, func: t.Callable[..., t.Any]) -> t.Callable[..., t.Any]:
        """Ensure that the function is synchronous for WSGI workers.
        Plain ``def`` functions are returned as-is. ``async def``
        functions are wrapped to run and wait for the response.

        Override this method to change how the app runs async views.

        .. versionadded:: 2.0
        """
        if iscoroutinefunction(func):
            return self.async_to_sync(func)

        return func
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: ensure_sync
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,38916,39409
Arguments: ['self', 'func: t.Callable[...', 't.Any]']
Code: def async_to_sync(
        self, func: t.Callable[..., t.Coroutine[t.Any, t.Any, t.Any]]
    ) -> t.Callable[..., t.Any]:
        """Return a sync function that will run the coroutine function.

        .. code-block:: python

            result = app.async_to_sync(func)(*args, **kwargs)

        Override this method to change how the app converts async code
        to be synchronously callable.

        .. versionadded:: 2.0
        """
        try:
            from asgiref.sync import async_to_sync as asgiref_async_to_sync
        except ImportError:
            raise RuntimeError(
                "Install Flask with the 'async' extra in order to use async views."
            ) from None

        return asgiref_async_to_sync(func)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: async_to_sync
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,39415,40157
Arguments: ['self', 'func: t.Callable[...', 't.Coroutine[t.Any', 't.Any', 't.Any]]']
Code: def url_for(
        self,
        /,
        endpoint: str,
        *,
        _anchor: str | None = None,
        _method: str | None = None,
        _scheme: str | None = None,
        _external: bool | None = None,
        **values: t.Any,
    ) -> str:
        """Generate a URL to the given endpoint with the given values.

        This is called by :func:`flask.url_for`, and can be called
        directly as well.

        An *endpoint* is the name of a URL rule, usually added with
        :meth:`@app.route() <route>`, and usually the same name as the
        view function. A route defined in a :class:`~flask.Blueprint`
        will prepend the blueprint's name separated by a ``.`` to the
        endpoint.

        In some cases, such as email messages, you want URLs to include
        the scheme and domain, like ``https://example.com/hello``. When
        not in an active request, URLs will be external by default, but
        this requires setting :data:`SERVER_NAME` so Flask knows what
        domain to use. :data:`APPLICATION_ROOT` and
        :data:`PREFERRED_URL_SCHEME` should also be configured as
        needed. This config is only used when not in an active request.

        Functions can be decorated with :meth:`url_defaults` to modify
        keyword arguments before the URL is built.

        If building fails for some reason, such as an unknown endpoint
        or incorrect values, the app's :meth:`handle_url_build_error`
        method is called. If that returns a string, that is returned,
        otherwise a :exc:`~werkzeug.routing.BuildError` is raised.

        :param endpoint: The endpoint name associated with the URL to
            generate. If this starts with a ``.``, the current blueprint
            name (if any) will be used.
        :param _anchor: If given, append this as ``#anchor`` to the URL.
        :param _method: If given, generate the URL associated with this
            method for the endpoint.
        :param _scheme: If given, the URL will have this scheme if it
            is external.
        :param _external: If given, prefer the URL to be internal
            (False) or require it to be external (True). External URLs
            include the scheme and domain. When not in an active
            request, URLs are external by default.
        :param values: Values to use for the variable parts of the URL
            rule. Unknown keys are appended as query string arguments,
            like ``?a=b&c=d``.

        .. versionadded:: 2.2
            Moved from ``flask.url_for``, which calls this method.
        """
        req_ctx = _cv_request.get(None)

        if req_ctx is not None:
            url_adapter = req_ctx.url_adapter
            blueprint_name = req_ctx.request.blueprint

            # If the endpoint starts with "." and the request matches a
            # blueprint, the endpoint is relative to the blueprint.
            if endpoint[:1] == ".":
                if blueprint_name is not None:
                    endpoint = f"{blueprint_name}{endpoint}"
                else:
                    endpoint = endpoint[1:]

            # When in a request, generate a URL without scheme and
            # domain by default, unless a scheme is given.
            if _external is None:
                _external = _scheme is not None
        else:
            app_ctx = _cv_app.get(None)

            # If called by helpers.url_for, an app context is active,
            # use its url_adapter. Otherwise, app.url_for was called
            # directly, build an adapter.
            if app_ctx is not None:
                url_adapter = app_ctx.url_adapter
            else:
                url_adapter = self.create_url_adapter(None)

            if url_adapter is None:
                raise RuntimeError(
                    "Unable to build URLs outside an active request"
                    " without 'SERVER_NAME' configured. Also configure"
                    " 'APPLICATION_ROOT' and 'PREFERRED_URL_SCHEME' as"
                    " needed."
                )

            # When outside a request, generate a URL with scheme and
            # domain by default.
            if _external is None:
                _external = True

        # It is an error to set _scheme when _external=False, in order
        # to avoid accidental insecure URLs.
        if _scheme is not None and not _external:
            raise ValueError("When specifying '_scheme', '_external' must be True.")

        self.inject_url_defaults(endpoint, values)

        try:
            rv = url_adapter.build(  # type: ignore[union-attr]
                endpoint,
                values,
                method=_method,
                url_scheme=_scheme,
                force_external=_external,
            )
        except BuildError as error:
            values.update(
                _anchor=_anchor, _method=_method, _scheme=_scheme, _external=_external
            )
            return self.handle_url_build_error(error, endpoint, values)

        if _anchor is not None:
            _anchor = _url_quote(_anchor, safe="%!#$&'()*+,/:;=?@")
            rv = f"{rv}#{_anchor}"

        return rv
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: url_for
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,40163,45345
Arguments: ['self', '/', 'endpoint: str', '*', '_anchor: str | None = None', '_method: str | None = None', '_scheme: str | None = None', '_external: bool | None = None', '**values: t.Any', '']
Code: def make_response(self, rv: ft.ResponseReturnValue) -> Response:
        """Convert the return value from a view function to an instance of
        :attr:`response_class`.

        :param rv: the return value from the view function. The view function
            must return a response. Returning ``None``, or the view ending
            without returning, is not allowed. The following types are allowed
            for ``view_rv``:

            ``str``
                A response object is created with the string encoded to UTF-8
                as the body.

            ``bytes``
                A response object is created with the bytes as the body.

            ``dict``
                A dictionary that will be jsonify'd before being returned.

            ``list``
                A list that will be jsonify'd before being returned.

            ``generator`` or ``iterator``
                A generator that returns ``str`` or ``bytes`` to be
                streamed as the response.

            ``tuple``
                Either ``(body, status, headers)``, ``(body, status)``, or
                ``(body, headers)``, where ``body`` is any of the other types
                allowed here, ``status`` is a string or an integer, and
                ``headers`` is a dictionary or a list of ``(key, value)``
                tuples. If ``body`` is a :attr:`response_class` instance,
                ``status`` overwrites the exiting value and ``headers`` are
                extended.

            :attr:`response_class`
                The object is returned unchanged.

            other :class:`~werkzeug.wrappers.Response` class
                The object is coerced to :attr:`response_class`.

            :func:`callable`
                The function is called as a WSGI application. The result is
                used to create a response object.

        .. versionchanged:: 2.2
            A generator will be converted to a streaming response.
            A list will be converted to a JSON response.

        .. versionchanged:: 1.1
            A dict will be converted to a JSON response.

        .. versionchanged:: 0.9
           Previously a tuple was interpreted as the arguments for the
           response object.
        """

        status: int | None = None
        headers: HeadersValue | None = None

        # unpack tuple returns
        if isinstance(rv, tuple):
            len_rv = len(rv)

            # a 3-tuple is unpacked directly
            if len_rv == 3:
                rv, status, headers = rv  # type: ignore[misc]
            # decide if a 2-tuple has status or headers
            elif len_rv == 2:
                if isinstance(rv[1], (Headers, dict, tuple, list)):
                    rv, headers = rv  # pyright: ignore
                else:
                    rv, status = rv  # type: ignore[assignment,misc]
            # other sized tuples are not allowed
            else:
                raise TypeError(
                    "The view function did not return a valid response tuple."
                    " The tuple must have the form (body, status, headers),"
                    " (body, status), or (body, headers)."
                )

        # the body must not be None
        if rv is None:
            raise TypeError(
                f"The view function for {request.endpoint!r} did not"
                " return a valid response. The function either returned"
                " None or ended without a return statement."
            )

        # make sure the body is an instance of the response class
        if not isinstance(rv, self.response_class):
            if isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, cabc.Iterator):
                # let the response class set the status and headers instead of
                # waiting to do it manually, so that the class can handle any
                # special logic
                rv = self.response_class(
                    rv,
                    status=status,
                    headers=headers,  # type: ignore[arg-type]
                )
                status = headers = None
            elif isinstance(rv, (dict, list)):
                rv = self.json.response(rv)
            elif isinstance(rv, BaseResponse) or callable(rv):
                # evaluate a WSGI callable, or coerce a different response
                # class to the correct type
                try:
                    rv = self.response_class.force_type(
                        rv,  # type: ignore[arg-type]
                        request.environ,
                    )
                except TypeError as e:
                    raise TypeError(
                        f"{e}\nThe view function did not return a valid"
                        " response. The return type must be a string,"
                        " dict, list, tuple with headers or status,"
                        " Response instance, or WSGI callable, but it"
                        f" was a {type(rv).__name__}."
                    ).with_traceback(sys.exc_info()[2]) from None
            else:
                raise TypeError(
                    "The view function did not return a valid"
                    " response. The return type must be a string,"
                    " dict, list, tuple with headers or status,"
                    " Response instance, or WSGI callable, but it was a"
                    f" {type(rv).__name__}."
                )

        rv = t.cast(Response, rv)
        # prefer the status if it was provided
        if status is not None:
            if isinstance(status, (str, bytes, bytearray)):
                rv.status = status
            else:
                rv.status_code = status

        # extend existing headers with provided headers
        if headers:
            rv.headers.update(headers)

        return rv
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: make_response
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,45351,51210
Arguments: ['self', 'rv: ft.ResponseReturnValue']
Code: def preprocess_request(self) -> ft.ResponseReturnValue | None:
        """Called before the request is dispatched. Calls
        :attr:`url_value_preprocessors` registered with the app and the
        current blueprint (if any). Then calls :attr:`before_request_funcs`
        registered with the app and the blueprint.

        If any :meth:`before_request` handler returns a non-None value, the
        value is handled as if it was the return value from the view, and
        further request handling is stopped.
        """
        names = (None, *reversed(request.blueprints))

        for name in names:
            if name in self.url_value_preprocessors:
                for url_func in self.url_value_preprocessors[name]:
                    url_func(request.endpoint, request.view_args)

        for name in names:
            if name in self.before_request_funcs:
                for before_func in self.before_request_funcs[name]:
                    rv = self.ensure_sync(before_func)()

                    if rv is not None:
                        return rv  # type: ignore[no-any-return]

        return None
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: preprocess_request
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,51216,52341
Arguments: ['self']
Code: def process_response(self, response: Response) -> Response:
        """Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        .. versionchanged:: 0.5
           As of Flask 0.5 the functions registered for after request
           execution are called in reverse order of registration.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """
        ctx = request_ctx._get_current_object()  # type: ignore[attr-defined]

        for func in ctx._after_request_functions:
            response = self.ensure_sync(func)(response)

        for name in chain(request.blueprints, (None,)):
            if name in self.after_request_funcs:
                for func in reversed(self.after_request_funcs[name]):
                    response = self.ensure_sync(func)(response)

        if not self.session_interface.is_null_session(ctx.session):
            self.session_interface.save_session(self, ctx.session, response)

        return response
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: process_response
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,52347,53559
Arguments: ['self', 'response: Response']
Code: def do_teardown_request(
        self,
        exc: BaseException | None = _sentinel,  # type: ignore[assignment]
    ) -> None:
        """Called after the request is dispatched and the response is
        returned, right before the request context is popped.

        This calls all functions decorated with
        :meth:`teardown_request`, and :meth:`Blueprint.teardown_request`
        if a blueprint handled the request. Finally, the
        :data:`request_tearing_down` signal is sent.

        This is called by
        :meth:`RequestContext.pop() <flask.ctx.RequestContext.pop>`,
        which may be delayed during testing to maintain access to
        resources.

        :param exc: An unhandled exception raised while dispatching the
            request. Detected from the current exception information if
            not passed. Passed to each teardown function.

        .. versionchanged:: 0.9
            Added the ``exc`` argument.
        """
        if exc is _sentinel:
            exc = sys.exc_info()[1]

        for name in chain(request.blueprints, (None,)):
            if name in self.teardown_request_funcs:
                for func in reversed(self.teardown_request_funcs[name]):
                    self.ensure_sync(func)(exc)

        request_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: do_teardown_request
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,53565,54904
Arguments: ['self', 'exc: BaseException | None = _sentinel', '# type: ignore[assignment]']
Code: def do_teardown_appcontext(
        self,
        exc: BaseException | None = _sentinel,  # type: ignore[assignment]
    ) -> None:
        """Called right before the application context is popped.

        When handling a request, the application context is popped
        after the request context. See :meth:`do_teardown_request`.

        This calls all functions decorated with
        :meth:`teardown_appcontext`. Then the
        :data:`appcontext_tearing_down` signal is sent.

        This is called by
        :meth:`AppContext.pop() <flask.ctx.AppContext.pop>`.

        .. versionadded:: 0.9
        """
        if exc is _sentinel:
            exc = sys.exc_info()[1]

        for func in reversed(self.teardown_appcontext_funcs):
            self.ensure_sync(func)(exc)

        appcontext_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: do_teardown_appcontext
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,54910,55779
Arguments: ['self', 'exc: BaseException | None = _sentinel', '# type: ignore[assignment]']
Code: def app_context(self) -> AppContext:
        """Create an :class:`~flask.ctx.AppContext`. Use as a ``with``
        block to push the context, which will make :data:`current_app`
        point at this application.

        An application context is automatically pushed by
        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`
        when handling a request, and when running a CLI command. Use
        this to manually create a context outside of these situations.

        ::

            with app.app_context():
                init_db()

        See :doc:`/appcontext`.

        .. versionadded:: 0.9
        """
        return AppContext(self)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: app_context
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,55785,56450
Arguments: ['self']
Code: def request_context(self, environ: WSGIEnvironment) -> RequestContext:
        """Create a :class:`~flask.ctx.RequestContext` representing a
        WSGI environment. Use a ``with`` block to push the context,
        which will make :data:`request` point at this request.

        See :doc:`/reqcontext`.

        Typically you should not call this from your own code. A request
        context is automatically pushed by the :meth:`wsgi_app` when
        handling a request. Use :meth:`test_request_context` to create
        an environment and context instead of this method.

        :param environ: a WSGI environment
        """
        return RequestContext(self, environ)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: request_context
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,56456,57134
Arguments: ['self', 'environ: WSGIEnvironment']
Code: def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:
        """Create a :class:`~flask.ctx.RequestContext` for a WSGI
        environment created from the given values. This is mostly useful
        during testing, where you may want to run a function that uses
        request data without dispatching a full request.

        See :doc:`/reqcontext`.

        Use a ``with`` block to push the context, which will make
        :data:`request` point at the request for the created
        environment. ::

            with app.test_request_context(...):
                generate_report()

        When using the shell, it may be easier to push and pop the
        context manually to avoid indentation. ::

            ctx = app.test_request_context(...)
            ctx.push()
            ...
            ctx.pop()

        Takes the same arguments as Werkzeug's
        :class:`~werkzeug.test.EnvironBuilder`, with some defaults from
        the application. See the linked Werkzeug docs for most of the
        available arguments. Flask-specific behavior is listed here.

        :param path: URL path being requested.
        :param base_url: Base URL where the app is being served, which
            ``path`` is relative to. If not given, built from
            :data:`PREFERRED_URL_SCHEME`, ``subdomain``,
            :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.
        :param subdomain: Subdomain name to append to
            :data:`SERVER_NAME`.
        :param url_scheme: Scheme to use instead of
            :data:`PREFERRED_URL_SCHEME`.
        :param data: The request body, either as a string or a dict of
            form keys and values.
        :param json: If given, this is serialized as JSON and passed as
            ``data``. Also defaults ``content_type`` to
            ``application/json``.
        :param args: other positional arguments passed to
            :class:`~werkzeug.test.EnvironBuilder`.
        :param kwargs: other keyword arguments passed to
            :class:`~werkzeug.test.EnvironBuilder`.
        """
        from .testing import EnvironBuilder

        builder = EnvironBuilder(self, *args, **kwargs)

        try:
            return self.request_context(builder.get_environ())
        finally:
            builder.close()
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_request_context
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,57140,59445
Arguments: ['self', '*args: t.Any', '**kwargs: t.Any']
Code: def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.

        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
                response = self.handle_exception(e)
            except:  # noqa: B001
                error = sys.exc_info()[1]
                raise
            return response(environ, start_response)
        finally:
            if "werkzeug.debug.preserve_context" in environ:
                environ["werkzeug.debug.preserve_context"](_cv_app.get())
                environ["werkzeug.debug.preserve_context"](_cv_request.get())

            if error is not None and self.should_ignore_error(error):
                error = None

            ctx.pop(error)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: wsgi_app
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,59451,61364
Arguments: ['self', 'environ: WSGIEnvironment', 'start_response: StartResponse']
Code: def __call__(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The WSGI server calls the Flask application object as the
        WSGI application. This calls :meth:`wsgi_app`, which can be
        wrapped to apply middleware.
        """
        return self.wsgi_app(environ, start_response)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __call__
Type: function
Parent Type: Flask
Location: /home/yuesheng/flask/src/flask/app.py,61370,61724
Arguments: ['self', 'environ: WSGIEnvironment', 'start_response: StartResponse']
Code: class Flask(App):
    """The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the :file:`__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)

    .. admonition:: About the First Parameter

        The idea of the first parameter is to give Flask an idea of what
        belongs to your application.  This name is used to find resources
        on the filesystem, can be used by extensions to improve debugging
        information and a lot more.

        So it's important what you provide there.  If you are using a single
        module, `__name__` is always the correct value.  If you however are
        using a package, it's usually recommended to hardcode the name of
        your package there.

        For example if your application is defined in :file:`yourapplication/app.py`
        you should create it with one of the two versions below::

            app = Flask('yourapplication')
            app = Flask(__name__.split('.')[0])

        Why is that?  The application will work even with `__name__`, thanks
        to how resources are looked up.  However it will make debugging more
        painful.  Certain extensions can make assumptions based on the
        import name of your application.  For example the Flask-SQLAlchemy
        extension will look for the code in your application that triggered
        an SQL query in debug mode.  If the import name is not properly set
        up, that debugging information is lost.  (For example it would only
        pick up SQL queries in `yourapplication.app` and not
        `yourapplication.views.frontend`)

    .. versionadded:: 0.7
       The `static_url_path`, `static_folder`, and `template_folder`
       parameters were added.

    .. versionadded:: 0.8
       The `instance_path` and `instance_relative_config` parameters were
       added.

    .. versionadded:: 0.11
       The `root_path` parameter was added.

    .. versionadded:: 1.0
       The ``host_matching`` and ``static_host`` parameters were added.

    .. versionadded:: 1.0
       The ``subdomain_matching`` parameter was added. Subdomain
       matching needs to be enabled manually now. Setting
       :data:`SERVER_NAME` does not implicitly enable it.

    :param import_name: the name of the application package
    :param static_url_path: can be used to specify a different path for the
                            static files on the web.  Defaults to the name
                            of the `static_folder` folder.
    :param static_folder: The folder with static files that is served at
        ``static_url_path``. Relative to the application ``root_path``
        or an absolute path. Defaults to ``'static'``.
    :param static_host: the host to use when adding the static route.
        Defaults to None. Required when using ``host_matching=True``
        with a ``static_folder`` configured.
    :param host_matching: set ``url_map.host_matching`` attribute.
        Defaults to False.
    :param subdomain_matching: consider the subdomain relative to
        :data:`SERVER_NAME` when matching routes. Defaults to False.
    :param template_folder: the folder that contains the templates that should
                            be used by the application.  Defaults to
                            ``'templates'`` folder in the root path of the
                            application.
    :param instance_path: An alternative instance path for the application.
                          By default the folder ``'instance'`` next to the
                          package or module is assumed to be the instance
                          path.
    :param instance_relative_config: if set to ``True`` relative filenames
                                     for loading the config are assumed to
                                     be relative to the instance path instead
                                     of the application root.
    :param root_path: The path to the root of the application files.
        This should only be set manually when it can't be detected
        automatically, such as for namespace packages.
    """

    default_config = ImmutableDict(
        {
            "DEBUG": None,
            "TESTING": False,
            "PROPAGATE_EXCEPTIONS": None,
            "SECRET_KEY": None,
            "SECRET_KEY_FALLBACKS": None,
            "PERMANENT_SESSION_LIFETIME": timedelta(days=31),
            "USE_X_SENDFILE": False,
            "TRUSTED_HOSTS": None,
            "SERVER_NAME": None,
            "APPLICATION_ROOT": "/",
            "SESSION_COOKIE_NAME": "session",
            "SESSION_COOKIE_DOMAIN": None,
            "SESSION_COOKIE_PATH": None,
            "SESSION_COOKIE_HTTPONLY": True,
            "SESSION_COOKIE_SECURE": False,
            "SESSION_COOKIE_PARTITIONED": False,
            "SESSION_COOKIE_SAMESITE": None,
            "SESSION_REFRESH_EACH_REQUEST": True,
            "MAX_CONTENT_LENGTH": None,
            "MAX_FORM_MEMORY_SIZE": 500_000,
            "MAX_FORM_PARTS": 1_000,
            "SEND_FILE_MAX_AGE_DEFAULT": None,
            "TRAP_BAD_REQUEST_ERRORS": None,
            "TRAP_HTTP_EXCEPTIONS": False,
            "EXPLAIN_TEMPLATE_LOADING": False,
            "PREFERRED_URL_SCHEME": "http",
            "TEMPLATES_AUTO_RELOAD": None,
            "MAX_COOKIE_SIZE": 4093,
            "PROVIDE_AUTOMATIC_OPTIONS": True,
        }
    )

    #: The class that is used for request objects.  See :class:`~flask.Request`
    #: for more information.
    request_class: type[Request] = Request

    #: The class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class: type[Response] = Response

    #: the session interface to use.  By default an instance of
    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.
    #:
    #: .. versionadded:: 0.8
    session_interface: SessionInterface = SecureCookieSessionInterface()

    # Code for function: Flask.__init__(self, import_name: str, static_url_path: str | None = None, static_folder: str | os.PathLike[str] | None = "static", static_host: str | None = None, host_matching: bool = False, subdomain_matching: bool = False, template_folder: str | os.PathLike[str] | None = "templates", instance_path: str | None = None, instance_relative_config: bool = False, root_path: str | None = None, )
# Code for function: Flask.get_send_file_max_age(self, filename: str | None)
# Code for function: Flask.send_static_file(self, filename: str)
# Code for function: Flask.open_resource(self, resource: str, mode: str = "rb", encoding: str | None = None)
# Code for function: Flask.open_instance_resource(self, resource: str, mode: str = "rb", encoding: str | None = "utf-8")
# Code for function: Flask.create_jinja_environment(self)
# Code for function: Flask.create_url_adapter(self, request: Request | None)
# Code for function: Flask.raise_routing_exception(self, request: Request)
# Code for function: Flask.update_template_context(self, context: dict[str, t.Any])
# Code for function: Flask.make_shell_context(self)
# Code for function: Flask.run(self, host: str | None = None, port: int | None = None, debug: bool | None = None, load_dotenv: bool = True, **options: t.Any, )
# Code for function: Flask.test_client(self, use_cookies: bool = True, **kwargs: t.Any)
# Code for function: Flask.test_cli_runner(self, **kwargs: t.Any)
# Code for function: Flask.handle_http_exception(self, e: HTTPException)
# Code for function: Flask.handle_user_exception(self, e: Exception)
# Code for function: Flask.handle_exception(self, e: Exception)
# Code for function: Flask.log_exception(self, exc_info: (tuple[type, BaseException, TracebackType] | tuple[None, None, None]), )
# Code for function: Flask.dispatch_request(self)
# Code for function: Flask.full_dispatch_request(self)
# Code for function: Flask.finalize_request(self, rv: ft.ResponseReturnValue | HTTPException, from_error_handler: bool = False, )
# Code for function: Flask.make_default_options_response(self)
# Code for function: Flask.ensure_sync(self, func: t.Callable[..., t.Any])
# Code for function: Flask.async_to_sync(self, func: t.Callable[..., t.Coroutine[t.Any, t.Any, t.Any]])
# Code for function: Flask.url_for(self, /, endpoint: str, *, _anchor: str | None = None, _method: str | None = None, _scheme: str | None = None, _external: bool | None = None, **values: t.Any, )
# Code for function: Flask.make_response(self, rv: ft.ResponseReturnValue)
# Code for function: Flask.preprocess_request(self)
# Code for function: Flask.process_response(self, response: Response)
# Code for function: Flask.do_teardown_request(self, exc: BaseException | None = _sentinel, # type: ignore[assignment])
# Code for function: Flask.do_teardown_appcontext(self, exc: BaseException | None = _sentinel, # type: ignore[assignment])
# Code for function: Flask.app_context(self)
# Code for function: Flask.request_context(self, environ: WSGIEnvironment)
# Code for function: Flask.test_request_context(self, *args: t.Any, **kwargs: t.Any)
# Code for function: Flask.wsgi_app(self, environ: WSGIEnvironment, start_response: StartResponse)
# Code for function: Flask.__call__(self, environ: WSGIEnvironment, start_response: StartResponse)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: EnvironBuilder
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/testing.py,642,1667
Arguments: ['self', 'app: Flask', 'path: str = "/"', 'base_url: str | None = None', 'subdomain: str | None = None', 'url_scheme: str | None = None', '*args: t.Any', '**kwargs: t.Any', '']
Code: class EnvironBuilder(werkzeug.test.EnvironBuilder):
    """An :class:`~werkzeug.test.EnvironBuilder`, that takes defaults from the
    application.

    :param app: The Flask application to configure the environment from.
    :param path: URL path being requested.
    :param base_url: Base URL where the app is being served, which
        ``path`` is relative to. If not given, built from
        :data:`PREFERRED_URL_SCHEME`, ``subdomain``,
        :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.
    :param subdomain: Subdomain name to append to :data:`SERVER_NAME`.
    :param url_scheme: Scheme to use instead of
        :data:`PREFERRED_URL_SCHEME`.
    :param json: If given, this is serialized as JSON and passed as
        ``data``. Also defaults ``content_type`` to
        ``application/json``.
    :param args: other positional arguments passed to
        :class:`~werkzeug.test.EnvironBuilder`.
    :param kwargs: other keyword arguments passed to
        :class:`~werkzeug.test.EnvironBuilder`.
    """

    # Code for function: EnvironBuilder.__init__(self, app: Flask, path: str = "/", base_url: str | None = None, subdomain: str | None = None, url_scheme: str | None = None, *args: t.Any, **kwargs: t.Any, )
# Code for function: EnvironBuilder.json_dumps(self, obj: t.Any, **kwargs: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: EnvironBuilder
Location: /home/yuesheng/flask/src/flask/testing.py,1667,2842
Arguments: ['self', 'app: Flask', 'path: str = "/"', 'base_url: str | None = None', 'subdomain: str | None = None', 'url_scheme: str | None = None', '*args: t.Any', '**kwargs: t.Any', '']
Code: def __init__(
        self,
        app: Flask,
        path: str = "/",
        base_url: str | None = None,
        subdomain: str | None = None,
        url_scheme: str | None = None,
        *args: t.Any,
        **kwargs: t.Any,
    ) -> None:
        assert not (base_url or subdomain or url_scheme) or (
            base_url is not None
        ) != bool(
            subdomain or url_scheme
        ), 'Cannot pass "subdomain" or "url_scheme" with "base_url".'

        if base_url is None:
            http_host = app.config.get("SERVER_NAME") or "localhost"
            app_root = app.config["APPLICATION_ROOT"]

            if subdomain:
                http_host = f"{subdomain}.{http_host}"

            if url_scheme is None:
                url_scheme = app.config["PREFERRED_URL_SCHEME"]

            url = urlsplit(path)
            base_url = (
                f"{url.scheme or url_scheme}://{url.netloc or http_host}"
                f"/{app_root.lstrip('/')}"
            )
            path = url.path

            if url.query:
                path = f"{path}?{url.query}"

        self.app = app
        super().__init__(path, base_url, *args, **kwargs)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: json_dumps
Type: function
Parent Type: EnvironBuilder
Location: /home/yuesheng/flask/src/flask/testing.py,2848,3165
Arguments: ['self', 'obj: t.Any', '**kwargs: t.Any']
Code: def json_dumps(self, obj: t.Any, **kwargs: t.Any) -> str:  # type: ignore
        """Serialize ``obj`` to a JSON-formatted string.

        The serialization will be configured according to the config associated
        with this EnvironBuilder's ``app``.
        """
        return self.app.json.dumps(obj, **kwargs)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _get_werkzeug_version
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/testing.py,3193,3385
Arguments: ['']
Code: def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:
        super().__init__(*args, **kwargs)
        self.preserve_context = False
        self._new_contexts: list[t.ContextManager[t.Any]] = []
        self._context_stack = ExitStack()
        self.environ_base = {
            "REMOTE_ADDR": "127.0.0.1",
            "HTTP_USER_AGENT": f"Werkzeug/{_get_werkzeug_version()}",
        }
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: FlaskClient
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/testing.py,3388,3991
Arguments: ['self', '*args: t.Any', '**kwargs: t.Any']
Code: def __init__(self, app: Flask, **kwargs: t.Any) -> None:
        self.app = app
        super().__init__(**kwargs)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: FlaskClient
Location: /home/yuesheng/flask/src/flask/testing.py,3991,4384
Arguments: ['self', '*args: t.Any', '**kwargs: t.Any']
Code: def _copy_environ(self, other: WSGIEnvironment) -> WSGIEnvironment:
        out = {**self.environ_base, **other}

        if self.preserve_context:
            out["werkzeug.debug.preserve_context"] = self._new_contexts.append

        return out
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _copy_environ
Type: function
Parent Type: FlaskClient
Location: /home/yuesheng/flask/src/flask/testing.py,6080,6326
Arguments: ['self', 'other: WSGIEnvironment']
Code: def _request_from_builder_args(
        self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any]
    ) -> BaseRequest:
        kwargs["environ_base"] = self._copy_environ(kwargs.get("environ_base", {}))
        builder = EnvironBuilder(self.application, *args, **kwargs)

        try:
            return builder.get_request()
        finally:
            builder.close()
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _request_from_builder_args
Type: function
Parent Type: FlaskClient
Location: /home/yuesheng/flask/src/flask/testing.py,6332,6701
Arguments: ['self', 'args: tuple[t.Any', '...]', 'kwargs: dict[str', 't.Any]']
Code: def open(
        self,
        *args: t.Any,
        buffered: bool = False,
        follow_redirects: bool = False,
        **kwargs: t.Any,
    ) -> TestResponse:
        if args and isinstance(
            args[0], (werkzeug.test.EnvironBuilder, dict, BaseRequest)
        ):
            if isinstance(args[0], werkzeug.test.EnvironBuilder):
                builder = copy(args[0])
                builder.environ_base = self._copy_environ(builder.environ_base or {})  # type: ignore[arg-type]
                request = builder.get_request()
            elif isinstance(args[0], dict):
                request = EnvironBuilder.from_environ(
                    args[0], app=self.application, environ_base=self._copy_environ({})
                ).get_request()
            else:
                # isinstance(args[0], BaseRequest)
                request = copy(args[0])
                request.environ = self._copy_environ(request.environ)
        else:
            # request is None
            request = self._request_from_builder_args(args, kwargs)

        # Pop any previously preserved contexts. This prevents contexts
        # from being preserved across redirects or multiple requests
        # within a single block.
        self._context_stack.close()

        response = super().open(
            request,
            buffered=buffered,
            follow_redirects=follow_redirects,
        )
        response.json_module = self.application.json  # type: ignore[assignment]

        # Re-push contexts that were preserved during the request.
        while self._new_contexts:
            cm = self._new_contexts.pop()
            self._context_stack.enter_context(cm)

        return response
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: open
Type: function
Parent Type: FlaskClient
Location: /home/yuesheng/flask/src/flask/testing.py,6707,8415
Arguments: ['self', '*args: t.Any', 'buffered: bool = False', 'follow_redirects: bool = False', '**kwargs: t.Any', '']
Code: def __enter__(self) -> FlaskClient:
        if self.preserve_context:
            raise RuntimeError("Cannot nest client invocations")
        self.preserve_context = True
        return self
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __enter__
Type: function
Parent Type: FlaskClient
Location: /home/yuesheng/flask/src/flask/testing.py,8421,8612
Arguments: ['self']
Code: def __exit__(
        self,
        exc_type: type | None,
        exc_value: BaseException | None,
        tb: TracebackType | None,
    ) -> None:
        self.preserve_context = False
        self._context_stack.close()
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __exit__
Type: function
Parent Type: FlaskClient
Location: /home/yuesheng/flask/src/flask/testing.py,8618,8840
Arguments: ['self', 'exc_type: type | None', 'exc_value: BaseException | None', 'tb: TracebackType | None', '']
Code: class FlaskClient(Client):
    """Works like a regular Werkzeug test client but has knowledge about
    Flask's contexts to defer the cleanup of the request context until
    the end of a ``with`` block. For general information about how to
    use this class refer to :class:`werkzeug.test.Client`.

    .. versionchanged:: 0.12
       `app.test_client()` includes preset default environment, which can be
       set after instantiation of the `app.test_client()` object in
       `client.environ_base`.

    Basic usage is outlined in the :doc:`/testing` chapter.
    """

    application: Flask

    # Code for function: FlaskClient.__init__(self, *args: t.Any, **kwargs: t.Any)
# Code for function: FlaskClient._copy_environ(self, other: WSGIEnvironment)
# Code for function: FlaskClient._request_from_builder_args(self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any])
# Code for function: FlaskClient.open(self, *args: t.Any, buffered: bool = False, follow_redirects: bool = False, **kwargs: t.Any, )
# Code for function: FlaskClient.__enter__(self)
# Code for function: FlaskClient.__exit__(self, exc_type: type | None, exc_value: BaseException | None, tb: TracebackType | None, )

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: FlaskCliRunner
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/testing.py,8843,9066
Arguments: ['self', 'app: Flask', '**kwargs: t.Any']
Code: // Code for Global Scope
from __future__ import annotations
import importlib.metadata
import typing as t
from contextlib import contextmanager
from contextlib import ExitStack
from copy import copy
from types import TracebackType
from urllib.parse import urlsplit
import werkzeug.test
from click.testing import CliRunner
from click.testing import Result
from werkzeug.test import Client
from werkzeug.wrappers import Request as BaseRequest
from .cli import ScriptInfo
from .sessions import SessionMixin
if t.TYPE_CHECKING:  # pragma: no cover
    from _typeshed.wsgi import WSGIEnvironment
    from werkzeug.test import TestResponse

    from .app import Flask
# Code for class: EnvironBuilder(self, app: Flask, path: str = "/", base_url: str | None = None, subdomain: str | None = None, url_scheme: str | None = None, *args: t.Any, **kwargs: t.Any, )
# Code for function: EnvironBuilder.__init__(self, app: Flask, path: str = "/", base_url: str | None = None, subdomain: str | None = None, url_scheme: str | None = None, *args: t.Any, **kwargs: t.Any, )
# Code for function: EnvironBuilder.json_dumps(self, obj: t.Any, **kwargs: t.Any)
_werkzeug_version = ""
# Code for function: _get_werkzeug_version()
# Code for class: FlaskClient(self, *args: t.Any, **kwargs: t.Any)
# Code for function: FlaskClient.__init__(self, *args: t.Any, **kwargs: t.Any)
# Code for function: FlaskClient._copy_environ(self, other: WSGIEnvironment)
# Code for function: FlaskClient._request_from_builder_args(self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any])
# Code for function: FlaskClient.open(self, *args: t.Any, buffered: bool = False, follow_redirects: bool = False, **kwargs: t.Any, )
# Code for function: FlaskClient.__enter__(self)
# Code for function: FlaskClient.__exit__(self, exc_type: type | None, exc_value: BaseException | None, tb: TracebackType | None, )
# Code for class: FlaskCliRunner(self, app: Flask, **kwargs: t.Any)
# Code for function: FlaskCliRunner.__init__(self, app: Flask, **kwargs: t.Any)
# Code for function: FlaskCliRunner.invoke(# type: ignore
        self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: FlaskCliRunner
Location: /home/yuesheng/flask/src/flask/testing.py,9066,9180
Arguments: ['self', 'app: Flask', '**kwargs: t.Any']
Code: def invoke(  # type: ignore
        self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any
    ) -> Result:
        """Invokes a CLI command in an isolated environment. See
        :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for
        full method documentation. See :ref:`testing-cli` for examples.

        If the ``obj`` argument is not given, passes an instance of
        :class:`~flask.cli.ScriptInfo` that knows how to load the Flask
        app being tested.

        :param cli: Command object to invoke. Default is the app's
            :attr:`~flask.app.Flask.cli` group.
        :param args: List of strings to invoke the command with.

        :return: a :class:`~click.testing.Result` object.
        """
        if cli is None:
            cli = self.app.cli

        if "obj" not in kwargs:
            kwargs["obj"] = ScriptInfo(create_app=lambda: self.app)

        return super().invoke(cli, args, **kwargs)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: invoke
Type: function
Parent Type: FlaskCliRunner
Location: /home/yuesheng/flask/src/flask/testing.py,9186,10133
Arguments: ['# type: ignore\n        self', 'cli: t.Any = None', 'args: t.Any = None', '**kwargs: t.Any']
Code: class FlaskCliRunner(CliRunner):
    """A :class:`~click.testing.CliRunner` for testing a Flask app's
    CLI commands. Typically created using
    :meth:`~flask.Flask.test_cli_runner`. See :ref:`testing-cli`.
    """

    # Code for function: FlaskCliRunner.__init__(self, app: Flask, **kwargs: t.Any)
# Code for function: FlaskCliRunner.invoke(# type: ignore
        self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/src/flask/typing.py,0,3165
Arguments: []
Code: // Code for Global Scope
from __future__ import annotations
import typing as t
if t.TYPE_CHECKING:  # pragma: no cover
    from _typeshed.wsgi import WSGIApplication  # noqa: F401
    from werkzeug.datastructures import Headers  # noqa: F401
    from werkzeug.sansio.response import Response  # noqa: F401
# The possible types that are directly convertible or are a Response object.
ResponseValue = t.Union[
    "Response",
    str,
    bytes,
    list[t.Any],
    # Only dict is actually accepted, but Mapping allows for TypedDict.
    t.Mapping[str, t.Any],
    t.Iterator[str],
    t.Iterator[bytes],
]
# the possible types for an individual HTTP header
# This should be a Union, but mypy doesn't pass unless it's a TypeVar.
HeaderValue = t.Union[str, list[str], tuple[str, ...]]
# the possible types for HTTP headers
HeadersValue = t.Union[
    "Headers",
    t.Mapping[str, HeaderValue],
    t.Sequence[tuple[str, HeaderValue]],
]
# The possible types returned by a route function.
ResponseReturnValue = t.Union[
    ResponseValue,
    tuple[ResponseValue, HeadersValue],
    tuple[ResponseValue, int],
    tuple[ResponseValue, int, HeadersValue],
    "WSGIApplication",
]
# Allow any subclass of werkzeug.Response, such as the one from Flask,
# as a callback argument. Using werkzeug.Response directly makes a
# callback annotated with flask.Response fail type checking.
ResponseClass = t.TypeVar("ResponseClass", bound="Response")
AppOrBlueprintKey = t.Optional[str]
# The App key is None, whereas blueprints are named
AfterRequestCallable = t.Union[
    t.Callable[[ResponseClass], ResponseClass],
    t.Callable[[ResponseClass], t.Awaitable[ResponseClass]],
]
BeforeFirstRequestCallable = t.Union[
    t.Callable[[], None], t.Callable[[], t.Awaitable[None]]
]
BeforeRequestCallable = t.Union[
    t.Callable[[], t.Optional[ResponseReturnValue]],
    t.Callable[[], t.Awaitable[t.Optional[ResponseReturnValue]]],
]
ShellContextProcessorCallable = t.Callable[[], dict[str, t.Any]]
TeardownCallable = t.Union[
    t.Callable[[t.Optional[BaseException]], None],
    t.Callable[[t.Optional[BaseException]], t.Awaitable[None]],
]
TemplateContextProcessorCallable = t.Union[
    t.Callable[[], dict[str, t.Any]],
    t.Callable[[], t.Awaitable[dict[str, t.Any]]],
]
TemplateFilterCallable = t.Callable[..., t.Any]
TemplateGlobalCallable = t.Callable[..., t.Any]
TemplateTestCallable = t.Callable[..., bool]
URLDefaultCallable = t.Callable[[str, dict[str, t.Any]], None]
URLValuePreprocessorCallable = t.Callable[
    [t.Optional[str], t.Optional[dict[str, t.Any]]], None
]
# This should take Exception, but that either breaks typing the argument
# with a specific exception, or decorating multiple times with different
# exceptions (and using a union type on the argument).
# https://github.com/pallets/flask/issues/4095
# https://github.com/pallets/flask/issues/4295
# https://github.com/pallets/flask/issues/4297
ErrorHandlerCallable = t.Union[
    t.Callable[[t.Any], ResponseReturnValue],
    t.Callable[[t.Any], t.Awaitable[ResponseReturnValue]],
]
RouteCallable = t.Union[
    t.Callable[..., ResponseReturnValue],
    t.Callable[..., t.Awaitable[ResponseReturnValue]],
]

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/src/flask/wrappers.py,0,9405
Arguments: []
Code: // Code for Global Scope
from __future__ import annotations
import typing as t
from werkzeug.exceptions import BadRequest
from werkzeug.exceptions import HTTPException
from werkzeug.wrappers import Request as RequestBase
from werkzeug.wrappers import Response as ResponseBase
from . import json
from .globals import current_app
from .helpers import _split_blueprint_path
if t.TYPE_CHECKING:  # pragma: no cover
    from werkzeug.routing import Rule
# Code for class: Request()
# Code for function: Request._load_form_data(self)
# Code for function: Request.on_json_loading_failed(self, e: ValueError | None)
# Code for class: Response()

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Request
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/wrappers.py,430,7328
Arguments: []
Code: class Request(RequestBase):
    """The request object used by default in Flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.

    The request object is a :class:`~werkzeug.wrappers.Request` subclass and
    provides all of the attributes Werkzeug defines plus a few Flask
    specific ones.
    """

    json_module: t.Any = json

    #: The internal URL rule that matched the request.  This can be
    #: useful to inspect which methods are allowed for the URL from
    #: a before/after handler (``request.url_rule.methods``) etc.
    #: Though if the request's method was invalid for the URL rule,
    #: the valid list is available in ``routing_exception.valid_methods``
    #: instead (an attribute of the Werkzeug exception
    #: :exc:`~werkzeug.exceptions.MethodNotAllowed`)
    #: because the request was never internally bound.
    #:
    #: .. versionadded:: 0.6
    url_rule: Rule | None = None

    #: A dict of view arguments that matched the request.  If an exception
    #: happened when matching, this will be ``None``.
    view_args: dict[str, t.Any] | None = None

    #: If matching the URL failed, this is the exception that will be
    #: raised / was raised as part of the request handling.  This is
    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or
    #: something similar.
    routing_exception: HTTPException | None = None

    _max_content_length: int | None = None
    _max_form_memory_size: int | None = None
    _max_form_parts: int | None = None

    @property
    def max_content_length(self) -> int | None:
        """The maximum number of bytes that will be read during this request. If
        this limit is exceeded, a 413 :exc:`~werkzeug.exceptions.RequestEntityTooLarge`
        error is raised. If it is set to ``None``, no limit is enforced at the
        Flask application level. However, if it is ``None`` and the request has
        no ``Content-Length`` header and the WSGI server does not indicate that
        it terminates the stream, then no data is read to avoid an infinite
        stream.

        Each request defaults to the :data:`MAX_CONTENT_LENGTH` config, which
        defaults to ``None``. It can be set on a specific ``request`` to apply
        the limit to that specific view. This should be set appropriately based
        on an application's or view's specific needs.

        .. versionchanged:: 3.1
            This can be set per-request.

        .. versionchanged:: 0.6
            This is configurable through Flask config.
        """
        if self._max_content_length is not None:
            return self._max_content_length

        if not current_app:
            return super().max_content_length

        return current_app.config["MAX_CONTENT_LENGTH"]  # type: ignore[no-any-return]

    @max_content_length.setter
    def max_content_length(self, value: int | None) -> None:
        self._max_content_length = value

    @property
    def max_form_memory_size(self) -> int | None:
        """The maximum size in bytes any non-file form field may be in a
        ``multipart/form-data`` body. If this limit is exceeded, a 413
        :exc:`~werkzeug.exceptions.RequestEntityTooLarge` error is raised. If it
        is set to ``None``, no limit is enforced at the Flask application level.

        Each request defaults to the :data:`MAX_FORM_MEMORY_SIZE` config, which
        defaults to ``500_000``. It can be set on a specific ``request`` to
        apply the limit to that specific view. This should be set appropriately
        based on an application's or view's specific needs.

        .. versionchanged:: 3.1
            This is configurable through Flask config.
        """
        if self._max_form_memory_size is not None:
            return self._max_form_memory_size

        if not current_app:
            return super().max_form_memory_size

        return current_app.config["MAX_FORM_MEMORY_SIZE"]  # type: ignore[no-any-return]

    @max_form_memory_size.setter
    def max_form_memory_size(self, value: int | None) -> None:
        self._max_form_memory_size = value

    @property  # type: ignore[override]
    def max_form_parts(self) -> int | None:
        """The maximum number of fields that may be present in a
        ``multipart/form-data`` body. If this limit is exceeded, a 413
        :exc:`~werkzeug.exceptions.RequestEntityTooLarge` error is raised. If it
        is set to ``None``, no limit is enforced at the Flask application level.

        Each request defaults to the :data:`MAX_FORM_PARTS` config, which
        defaults to ``1_000``. It can be set on a specific ``request`` to apply
        the limit to that specific view. This should be set appropriately based
        on an application's or view's specific needs.

        .. versionchanged:: 3.1
            This is configurable through Flask config.
        """
        if self._max_form_parts is not None:
            return self._max_form_parts

        if not current_app:
            return super().max_form_parts

        return current_app.config["MAX_FORM_PARTS"]  # type: ignore[no-any-return]

    @max_form_parts.setter
    def max_form_parts(self, value: int | None) -> None:
        self._max_form_parts = value

    @property
    def endpoint(self) -> str | None:
        """The endpoint that matched the request URL.

        This will be ``None`` if matching failed or has not been
        performed yet.

        This in combination with :attr:`view_args` can be used to
        reconstruct the same URL or a modified URL.
        """
        if self.url_rule is not None:
            return self.url_rule.endpoint  # type: ignore[no-any-return]

        return None

    @property
    def blueprint(self) -> str | None:
        """The registered name of the current blueprint.

        This will be ``None`` if the endpoint is not part of a
        blueprint, or if URL matching failed or has not been performed
        yet.

        This does not necessarily match the name the blueprint was
        created with. It may have been nested, or registered with a
        different name.
        """
        endpoint = self.endpoint

        if endpoint is not None and "." in endpoint:
            return endpoint.rpartition(".")[0]

        return None

    @property
    def blueprints(self) -> list[str]:
        """The registered names of the current blueprint upwards through
        parent blueprints.

        This will be an empty list if there is no current blueprint, or
        if URL matching failed.

        .. versionadded:: 2.0.1
        """
        name = self.blueprint

        if name is None:
            return []

        return _split_blueprint_path(name)

    # Code for function: Request._load_form_data(self)
# Code for function: Request.on_json_loading_failed(self, e: ValueError | None)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _load_form_data
Type: function
Parent Type: Request
Location: /home/yuesheng/flask/src/flask/wrappers.py,7328,7824
Arguments: ['self']
Code: def _load_form_data(self) -> None:
        super()._load_form_data()

        # In debug mode we're replacing the files multidict with an ad-hoc
        # subclass that raises a different error for key errors.
        if (
            current_app
            and current_app.debug
            and self.mimetype != "multipart/form-data"
            and not self.files
        ):
            from .debughelpers import attach_enctype_error_multidict

            attach_enctype_error_multidict(self)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: on_json_loading_failed
Type: function
Parent Type: Request
Location: /home/yuesheng/flask/src/flask/wrappers.py,7830,8107
Arguments: ['self', 'e: ValueError | None']
Code: def on_json_loading_failed(self, e: ValueError | None) -> t.Any:
        try:
            return super().on_json_loading_failed(e)
        except BadRequest as ebr:
            if current_app and current_app.debug:
                raise

            raise BadRequest() from ebr
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Response
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/wrappers.py,8110,9405
Arguments: []
Code: class Response(ResponseBase):
    """The response object that is used by default in Flask.  Works like the
    response object from Werkzeug but is set to have an HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.response_class` to your subclass.

    .. versionchanged:: 1.0
        JSON support is added to the response, like the request. This is useful
        when testing to get the test client response data as JSON.

    .. versionchanged:: 1.0

        Added :attr:`max_cookie_size`.
    """

    default_mimetype: str | None = "text/html"

    json_module = json

    autocorrect_location_header = False

    @property
    def max_cookie_size(self) -> int:  # type: ignore
        """Read-only view of the :data:`MAX_COOKIE_SIZE` config key.

        See :attr:`~werkzeug.wrappers.Response.max_cookie_size` in
        Werkzeug's docs.
        """
        if current_app:
            return current_app.config["MAX_COOKIE_SIZE"]  # type: ignore[no-any-return]

        # return Werkzeug's default when not in an app context
        return super().max_cookie_size
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: UnexpectedUnicodeError
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/debughelpers.py,334,510
Arguments: []
Code: class UnexpectedUnicodeError(AssertionError, UnicodeError):
    """Raised in places where we want some better error reporting for
    unexpected unicode or binary data.
    """
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: DebugFilesKeyError
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/debughelpers.py,513,730
Arguments: ['self', 'request: Request', 'key: str']
Code: class DebugFilesKeyError(KeyError, AssertionError):
    """Raised from request.files during debugging.  The idea is that it can
    provide a better error message than just a generic KeyError/BadRequest.
    """

    # Code for function: DebugFilesKeyError.__init__(self, request: Request, key: str)
# Code for function: DebugFilesKeyError.__str__(self)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: DebugFilesKeyError
Location: /home/yuesheng/flask/src/flask/debughelpers.py,730,1537
Arguments: ['self', 'request: Request', 'key: str']
Code: def __init__(self, request: Request, key: str) -> None:
        form_matches = request.form.getlist(key)
        buf = [
            f"You tried to access the file {key!r} in the request.files"
            " dictionary but it does not exist. The mimetype for the"
            f" request is {request.mimetype!r} instead of"
            " 'multipart/form-data' which means that no file contents"
            " were transmitted. To fix this error you should provide"
            ' enctype="multipart/form-data" in your form.'
        ]
        if form_matches:
            names = ", ".join(repr(x) for x in form_matches)
            buf.append(
                "\n\nThe browser instead transmitted some file names. "
                f"This was submitted: {names}"
            )
        self.msg = "".join(buf)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __str__
Type: function
Parent Type: DebugFilesKeyError
Location: /home/yuesheng/flask/src/flask/debughelpers.py,1543,1592
Arguments: ['self']
Code: def __str__(self) -> str:
        return self.msg
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: FormDataRoutingRedirect
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/debughelpers.py,1595,1879
Arguments: ['self', 'request: Request']
Code: class FormDataRoutingRedirect(AssertionError):
    """This exception is raised in debug mode if a routing redirect
    would cause the browser to drop the method or body. This happens
    when method is not GET, HEAD or OPTIONS and the status code is not
    307 or 308.
    """

    # Code for function: FormDataRoutingRedirect.__init__(self, request: Request)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: FormDataRoutingRedirect
Location: /home/yuesheng/flask/src/flask/debughelpers.py,1879,2764
Arguments: ['self', 'request: Request']
Code: def __init__(self, request: Request) -> None:
        exc = request.routing_exception
        assert isinstance(exc, RequestRedirect)
        buf = [
            f"A request was sent to '{request.url}', but routing issued"
            f" a redirect to the canonical URL '{exc.new_url}'."
        ]

        if f"{request.base_url}/" == exc.new_url.partition("?")[0]:
            buf.append(
                " The URL was defined with a trailing slash. Flask"
                " will redirect to the URL with a trailing slash if it"
                " was accessed without one."
            )

        buf.append(
            " Send requests to the canonical URL, or use 307 or 308 for"
            " routing redirects. Otherwise, browsers will drop form"
            " data.\n\n"
            "This exception is only raised in debug mode."
        )
        super().__init__("".join(buf))
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: attach_enctype_error_multidict
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/debughelpers.py,2767,3584
Arguments: ['request: Request', 'self', 'key: str']
Code: // Code for Global Scope
from __future__ import annotations
import typing as t
from jinja2.loaders import BaseLoader
from werkzeug.routing import RequestRedirect
from .blueprints import Blueprint
from .globals import request_ctx
from .sansio.app import App
if t.TYPE_CHECKING:
    from .sansio.scaffold import Scaffold
    from .wrappers import Request
# Code for class: UnexpectedUnicodeError()
# Code for class: DebugFilesKeyError(self, request: Request, key: str)
# Code for function: DebugFilesKeyError.__init__(self, request: Request, key: str)
# Code for function: DebugFilesKeyError.__str__(self)
# Code for class: FormDataRoutingRedirect(self, request: Request)
# Code for function: FormDataRoutingRedirect.__init__(self, request: Request)
# Code for function: attach_enctype_error_multidict(request: Request, self, key: str)
# Code for function: _dump_loader_info(loader: BaseLoader)
# Code for function: explain_template_loading_attempts(app: App, template: str, attempts: list[
        tuple[
            BaseLoader, Scaffold, tuple[str, str | None, t.Callable[[], bool] | None] | None, ]
    ], )

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: NoAppException
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/cli.py,793,894
Arguments: []
Code: class NoAppException(click.UsageError):
    """Raised if an application cannot be found or loaded."""
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: find_best_app
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/cli.py,897,2676
Arguments: ['module: ModuleType']
Code: def __init__(
        self,
        app_import_path: str | None = None,
        create_app: t.Callable[..., Flask] | None = None,
        set_debug_flag: bool = True,
        load_dotenv_defaults: bool = True,
    ) -> None:
        #: Optionally the import path for the Flask application.
        self.app_import_path = app_import_path
        #: Optionally a function that is passed the script info to create
        #: the instance of the application.
        self.create_app = create_app
        #: A dictionary with arbitrary data that can be associated with
        #: this script info.
        self.data: dict[t.Any, t.Any] = {}
        self.set_debug_flag = set_debug_flag

        self.load_dotenv_defaults = get_load_dotenv(load_dotenv_defaults)
        """Whether default ``.flaskenv`` and ``.env`` files should be loaded.

        ``ScriptInfo`` doesn't load anything, this is for reference when doing
        the load elsewhere during processing.

        .. versionadded:: 3.1
        """

        self._loaded_app: Flask | None = None
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _called_with_wrong_args
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/cli.py,2679,3426
Arguments: ['f: t.Callable[...', 'Flask]']
Code: def load_app(self) -> Flask:
        """Loads the Flask app (if not yet loaded) and returns it.  Calling
        this multiple times will just result in the already loaded app to
        be returned.
        """
        if self._loaded_app is not None:
            return self._loaded_app
        app: Flask | None = None
        if self.create_app is not None:
            app = self.create_app()
        else:
            if self.app_import_path:
                path, name = (
                    re.split(r":(?![\\/])", self.app_import_path, maxsplit=1) + [None]
                )[:2]
                import_name = prepare_import(path)
                app = locate_app(import_name, name)
            else:
                for path in ("wsgi.py", "app.py"):
                    import_name = prepare_import(path)
                    app = locate_app(import_name, None, raise_if_not_found=False)

                    if app is not None:
                        break

        if app is None:
            raise NoAppException(
                "Could not locate a Flask application. Use the"
                " 'flask --app' option, 'FLASK_APP' environment"
                " variable, or a 'wsgi.py' or 'app.py' file in the"
                " current directory."
            )

        if self.set_debug_flag:
            # Update the app's debug flag through the descriptor so that
            # other values repopulate as well.
            app.debug = get_debug_flag()

        self._loaded_app = app
        return app
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: find_app_by_string
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/cli.py,3429,6072
Arguments: ['module: ModuleType', 'app_name: str']
Code: class ScriptInfo:
    """Helper object to deal with Flask applications.  This is usually not
    necessary to interface with as it's used internally in the dispatching
    to click.  In future versions of Flask this object will most likely play
    a bigger role.  Typically it's created automatically by the
    :class:`FlaskGroup` but you can also manually create it and pass it
    onwards as click object.

    .. versionchanged:: 3.1
        Added the ``load_dotenv_defaults`` parameter and attribute.
    """

    # Code for function: ScriptInfo.__init__(self, app_import_path: str | None = None, create_app: t.Callable[..., Flask] | None = None, set_debug_flag: bool = True, load_dotenv_defaults: bool = True, )
# Code for function: ScriptInfo.load_app(self)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: prepare_import
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/cli.py,6075,6833
Arguments: ['path: str']
Code: def command(  # type: ignore[override]
        self, *args: t.Any, **kwargs: t.Any
    ) -> t.Callable[[t.Callable[..., t.Any]], click.Command]:
        """This works exactly like the method of the same name on a regular
        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`
        unless it's disabled by passing ``with_appcontext=False``.
        """
        wrap_for_ctx = kwargs.pop("with_appcontext", True)

        def decorator(f: t.Callable[..., t.Any]) -> click.Command:
            if wrap_for_ctx:
                f = with_appcontext(f)
            return super(AppGroup, self).command(*args, **kwargs)(f)  # type: ignore[no-any-return]

        return decorator
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: locate_app
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/cli.py,7109,8000
Arguments: ['module_name: str', 'app_name: str | None', 'raise_if_not_found: bool = True']
Code: def group(  # type: ignore[override]
        self, *args: t.Any, **kwargs: t.Any
    ) -> t.Callable[[t.Callable[..., t.Any]], click.Group]:
        """This works exactly like the method of the same name on a regular
        :class:`click.Group` but it defaults the group class to
        :class:`AppGroup`.
        """
        kwargs.setdefault("cls", AppGroup)
        return super().group(*args, **kwargs)  # type: ignore[no-any-return]
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get_version
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/cli.py,8003,8448
Arguments: ['ctx: click.Context', 'param: click.Parameter', 'value: t.Any']
Code: class AppGroup(click.Group):
    """This works similar to a regular click :class:`~click.Group` but it
    changes the behavior of the :meth:`command` decorator so that it
    automatically wraps the functions in :func:`with_appcontext`.

    Not to be confused with :class:`FlaskGroup`.
    """

    # Code for function: AppGroup.command(# type: ignore[override]
        self, *args: t.Any, **kwargs: t.Any, f: t.Callable[..., t.Any])
# Code for function: AppGroup.group(# type: ignore[override]
        self, *args: t.Any, **kwargs: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: ScriptInfo
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/cli.py,8628,9148
Arguments: ['self', 'app_import_path: str | None = None', 'create_app: t.Callable[...', 'Flask] | None = None', 'set_debug_flag: bool = True', 'load_dotenv_defaults: bool = True', '']
Code: def get_command(self, ctx: click.Context, name: str) -> click.Command | None:
        self._load_plugin_commands()
        # Look up built-in and plugin commands, which should be
        # available even if the app fails to load.
        rv = super().get_command(ctx, name)

        if rv is not None:
            return rv

        info = ctx.ensure_object(ScriptInfo)

        # Look up commands provided by the app, showing an error and
        # continuing if the app couldn't be loaded.
        try:
            app = info.load_app()
        except NoAppException as e:
            click.secho(f"Error: {e.format_message()}\n", err=True, fg="red")
            return None

        # Push an app context for the loaded app unless it is already
        # active somehow. This makes the context available to parameter
        # and command callbacks without needing @with_appcontext.
        if not current_app or current_app._get_current_object() is not app:  # type: ignore[attr-defined]
            ctx.with_resource(app.app_context())

        return app.cli.get_command(ctx, name)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: ScriptInfo
Location: /home/yuesheng/flask/src/flask/cli.py,9148,10197
Arguments: ['self', 'app_import_path: str | None = None', 'create_app: t.Callable[...', 'Flask] | None = None', 'set_debug_flag: bool = True', 'load_dotenv_defaults: bool = True', '']
Code: def __init__(
        self,
        add_default_commands: bool = True,
        create_app: t.Callable[..., Flask] | None = None,
        add_version_option: bool = True,
        load_dotenv: bool = True,
        set_debug_flag: bool = True,
        **extra: t.Any,
    ) -> None:
        params: list[click.Parameter] = list(extra.pop("params", None) or ())
        # Processing is done with option callbacks instead of a group
        # callback. This allows users to make a custom group callback
        # without losing the behavior. --env-file must come first so
        # that it is eagerly evaluated before --app.
        params.extend((_env_file_option, _app_option, _debug_option))

        if add_version_option:
            params.append(version_option)

        if "context_settings" not in extra:
            extra["context_settings"] = {}

        extra["context_settings"].setdefault("auto_envvar_prefix", "FLASK")

        super().__init__(params=params, **extra)

        self.create_app = create_app
        self.load_dotenv = load_dotenv
        self.set_debug_flag = set_debug_flag

        if add_default_commands:
            self.add_command(run_command)
            self.add_command(shell_command)
            self.add_command(routes_command)

        self._loaded_plugin_commands = False
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: load_app
Type: function
Parent Type: ScriptInfo
Location: /home/yuesheng/flask/src/flask/cli.py,10203,11724
Arguments: ['self']
Code: def _load_plugin_commands(self) -> None:
        if self._loaded_plugin_commands:
            return

        if sys.version_info >= (3, 10):
            from importlib import metadata
        else:
            # Use a backport on Python < 3.10. We technically have
            # importlib.metadata on 3.8+, but the API changed in 3.10,
            # so use the backport for consistency.
            import importlib_metadata as metadata  # pyright: ignore

        for ep in metadata.entry_points(group="flask.commands"):
            self.add_command(ep.load(), ep.name)

        self._loaded_plugin_commands = True
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: with_appcontext
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/cli.py,11849,12756
Arguments: ['f: F', 'ctx: click.Context', '/', '*args: t.Any', '**kwargs: t.Any']
Code: def list_commands(self, ctx: click.Context) -> list[str]:
        self._load_plugin_commands()
        # Start with the built-in and plugin commands.
        rv = set(super().list_commands(ctx))
        info = ctx.ensure_object(ScriptInfo)

        # Add commands provided by the app, showing an error and
        # continuing if the app couldn't be loaded.
        try:
            rv.update(info.load_app().cli.list_commands(ctx))
        except NoAppException as e:
            # When an app couldn't be loaded, show the error message
            # without the traceback.
            click.secho(f"Error: {e.format_message()}\n", err=True, fg="red")
        except Exception:
            # When any other errors occurred during loading, show the
            # full traceback.
            click.secho(f"{traceback.format_exc()}\n", err=True, fg="red")

        return sorted(rv)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: AppGroup
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/cli.py,12759,13060
Arguments: []
Code: class FlaskGroup(AppGroup):
    """Special subclass of the :class:`AppGroup` group that supports
    loading more commands from the configured Flask app.  Normally a
    developer does not have to interface with this class but there are
    some very advanced use cases for which it makes sense to create an
    instance of this. see :ref:`custom-scripts`.

    :param add_default_commands: if this is True then the default run and
        shell commands will be added.
    :param add_version_option: adds the ``--version`` option.
    :param create_app: an optional callback that is passed the script info and
        returns the loaded app.
    :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`
        files to set environment variables. Will also change the working
        directory to the directory containing the first file found.
    :param set_debug_flag: Set the app's debug flag.

    .. versionchanged:: 3.1
        ``-e path`` takes precedence over default ``.env`` and ``.flaskenv`` files.

    .. versionchanged:: 2.2
        Added the ``-A/--app``, ``--debug/--no-debug``, ``-e/--env-file`` options.

    .. versionchanged:: 2.2
        An app context is pushed when running ``app.cli`` commands, so
        ``@with_appcontext`` is no longer required for those commands.

    .. versionchanged:: 1.0
        If installed, python-dotenv will be used to load environment variables
        from :file:`.env` and :file:`.flaskenv` files.
    """

    # Code for function: FlaskGroup.__init__(self, add_default_commands: bool = True, create_app: t.Callable[..., Flask] | None = None, add_version_option: bool = True, load_dotenv: bool = True, set_debug_flag: bool = True, **extra: t.Any, )
# Code for function: FlaskGroup._load_plugin_commands(self)
# Code for function: FlaskGroup.get_command(self, ctx: click.Context, name: str)
# Code for function: FlaskGroup.list_commands(self, ctx: click.Context)
# Code for function: FlaskGroup.make_context(self, info_name: str | None, args: list[str], parent: click.Context | None = None, **extra: t.Any, )
# Code for function: FlaskGroup.parse_args(self, ctx: click.Context, args: list[str])

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: command
Type: function
Parent Type: AppGroup
Location: /home/yuesheng/flask/src/flask/cli.py,13060,13759
Arguments: ['# type: ignore[override]\n        self', '*args: t.Any', '**kwargs: t.Any', 'f: t.Callable[...', 't.Any]']
Code: def make_context(
        self,
        info_name: str | None,
        args: list[str],
        parent: click.Context | None = None,
        **extra: t.Any,
    ) -> click.Context:
        # Set a flag to tell app.run to become a no-op. If app.run was
        # not in a __name__ == __main__ guard, it would start the server
        # when importing, blocking whatever command is being called.
        os.environ["FLASK_RUN_FROM_CLI"] = "true"

        if "obj" not in extra and "obj" not in self.context_settings:
            extra["obj"] = ScriptInfo(
                create_app=self.create_app,
                set_debug_flag=self.set_debug_flag,
                load_dotenv_defaults=self.load_dotenv,
            )

        return super().make_context(info_name, args, parent=parent, **extra)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: group
Type: function
Parent Type: AppGroup
Location: /home/yuesheng/flask/src/flask/cli.py,13765,14204
Arguments: ['# type: ignore[override]\n        self', '*args: t.Any', '**kwargs: t.Any']
Code: def parse_args(self, ctx: click.Context, args: list[str]) -> list[str]:
        if not args and self.no_args_is_help:
            # Attempt to load --env-file and --app early in case they
            # were given as env vars. Otherwise no_args_is_help will not
            # see commands from app.cli.
            _env_file_option.handle_parse_result(ctx, {}, [])
            _app_option.handle_parse_result(ctx, {}, [])

        return super().parse_args(ctx, args)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _set_app
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/cli.py,14207,14428
Arguments: ['ctx: click.Context', 'param: click.Option', 'value: str | None']
Code: def __init__(self) -> None:
        self.path_type = click.Path(exists=True, dir_okay=False, resolve_path=True)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _set_debug
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/cli.py,15159,15767
Arguments: ['ctx: click.Context', 'param: click.Option', 'value: bool']
Code: def convert(
        self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None
    ) -> t.Any:
        try:
            import ssl
        except ImportError:
            raise click.BadParameter(
                'Using "--cert" requires Python to be compiled with SSL support.',
                ctx,
                param,
            ) from None

        try:
            return self.path_type(value, param, ctx)
        except click.BadParameter:
            value = click.STRING(value, param, ctx).lower()

            if value == "adhoc":
                try:
                    import cryptography  # noqa: F401
                except ImportError:
                    raise click.BadParameter(
                        "Using ad-hoc certificates requires the cryptography library.",
                        ctx,
                        param,
                    ) from None

                return value

            obj = import_string(value, silent=True)

            if isinstance(obj, ssl.SSLContext):
                return obj

            raise
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _env_file_callback
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/cli.py,15909,16666
Arguments: ['ctx: click.Context', 'param: click.Option', 'value: str | None']
Code: class CertParamType(click.ParamType):
    """Click option type for the ``--cert`` option. Allows either an
    existing file, the string ``'adhoc'``, or an import for a
    :class:`~ssl.SSLContext` object.
    """

    name = "path"

    # Code for function: CertParamType.__init__(self)
# Code for function: CertParamType.convert(self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: FlaskGroup
Location: /home/yuesheng/flask/src/flask/cli.py,18694,20005
Arguments: ['self', 'add_default_commands: bool = True', 'create_app: t.Callable[...', 'Flask] | None = None', 'add_version_option: bool = True', 'load_dotenv: bool = True', 'set_debug_flag: bool = True', '**extra: t.Any', '']
Code: def convert(
        self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None
    ) -> t.Any:
        items = self.split_envvar_value(value)
        # can't call no-arg super() inside list comprehension until Python 3.12
        super_convert = super().convert
        return [super_convert(item, param, ctx) for item in items]
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _load_plugin_commands
Type: function
Parent Type: FlaskGroup
Location: /home/yuesheng/flask/src/flask/cli.py,20011,20627
Arguments: ['self']
Code: class SeparatedPathType(click.Path):
    """Click option type that accepts a list of values separated by the
    OS's path separator (``:``, ``;`` on Windows). Each value is
    validated as a :class:`click.Path` type.
    """

    # Code for function: SeparatedPathType.convert(self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get_command
Type: function
Parent Type: FlaskGroup
Location: /home/yuesheng/flask/src/flask/cli.py,20633,21720
Arguments: ['self', 'ctx: click.Context', 'name: str']
Code: // Code for Global Scope
from __future__ import annotations
import ast
import collections.abc as cabc
import importlib.metadata
import inspect
import os
import platform
import re
import sys
import traceback
import typing as t
from functools import update_wrapper
from operator import itemgetter
from types import ModuleType
import click
from click.core import ParameterSource
from werkzeug import run_simple
from werkzeug.serving import is_running_from_reloader
from werkzeug.utils import import_string
from .globals import current_app
from .helpers import get_debug_flag
from .helpers import get_load_dotenv
if t.TYPE_CHECKING:
    import ssl

    from _typeshed.wsgi import StartResponse
    from _typeshed.wsgi import WSGIApplication
    from _typeshed.wsgi import WSGIEnvironment

    from .app import Flask
# Code for class: NoAppException()
# Code for function: find_best_app(module: ModuleType)
# Code for function: _called_with_wrong_args(f: t.Callable[..., Flask])
# Code for function: find_app_by_string(module: ModuleType, app_name: str)
# Code for function: prepare_import(path: str)
@t.overload
def locate_app(
    module_name: str, app_name: str | None, raise_if_not_found: t.Literal[True] = True
) -> Flask: ...
@t.overload
def locate_app(
    module_name: str, app_name: str | None, raise_if_not_found: t.Literal[False] = ...
) -> Flask | None: ...
# Code for function: locate_app(module_name: str, app_name: str | None, raise_if_not_found: bool = True)
# Code for function: get_version(ctx: click.Context, param: click.Parameter, value: t.Any)
version_option = click.Option(
    ["--version"],
    help="Show the Flask version.",
    expose_value=False,
    callback=get_version,
    is_flag=True,
    is_eager=True,
)
# Code for class: ScriptInfo(self, app_import_path: str | None = None, create_app: t.Callable[..., Flask] | None = None, set_debug_flag: bool = True, load_dotenv_defaults: bool = True, )
# Code for function: ScriptInfo.__init__(self, app_import_path: str | None = None, create_app: t.Callable[..., Flask] | None = None, set_debug_flag: bool = True, load_dotenv_defaults: bool = True, )
# Code for function: ScriptInfo.load_app(self)
pass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)
F = t.TypeVar("F", bound=t.Callable[..., t.Any])
# Code for function: with_appcontext(f: F, ctx: click.Context, /, *args: t.Any, **kwargs: t.Any)
# Code for class: AppGroup()
# Code for function: AppGroup.command(# type: ignore[override]
        self, *args: t.Any, **kwargs: t.Any, f: t.Callable[..., t.Any])
# Code for function: AppGroup.group(# type: ignore[override]
        self, *args: t.Any, **kwargs: t.Any)
# Code for function: _set_app(ctx: click.Context, param: click.Option, value: str | None)
# This option is eager so the app will be available if --help is given.
# --help is also eager, so --app must be before it in the param list.
# no_args_is_help bypasses eager processing, so this option must be
# processed manually in that case to ensure FLASK_APP gets picked up.
_app_option = click.Option(
    ["-A", "--app"],
    metavar="IMPORT",
    help=(
        "The Flask application or factory function to load, in the form 'module:name'."
        " Module can be a dotted import or file path. Name is not required if it is"
        " 'app', 'application', 'create_app', or 'make_app', and can be 'name(args)' to"
        " pass arguments."
    ),
    is_eager=True,
    expose_value=False,
    callback=_set_app,
)
# Code for function: _set_debug(ctx: click.Context, param: click.Option, value: bool)
_debug_option = click.Option(
    ["--debug/--no-debug"],
    help="Set debug mode.",
    expose_value=False,
    callback=_set_debug,
)
# Code for function: _env_file_callback(ctx: click.Context, param: click.Option, value: str | None)
# This option is eager so env vars are loaded as early as possible to be
# used by other options.
_env_file_option = click.Option(
    ["-e", "--env-file"],
    type=click.Path(exists=True, dir_okay=False),
    help=(
        "Load environment variables from this file, taking precedence over"
        " those set by '.env' and '.flaskenv'. Variables set directly in the"
        " environment take highest precedence. python-dotenv must be installed."
    ),
    is_eager=True,
    expose_value=False,
    callback=_env_file_callback,
)
# Code for class: FlaskGroup(self, add_default_commands: bool = True, create_app: t.Callable[..., Flask] | None = None, add_version_option: bool = True, load_dotenv: bool = True, set_debug_flag: bool = True, **extra: t.Any, )
# Code for function: FlaskGroup.__init__(self, add_default_commands: bool = True, create_app: t.Callable[..., Flask] | None = None, add_version_option: bool = True, load_dotenv: bool = True, set_debug_flag: bool = True, **extra: t.Any, )
# Code for function: FlaskGroup._load_plugin_commands(self)
# Code for function: FlaskGroup.get_command(self, ctx: click.Context, name: str)
# Code for function: FlaskGroup.list_commands(self, ctx: click.Context)
# Code for function: FlaskGroup.make_context(self, info_name: str | None, args: list[str], parent: click.Context | None = None, **extra: t.Any, )
# Code for function: FlaskGroup.parse_args(self, ctx: click.Context, args: list[str])
# Code for function: _path_is_ancestor(path: str, other: str)
# Code for function: load_dotenv(path: str | os.PathLike[str] | None = None, load_defaults: bool = True)
# Code for function: show_server_banner(debug: bool, app_import_path: str | None)
# Code for class: CertParamType(self)
# Code for function: CertParamType.__init__(self)
# Code for function: CertParamType.convert(self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None)
# Code for function: _validate_key(ctx: click.Context, param: click.Parameter, value: t.Any)
# Code for class: SeparatedPathType()
# Code for function: SeparatedPathType.convert(self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None)
@click.command("run", short_help="Run a development server.")
@click.option("--host", "-h", default="127.0.0.1", help="The interface to bind to.")
@click.option("--port", "-p", default=5000, help="The port to bind to.")
@click.option(
    "--cert",
    type=CertParamType(),
    help="Specify a certificate file to use HTTPS.",
    is_eager=True,
)
@click.option(
    "--key",
    type=click.Path(exists=True, dir_okay=False, resolve_path=True),
    callback=_validate_key,
    expose_value=False,
    help="The key file to use when specifying a certificate.",
)
@click.option(
    "--reload/--no-reload",
    default=None,
    help="Enable or disable the reloader. By default the reloader "
    "is active if debug is enabled.",
)
@click.option(
    "--debugger/--no-debugger",
    default=None,
    help="Enable or disable the debugger. By default the debugger "
    "is active if debug is enabled.",
)
@click.option(
    "--with-threads/--without-threads",
    default=True,
    help="Enable or disable multithreading.",
)
@click.option(
    "--extra-files",
    default=None,
    type=SeparatedPathType(),
    help=(
        "Extra files that trigger a reload on change. Multiple paths"
        f" are separated by {os.path.pathsep!r}."
    ),
)
@click.option(
    "--exclude-patterns",
    default=None,
    type=SeparatedPathType(),
    help=(
        "Files matching these fnmatch patterns will not trigger a reload"
        " on change. Multiple patterns are separated by"
        f" {os.path.pathsep!r}."
    ),
)
@pass_script_info
def run_command(
    info: ScriptInfo,
    host: str,
    port: int,
    reload: bool,
    debugger: bool,
    with_threads: bool,
    cert: ssl.SSLContext | tuple[str, str | None] | t.Literal["adhoc"] | None,
    extra_files: list[str] | None,
    exclude_patterns: list[str] | None,
) -> None:
    """Run a local development server.

    This server is for development purposes only. It does not provide
    the stability, security, or performance of production WSGI servers.

    The reloader and debugger are enabled by default with the '--debug'
    option.
    """
    try:
        app: WSGIApplication = info.load_app()  # pyright: ignore
    except Exception as e:
        if is_running_from_reloader():
            # When reloading, print out the error immediately, but raise
            # it later so the debugger or server can handle it.
            traceback.print_exc()
            err = e

            def app(
                environ: WSGIEnvironment, start_response: StartResponse
            ) -> cabc.Iterable[bytes]:
                raise err from None

        else:
            # When not reloading, raise the error immediately so the
            # command fails.
            raise e from None

    debug = get_debug_flag()

    if reload is None:
        reload = debug

    if debugger is None:
        debugger = debug

    show_server_banner(debug, info.app_import_path)

    run_simple(
        host,
        port,
        app,
        use_reloader=reload,
        use_debugger=debugger,
        threaded=with_threads,
        ssl_context=cert,
        extra_files=extra_files,
        exclude_patterns=exclude_patterns,
    )
run_command.params.insert(0, _debug_option)
@click.command("shell", short_help="Run a shell in the app context.")
@with_appcontext
def shell_command() -> None:
    """Run an interactive Python shell in the context of a given
    Flask application.  The application will populate the default
    namespace of this shell according to its configuration.

    This is useful for executing small snippets of management code
    without having to manually configure the application.
    """
    import code

    banner = (
        f"Python {sys.version} on {sys.platform}\n"
        f"App: {current_app.import_name}\n"
        f"Instance: {current_app.instance_path}"
    )
    ctx: dict[str, t.Any] = {}

    # Support the regular Python interpreter startup script if someone
    # is using it.
    startup = os.environ.get("PYTHONSTARTUP")
    if startup and os.path.isfile(startup):
        with open(startup) as f:
            eval(compile(f.read(), startup, "exec"), ctx)

    ctx.update(current_app.make_shell_context())

    # Site, customize, or startup script can set a hook to call when
    # entering interactive mode. The default one sets up readline with
    # tab and history completion.
    interactive_hook = getattr(sys, "__interactivehook__", None)

    if interactive_hook is not None:
        try:
            import readline
            from rlcompleter import Completer
        except ImportError:
            pass
        else:
            # rlcompleter uses __main__.__dict__ by default, which is
            # flask.__main__. Use the shell context instead.
            readline.set_completer(Completer(ctx).complete)

        interactive_hook()

    code.interact(banner=banner, local=ctx)
@click.command("routes", short_help="Show the routes for the app.")
@click.option(
    "--sort",
    "-s",
    type=click.Choice(("endpoint", "methods", "domain", "rule", "match")),
    default="endpoint",
    help=(
        "Method to sort routes by. 'match' is the order that Flask will match routes"
        " when dispatching a request."
    ),
)
@click.option("--all-methods", is_flag=True, help="Show HEAD and OPTIONS methods.")
@with_appcontext
def routes_command(sort: str, all_methods: bool) -> None:
    """Show all registered routes with endpoints and methods."""
    rules = list(current_app.url_map.iter_rules())

    if not rules:
        click.echo("No routes were registered.")
        return

    ignored_methods = set() if all_methods else {"HEAD", "OPTIONS"}
    host_matching = current_app.url_map.host_matching
    has_domain = any(rule.host if host_matching else rule.subdomain for rule in rules)
    rows = []

    for rule in rules:
        row = [
            rule.endpoint,
            ", ".join(sorted((rule.methods or set()) - ignored_methods)),
        ]

        if has_domain:
            row.append((rule.host if host_matching else rule.subdomain) or "")

        row.append(rule.rule)
        rows.append(row)

    headers = ["Endpoint", "Methods"]
    sorts = ["endpoint", "methods"]

    if has_domain:
        headers.append("Host" if host_matching else "Subdomain")
        sorts.append("domain")

    headers.append("Rule")
    sorts.append("rule")

    try:
        rows.sort(key=itemgetter(sorts.index(sort)))
    except ValueError:
        pass

    rows.insert(0, headers)
    widths = [max(len(row[i]) for row in rows) for i in range(len(headers))]
    rows.insert(1, ["-" * w for w in widths])
    template = "  ".join(f"{{{i}:<{w}}}" for i, w in enumerate(widths))

    for row in rows:
        click.echo(template.format(*row))
cli = FlaskGroup(
    name="flask",
    help="""\
A general utility script for Flask applications.

An application to load must be given with the '--app' option,
'FLASK_APP' environment variable, or with a 'wsgi.py' or 'app.py' file
in the current directory.
""",
)
# Code for function: main()
if __name__ == "__main__":
    main()

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _default_template_ctx_processor
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/templating.py,593,1014
Arguments: ['']
Code: def __init__(self, app: App, **options: t.Any) -> None:
        if "loader" not in options:
            options["loader"] = app.create_global_jinja_loader()
        BaseEnvironment.__init__(self, **options)
        self.app = app
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Environment
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/templating.py,1017,1273
Arguments: ['self', 'app: App', '**options: t.Any']
Code: def __init__(self, app: App) -> None:
        self.app = app
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: Environment
Location: /home/yuesheng/flask/src/flask/templating.py,1273,1502
Arguments: ['self', 'app: App', '**options: t.Any']
Code: class Environment(BaseEnvironment):
    """Works like a regular Jinja2 environment but has some additional
    knowledge of how Flask's blueprint works so that it can prepend the
    name of the blueprint to referenced templates if necessary.
    """

    # Code for function: Environment.__init__(self, app: App, **options: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: DispatchingJinjaLoader
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/templating.py,1505,1655
Arguments: ['self', 'app: App']
Code: // Code for Global Scope
from __future__ import annotations
import typing as t
from jinja2 import BaseLoader
from jinja2 import Environment as BaseEnvironment
from jinja2 import Template
from jinja2 import TemplateNotFound
from .globals import _cv_app
from .globals import _cv_request
from .globals import current_app
from .globals import request
from .helpers import stream_with_context
from .signals import before_render_template
from .signals import template_rendered
if t.TYPE_CHECKING:  # pragma: no cover
    from .app import Flask
    from .sansio.app import App
    from .sansio.scaffold import Scaffold
# Code for function: _default_template_ctx_processor()
# Code for class: Environment(self, app: App, **options: t.Any)
# Code for function: Environment.__init__(self, app: App, **options: t.Any)
# Code for class: DispatchingJinjaLoader(self, app: App)
# Code for function: DispatchingJinjaLoader.__init__(self, app: App)
# Code for function: DispatchingJinjaLoader.get_source(self, environment: BaseEnvironment, template: str)
# Code for function: DispatchingJinjaLoader._get_source_explained(self, environment: BaseEnvironment, template: str)
# Code for function: DispatchingJinjaLoader._get_source_fast(self, environment: BaseEnvironment, template: str)
# Code for function: DispatchingJinjaLoader._iter_loaders(self, template: str)
# Code for function: DispatchingJinjaLoader.list_templates(self)
# Code for function: _render(app: Flask, template: Template, context: dict[str, t.Any])
# Code for function: render_template(template_name_or_list: str | Template | list[str | Template], **context: t.Any, )
# Code for function: render_template_string(source: str, **context: t.Any)
# Code for function: _stream(app: Flask, template: Template, context: dict[str, t.Any], )
# Code for function: stream_template(template_name_or_list: str | Template | list[str | Template], **context: t.Any, )
# Code for function: stream_template_string(source: str, **context: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: DispatchingJinjaLoader
Location: /home/yuesheng/flask/src/flask/templating.py,1655,1715
Arguments: ['self', 'app: App']
Code: def get_source(
        self, environment: BaseEnvironment, template: str
    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:
        if self.app.config["EXPLAIN_TEMPLATE_LOADING"]:
            return self._get_source_explained(environment, template)
        return self._get_source_fast(environment, template)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get_source
Type: function
Parent Type: DispatchingJinjaLoader
Location: /home/yuesheng/flask/src/flask/templating.py,1721,2041
Arguments: ['self', 'environment: BaseEnvironment', 'template: str']
Code: def _get_source_explained(
        self, environment: BaseEnvironment, template: str
    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:
        attempts = []
        rv: tuple[str, str | None, t.Callable[[], bool] | None] | None
        trv: None | (tuple[str, str | None, t.Callable[[], bool] | None]) = None

        for srcobj, loader in self._iter_loaders(template):
            try:
                rv = loader.get_source(environment, template)
                if trv is None:
                    trv = rv
            except TemplateNotFound:
                rv = None
            attempts.append((loader, srcobj, rv))

        from .debughelpers import explain_template_loading_attempts

        explain_template_loading_attempts(self.app, template, attempts)

        if trv is not None:
            return trv
        raise TemplateNotFound(template)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _get_source_explained
Type: function
Parent Type: DispatchingJinjaLoader
Location: /home/yuesheng/flask/src/flask/templating.py,2047,2916
Arguments: ['self', 'environment: BaseEnvironment', 'template: str']
Code: def _get_source_fast(
        self, environment: BaseEnvironment, template: str
    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:
        for _srcobj, loader in self._iter_loaders(template):
            try:
                return loader.get_source(environment, template)
            except TemplateNotFound:
                continue
        raise TemplateNotFound(template)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _get_source_fast
Type: function
Parent Type: DispatchingJinjaLoader
Location: /home/yuesheng/flask/src/flask/templating.py,2922,3308
Arguments: ['self', 'environment: BaseEnvironment', 'template: str']
Code: def _iter_loaders(self, template: str) -> t.Iterator[tuple[Scaffold, BaseLoader]]:
        loader = self.app.jinja_loader
        if loader is not None:
            yield self.app, loader

        for blueprint in self.app.iter_blueprints():
            loader = blueprint.jinja_loader
            if loader is not None:
                yield blueprint, loader
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _iter_loaders
Type: function
Parent Type: DispatchingJinjaLoader
Location: /home/yuesheng/flask/src/flask/templating.py,3314,3674
Arguments: ['self', 'template: str']
Code: def list_templates(self) -> list[str]:
        result = set()
        loader = self.app.jinja_loader
        if loader is not None:
            result.update(loader.list_templates())

        for blueprint in self.app.iter_blueprints():
            loader = blueprint.jinja_loader
            if loader is not None:
                for template in loader.list_templates():
                    result.add(template)

        return list(result)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: list_templates
Type: function
Parent Type: DispatchingJinjaLoader
Location: /home/yuesheng/flask/src/flask/templating.py,3680,4122
Arguments: ['self']
Code: class DispatchingJinjaLoader(BaseLoader):
    """A loader that looks for templates in the application and all
    the blueprint folders.
    """

    # Code for function: DispatchingJinjaLoader.__init__(self, app: App)
# Code for function: DispatchingJinjaLoader.get_source(self, environment: BaseEnvironment, template: str)
# Code for function: DispatchingJinjaLoader._get_source_explained(self, environment: BaseEnvironment, template: str)
# Code for function: DispatchingJinjaLoader._get_source_fast(self, environment: BaseEnvironment, template: str)
# Code for function: DispatchingJinjaLoader._iter_loaders(self, template: str)
# Code for function: DispatchingJinjaLoader.list_templates(self)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/src/flask/config.py,0,13218
Arguments: []
Code: // Code for Global Scope
from __future__ import annotations
import errno
import json
import os
import types
import typing as t
from werkzeug.utils import import_string
if t.TYPE_CHECKING:
    import typing_extensions as te

    from .sansio.app import App
T = t.TypeVar("T")
# Code for class: ConfigAttribute(self, name: str, get_converter: t.Callable[[t.Any], T] | None = None)
# Code for function: ConfigAttribute.__init__(self, name: str, get_converter: t.Callable[[t.Any], T] | None = None)
# Code for function: ConfigAttribute.__get__(self, obj: App | None, owner: type[App] | None = None)
# Code for function: ConfigAttribute.__set__(self, obj: App, value: t.Any)
# Code for class: Config(self, root_path: str | os.PathLike[str], defaults: dict[str, t.Any] | None = None, )
# Code for function: Config.__init__(self, root_path: str | os.PathLike[str], defaults: dict[str, t.Any] | None = None, )
# Code for function: Config.from_envvar(self, variable_name: str, silent: bool = False)
# Code for function: Config.from_prefixed_env(self, prefix: str = "FLASK", *, loads: t.Callable[[str], t.Any] = json.loads)
# Code for function: Config.from_pyfile(self, filename: str | os.PathLike[str], silent: bool = False)
# Code for function: Config.from_object(self, obj: object | str)
# Code for function: Config.from_file(self, filename: str | os.PathLike[str], load: t.Callable[[t.IO[t.Any]], t.Mapping[str, t.Any]], silent: bool = False, text: bool = True, )
# Code for function: Config.from_mapping(self, mapping: t.Mapping[str, t.Any] | None = None, **kwargs: t.Any)
# Code for function: Config.get_namespace(self, namespace: str, lowercase: bool = True, trim_namespace: bool = True)
# Code for function: Config.__repr__(self)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: ConfigAttribute
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/config.py,257,350
Arguments: ['self', 'name: str', 'get_converter: t.Callable[[t.Any]', 'T] | None = None']
Code: class ConfigAttribute(t.Generic[T]):
    """Makes an attribute forward to the config"""

    # Code for function: ConfigAttribute.__init__(self, name: str, get_converter: t.Callable[[t.Any], T] | None = None)
# Code for function: ConfigAttribute.__get__(self, obj: App | None, owner: type[App] | None = None)
# Code for function: ConfigAttribute.__set__(self, obj: App, value: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: ConfigAttribute
Location: /home/yuesheng/flask/src/flask/config.py,350,527
Arguments: ['self', 'name: str', 'get_converter: t.Callable[[t.Any]', 'T] | None = None']
Code: def __init__(
        self, name: str, get_converter: t.Callable[[t.Any], T] | None = None
    ) -> None:
        self.__name__ = name
        self.get_converter = get_converter
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __get__
Type: function
Parent Type: ConfigAttribute
Location: /home/yuesheng/flask/src/flask/config.py,689,993
Arguments: ['self', 'obj: App | None', 'owner: type[App] | None = None']
Code: def __get__(self, obj: App | None, owner: type[App] | None = None) -> T | te.Self:
        if obj is None:
            return self

        rv = obj.config[self.__name__]

        if self.get_converter is not None:
            rv = self.get_converter(rv)

        return rv  # type: ignore[no-any-return]
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __set__
Type: function
Parent Type: ConfigAttribute
Location: /home/yuesheng/flask/src/flask/config.py,999,1091
Arguments: ['self', 'obj: App', 'value: t.Any']
Code: def __set__(self, obj: App, value: t.Any) -> None:
        obj.config[self.__name__] = value
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Config
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/config.py,1094,2909
Arguments: ['self', 'root_path: str | os.PathLike[str]', 'defaults: dict[str', 't.Any] | None = None', '']
Code: class Config(dict):  # type: ignore[type-arg]
    """Works exactly like a dict but provides ways to fill it from files
    or special dictionaries.  There are two common patterns to populate the
    config.

    Either you can fill the config from a config file::

        app.config.from_pyfile('yourconfig.cfg')

    Or alternatively you can define the configuration options in the
    module that calls :meth:`from_object` or provide an import path to
    a module that should be loaded.  It is also possible to tell it to
    use the same module and with that provide the configuration values
    just before the call::

        DEBUG = True
        SECRET_KEY = 'development key'
        app.config.from_object(__name__)

    In both cases (loading from any Python file or loading from modules),
    only uppercase keys are added to the config.  This makes it possible to use
    lowercase values in the config file for temporary values that are not added
    to the config or to define the config keys in the same file that implements
    the application.

    Probably the most interesting way to load configurations is from an
    environment variable pointing to a file::

        app.config.from_envvar('YOURAPPLICATION_SETTINGS')

    In this case before launching the application you have to set this
    environment variable to the file you want to use.  On Linux and OS X
    use the export statement::

        export YOURAPPLICATION_SETTINGS='/path/to/config/file'

    On windows use `set` instead.

    :param root_path: path to which files are read relative from.  When the
                      config object is created by the application, this is
                      the application's :attr:`~flask.Flask.root_path`.
    :param defaults: an optional dictionary of default values
    """

    # Code for function: Config.__init__(self, root_path: str | os.PathLike[str], defaults: dict[str, t.Any] | None = None, )
# Code for function: Config.from_envvar(self, variable_name: str, silent: bool = False)
# Code for function: Config.from_prefixed_env(self, prefix: str = "FLASK", *, loads: t.Callable[[str], t.Any] = json.loads)
# Code for function: Config.from_pyfile(self, filename: str | os.PathLike[str], silent: bool = False)
# Code for function: Config.from_object(self, obj: object | str)
# Code for function: Config.from_file(self, filename: str | os.PathLike[str], load: t.Callable[[t.IO[t.Any]], t.Mapping[str, t.Any]], silent: bool = False, text: bool = True, )
# Code for function: Config.from_mapping(self, mapping: t.Mapping[str, t.Any] | None = None, **kwargs: t.Any)
# Code for function: Config.get_namespace(self, namespace: str, lowercase: bool = True, trim_namespace: bool = True)
# Code for function: Config.__repr__(self)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: Config
Location: /home/yuesheng/flask/src/flask/config.py,2909,3120
Arguments: ['self', 'root_path: str | os.PathLike[str]', 'defaults: dict[str', 't.Any] | None = None', '']
Code: def __init__(
        self,
        root_path: str | os.PathLike[str],
        defaults: dict[str, t.Any] | None = None,
    ) -> None:
        super().__init__(defaults or {})
        self.root_path = root_path
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: from_envvar
Type: function
Parent Type: Config
Location: /home/yuesheng/flask/src/flask/config.py,3126,4166
Arguments: ['self', 'variable_name: str', 'silent: bool = False']
Code: def from_envvar(self, variable_name: str, silent: bool = False) -> bool:
        """Loads a configuration from an environment variable pointing to
        a configuration file.  This is basically just a shortcut with nicer
        error messages for this line of code::

            app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])

        :param variable_name: name of the environment variable
        :param silent: set to ``True`` if you want silent failure for missing
                       files.
        :return: ``True`` if the file was loaded successfully.
        """
        rv = os.environ.get(variable_name)
        if not rv:
            if silent:
                return False
            raise RuntimeError(
                f"The environment variable {variable_name!r} is not set"
                " and as such configuration could not be loaded. Set"
                " this variable and make it point to a configuration"
                " file"
            )
        return self.from_pyfile(rv, silent=silent)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: from_prefixed_env
Type: function
Parent Type: Config
Location: /home/yuesheng/flask/src/flask/config.py,4172,6289
Arguments: ['self', 'prefix: str = "FLASK"', '*', 'loads: t.Callable[[str]', 't.Any] = json.loads']
Code: def from_prefixed_env(
        self, prefix: str = "FLASK", *, loads: t.Callable[[str], t.Any] = json.loads
    ) -> bool:
        """Load any environment variables that start with ``FLASK_``,
        dropping the prefix from the env key for the config key. Values
        are passed through a loading function to attempt to convert them
        to more specific types than strings.

        Keys are loaded in :func:`sorted` order.

        The default loading function attempts to parse values as any
        valid JSON type, including dicts and lists.

        Specific items in nested dicts can be set by separating the
        keys with double underscores (``__``). If an intermediate key
        doesn't exist, it will be initialized to an empty dict.

        :param prefix: Load env vars that start with this prefix,
            separated with an underscore (``_``).
        :param loads: Pass each string value to this function and use
            the returned value as the config value. If any error is
            raised it is ignored and the value remains a string. The
            default is :func:`json.loads`.

        .. versionadded:: 2.1
        """
        prefix = f"{prefix}_"

        for key in sorted(os.environ):
            if not key.startswith(prefix):
                continue

            value = os.environ[key]
            key = key.removeprefix(prefix)

            try:
                value = loads(value)
            except Exception:
                # Keep the value as a string if loading failed.
                pass

            if "__" not in key:
                # A non-nested key, set directly.
                self[key] = value
                continue

            # Traverse nested dictionaries with keys separated by "__".
            current = self
            *parts, tail = key.split("__")

            for part in parts:
                # If an intermediate dict does not exist, create it.
                if part not in current:
                    current[part] = {}

                current = current[part]

            current[tail] = value

        return True
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: from_pyfile
Type: function
Parent Type: Config
Location: /home/yuesheng/flask/src/flask/config.py,6295,7568
Arguments: ['self', 'filename: str | os.PathLike[str]', 'silent: bool = False']
Code: def from_pyfile(
        self, filename: str | os.PathLike[str], silent: bool = False
    ) -> bool:
        """Updates the values in the config from a Python file.  This function
        behaves as if the file was imported as module with the
        :meth:`from_object` function.

        :param filename: the filename of the config.  This can either be an
                         absolute filename or a filename relative to the
                         root path.
        :param silent: set to ``True`` if you want silent failure for missing
                       files.
        :return: ``True`` if the file was loaded successfully.

        .. versionadded:: 0.7
           `silent` parameter.
        """
        filename = os.path.join(self.root_path, filename)
        d = types.ModuleType("config")
        d.__file__ = filename
        try:
            with open(filename, mode="rb") as config_file:
                exec(compile(config_file.read(), filename, "exec"), d.__dict__)
        except OSError as e:
            if silent and e.errno in (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):
                return False
            e.strerror = f"Unable to load configuration file ({e.strerror})"
            raise
        self.from_object(d)
        return True
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: from_object
Type: function
Parent Type: Config
Location: /home/yuesheng/flask/src/flask/config.py,7574,9237
Arguments: ['self', 'obj: object | str']
Code: def from_object(self, obj: object | str) -> None:
        """Updates the values from the given object.  An object can be of one
        of the following two types:

        -   a string: in this case the object with that name will be imported
        -   an actual object reference: that object is used directly

        Objects are usually either modules or classes. :meth:`from_object`
        loads only the uppercase attributes of the module/class. A ``dict``
        object will not work with :meth:`from_object` because the keys of a
        ``dict`` are not attributes of the ``dict`` class.

        Example of module-based configuration::

            app.config.from_object('yourapplication.default_config')
            from yourapplication import default_config
            app.config.from_object(default_config)

        Nothing is done to the object before loading. If the object is a
        class and has ``@property`` attributes, it needs to be
        instantiated before being passed to this method.

        You should not use this function to load the actual configuration but
        rather configuration defaults.  The actual config should be loaded
        with :meth:`from_pyfile` and ideally from a location not within the
        package because the package might be installed system wide.

        See :ref:`config-dev-prod` for an example of class-based configuration
        using :meth:`from_object`.

        :param obj: an import name or object
        """
        if isinstance(obj, str):
            obj = import_string(obj)
        for key in dir(obj):
            if key.isupper():
                self[key] = getattr(obj, key)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: from_file
Type: function
Parent Type: Config
Location: /home/yuesheng/flask/src/flask/config.py,9243,10945
Arguments: ['self', 'filename: str | os.PathLike[str]', 'load: t.Callable[[t.IO[t.Any]]', 't.Mapping[str', 't.Any]]', 'silent: bool = False', 'text: bool = True', '']
Code: def from_file(
        self,
        filename: str | os.PathLike[str],
        load: t.Callable[[t.IO[t.Any]], t.Mapping[str, t.Any]],
        silent: bool = False,
        text: bool = True,
    ) -> bool:
        """Update the values in the config from a file that is loaded
        using the ``load`` parameter. The loaded data is passed to the
        :meth:`from_mapping` method.

        .. code-block:: python

            import json
            app.config.from_file("config.json", load=json.load)

            import tomllib
            app.config.from_file("config.toml", load=tomllib.load, text=False)

        :param filename: The path to the data file. This can be an
            absolute path or relative to the config root path.
        :param load: A callable that takes a file handle and returns a
            mapping of loaded data from the file.
        :type load: ``Callable[[Reader], Mapping]`` where ``Reader``
            implements a ``read`` method.
        :param silent: Ignore the file if it doesn't exist.
        :param text: Open the file in text or binary mode.
        :return: ``True`` if the file was loaded successfully.

        .. versionchanged:: 2.3
            The ``text`` parameter was added.

        .. versionadded:: 2.0
        """
        filename = os.path.join(self.root_path, filename)

        try:
            with open(filename, "r" if text else "rb") as f:
                obj = load(f)
        except OSError as e:
            if silent and e.errno in (errno.ENOENT, errno.EISDIR):
                return False

            e.strerror = f"Unable to load configuration file ({e.strerror})"
            raise

        return self.from_mapping(obj)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: from_mapping
Type: function
Parent Type: Config
Location: /home/yuesheng/flask/src/flask/config.py,10951,11509
Arguments: ['self', 'mapping: t.Mapping[str', 't.Any] | None = None', '**kwargs: t.Any']
Code: def from_mapping(
        self, mapping: t.Mapping[str, t.Any] | None = None, **kwargs: t.Any
    ) -> bool:
        """Updates the config like :meth:`update` ignoring items with
        non-upper keys.

        :return: Always returns ``True``.

        .. versionadded:: 0.11
        """
        mappings: dict[str, t.Any] = {}
        if mapping is not None:
            mappings.update(mapping)
        mappings.update(kwargs)
        for key, value in mappings.items():
            if key.isupper():
                self[key] = value
        return True
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get_namespace
Type: function
Parent Type: Config
Location: /home/yuesheng/flask/src/flask/config.py,11515,13122
Arguments: ['self', 'namespace: str', 'lowercase: bool = True', 'trim_namespace: bool = True']
Code: def get_namespace(
        self, namespace: str, lowercase: bool = True, trim_namespace: bool = True
    ) -> dict[str, t.Any]:
        """Returns a dictionary containing a subset of configuration options
        that match the specified namespace/prefix. Example usage::

            app.config['IMAGE_STORE_TYPE'] = 'fs'
            app.config['IMAGE_STORE_PATH'] = '/var/app/images'
            app.config['IMAGE_STORE_BASE_URL'] = 'http://img.website.com'
            image_store_config = app.config.get_namespace('IMAGE_STORE_')

        The resulting dictionary `image_store_config` would look like::

            {
                'type': 'fs',
                'path': '/var/app/images',
                'base_url': 'http://img.website.com'
            }

        This is often useful when configuration options map directly to
        keyword arguments in functions or class constructors.

        :param namespace: a configuration namespace
        :param lowercase: a flag indicating if the keys of the resulting
                          dictionary should be lowercase
        :param trim_namespace: a flag indicating if the keys of the resulting
                          dictionary should not include the namespace

        .. versionadded:: 0.11
        """
        rv = {}
        for k, v in self.items():
            if not k.startswith(namespace):
                continue
            if trim_namespace:
                key = k[len(namespace) :]
            else:
                key = k
            if lowercase:
                key = key.lower()
            rv[key] = v
        return rv
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __repr__
Type: function
Parent Type: Config
Location: /home/yuesheng/flask/src/flask/config.py,13128,13218
Arguments: ['self']
Code: def __repr__(self) -> str:
        return f"<{type(self).__name__} {dict.__repr__(self)}>"
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: has_level_handler
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/logging.py,809,1325
Arguments: ['logger: logging.Logger']
Code: // Code for Global Scope
from __future__ import annotations
import logging
import sys
import typing as t
from werkzeug.local import LocalProxy
from .globals import request
if t.TYPE_CHECKING:  # pragma: no cover
    from .sansio.app import App
@LocalProxy
def wsgi_errors_stream() -> t.TextIO:
    """Find the most appropriate error stream for the application. If a request
    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.

    If you configure your own :class:`logging.StreamHandler`, you may want to
    use this for the stream. If you are using file or dict configuration and
    can't import this directly, you can refer to it as
    ``ext://flask.logging.wsgi_errors_stream``.
    """
    if request:
        return request.environ["wsgi.errors"]  # type: ignore[no-any-return]

    return sys.stderr
# Code for function: has_level_handler(logger: logging.Logger)
#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format
#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.
default_handler = logging.StreamHandler(wsgi_errors_stream)
# type: ignore
default_handler.setFormatter(
    logging.Formatter("[%(asctime)s] %(levelname)s in %(module)s: %(message)s")
)
# Code for function: create_logger(app: App)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: SessionMixin
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/sessions.py,556,1490
Arguments: []
Code: class SessionMixin(MutableMapping[str, t.Any]):
    """Expands a basic dictionary with session attributes."""

    @property
    def permanent(self) -> bool:
        """This reflects the ``'_permanent'`` key in the dict."""
        return self.get("_permanent", False)

    @permanent.setter
    def permanent(self, value: bool) -> None:
        self["_permanent"] = bool(value)

    #: Some implementations can detect whether a session is newly
    #: created, but that is not guaranteed. Use with caution. The mixin
    # default is hard-coded ``False``.
    new = False

    #: Some implementations can detect changes to the session and set
    #: this when that happens. The mixin default is hard coded to
    #: ``True``.
    modified = True

    #: Some implementations can detect when session data is read or
    #: written and set this when that happens. The mixin default is hard
    #: coded to ``True``.
    accessed = True
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: SecureCookieSession
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/sessions.py,1493,2463
Arguments: ['self', 'initial: c.Mapping[str', 't.Any] | c.Iterable[tuple[str', 't.Any]] | None = None', '', 'self: te.Self']
Code: class SecureCookieSession(CallbackDict[str, t.Any], SessionMixin):
    """Base class for sessions based on signed cookies.

    This session backend will set the :attr:`modified` and
    :attr:`accessed` attributes. It cannot reliably track whether a
    session is new (vs. empty), so :attr:`new` remains hard coded to
    ``False``.
    """

    #: When data is changed, this is set to ``True``. Only the session
    #: dictionary itself is tracked; if the session contains mutable
    #: data (for example a nested dict) then this must be set to
    #: ``True`` manually when modifying that data. The session cookie
    #: will only be written to the response if this is ``True``.
    modified = False

    #: When data is read or written, this is set to ``True``. Used by
    # :class:`.SecureCookieSessionInterface` to add a ``Vary: Cookie``
    #: header, which allows caching proxies to cache different pages for
    #: different users.
    accessed = False

    # Code for function: SecureCookieSession.__init__(self, initial: c.Mapping[str, t.Any] | c.Iterable[tuple[str, t.Any]] | None = None, , self: te.Self)
# Code for function: SecureCookieSession.__getitem__(self, key: str)
# Code for function: SecureCookieSession.get(self, key: str, default: t.Any = None)
# Code for function: SecureCookieSession.setdefault(self, key: str, default: t.Any = None)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: SecureCookieSession
Location: /home/yuesheng/flask/src/flask/sessions.py,2463,2749
Arguments: ['self', 'initial: c.Mapping[str', 't.Any] | c.Iterable[tuple[str', 't.Any]] | None = None', '', 'self: te.Self']
Code: def __init__(
        self,
        initial: c.Mapping[str, t.Any] | c.Iterable[tuple[str, t.Any]] | None = None,
    ) -> None:
        def on_update(self: te.Self) -> None:
            self.modified = True
            self.accessed = True

        super().__init__(initial, on_update)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __getitem__
Type: function
Parent Type: SecureCookieSession
Location: /home/yuesheng/flask/src/flask/sessions.py,2755,2865
Arguments: ['self', 'key: str']
Code: def __getitem__(self, key: str) -> t.Any:
        self.accessed = True
        return super().__getitem__(key)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get
Type: function
Parent Type: SecureCookieSession
Location: /home/yuesheng/flask/src/flask/sessions.py,2871,2997
Arguments: ['self', 'key: str', 'default: t.Any = None']
Code: def get(self, key: str, default: t.Any = None) -> t.Any:
        self.accessed = True
        return super().get(key, default)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: setdefault
Type: function
Parent Type: SecureCookieSession
Location: /home/yuesheng/flask/src/flask/sessions.py,3003,3143
Arguments: ['self', 'key: str', 'default: t.Any = None']
Code: def setdefault(self, key: str, default: t.Any = None) -> t.Any:
        self.accessed = True
        return super().setdefault(key, default)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: NullSession
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/sessions.py,3146,3366
Arguments: []
Code: class NullSession(SecureCookieSession):
    """Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """

    # Code for function: NullSession._fail(self, *args: t.Any, **kwargs: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _fail
Type: function
Parent Type: NullSession
Location: /home/yuesheng/flask/src/flask/sessions.py,3366,3638
Arguments: ['self', '*args: t.Any', '**kwargs: t.Any']
Code: def _fail(self, *args: t.Any, **kwargs: t.Any) -> t.NoReturn:
        raise RuntimeError(
            "The session is unavailable because no secret "
            "key was set.  Set the secret_key on the "
            "application to something unique and secret."
        )
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: SessionInterface
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/sessions.py,3769,5919
Arguments: []
Code: class SessionInterface:
    """The basic interface you have to implement in order to replace the
    default session interface which uses werkzeug's securecookie
    implementation.  The only methods you have to implement are
    :meth:`open_session` and :meth:`save_session`, the others have
    useful defaults which you don't need to change.

    The session object returned by the :meth:`open_session` method has to
    provide a dictionary like interface plus the properties and methods
    from the :class:`SessionMixin`.  We recommend just subclassing a dict
    and adding that mixin::

        class Session(dict, SessionMixin):
            pass

    If :meth:`open_session` returns ``None`` Flask will call into
    :meth:`make_null_session` to create a session that acts as replacement
    if the session support cannot work because some requirement is not
    fulfilled.  The default :class:`NullSession` class that is created
    will complain that the secret key was not set.

    To replace the session interface on an application all you have to do
    is to assign :attr:`flask.Flask.session_interface`::

        app = Flask(__name__)
        app.session_interface = MySessionInterface()

    Multiple requests with the same session may be sent and handled
    concurrently. When implementing a new session interface, consider
    whether reads or writes to the backing store must be synchronized.
    There is no guarantee on the order in which the session for each
    request is opened or saved, it will occur in the order that requests
    begin and end processing.

    .. versionadded:: 0.8
    """

    #: :meth:`make_null_session` will look here for the class that should
    #: be created when a null session is requested.  Likewise the
    #: :meth:`is_null_session` method will perform a typecheck against
    #: this type.
    null_session_class = NullSession

    #: A flag that indicates if the session interface is pickle based.
    #: This can be used by Flask extensions to make a decision in regards
    #: to how to deal with the session object.
    #:
    #: .. versionadded:: 0.10
    pickle_based = False

    # Code for function: SessionInterface.make_null_session(self, app: Flask)
# Code for function: SessionInterface.is_null_session(self, obj: object)
# Code for function: SessionInterface.get_cookie_name(self, app: Flask)
# Code for function: SessionInterface.get_cookie_domain(self, app: Flask)
# Code for function: SessionInterface.get_cookie_path(self, app: Flask)
# Code for function: SessionInterface.get_cookie_httponly(self, app: Flask)
# Code for function: SessionInterface.get_cookie_secure(self, app: Flask)
# Code for function: SessionInterface.get_cookie_samesite(self, app: Flask)
# Code for function: SessionInterface.get_cookie_partitioned(self, app: Flask)
# Code for function: SessionInterface.get_expiration_time(self, app: Flask, session: SessionMixin)
# Code for function: SessionInterface.should_set_cookie(self, app: Flask, session: SessionMixin)
# Code for function: SessionInterface.open_session(self, app: Flask, request: Request)
# Code for function: SessionInterface.save_session(self, app: Flask, session: SessionMixin, response: Response)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: make_null_session
Type: function
Parent Type: SessionInterface
Location: /home/yuesheng/flask/src/flask/sessions.py,5919,6487
Arguments: ['self', 'app: Flask']
Code: def make_null_session(self, app: Flask) -> NullSession:
        """Creates a null session which acts as a replacement object if the
        real session support could not be loaded due to a configuration
        error.  This mainly aids the user experience because the job of the
        null session is to still support lookup without complaining but
        modifications are answered with a helpful error message of what
        failed.

        This creates an instance of :attr:`null_session_class` by default.
        """
        return self.null_session_class()
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: is_null_session
Type: function
Parent Type: SessionInterface
Location: /home/yuesheng/flask/src/flask/sessions.py,6493,6813
Arguments: ['self', 'obj: object']
Code: def is_null_session(self, obj: object) -> bool:
        """Checks if a given object is a null session.  Null sessions are
        not asked to be saved.

        This checks if the object is an instance of :attr:`null_session_class`
        by default.
        """
        return isinstance(obj, self.null_session_class)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get_cookie_name
Type: function
Parent Type: SessionInterface
Location: /home/yuesheng/flask/src/flask/sessions.py,6819,7033
Arguments: ['self', 'app: Flask']
Code: def get_cookie_name(self, app: Flask) -> str:
        """The name of the session cookie. Uses``app.config["SESSION_COOKIE_NAME"]``."""
        return app.config["SESSION_COOKIE_NAME"]  # type: ignore[no-any-return]
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get_cookie_domain
Type: function
Parent Type: SessionInterface
Location: /home/yuesheng/flask/src/flask/sessions.py,7039,7593
Arguments: ['self', 'app: Flask']
Code: def get_cookie_domain(self, app: Flask) -> str | None:
        """The value of the ``Domain`` parameter on the session cookie. If not set,
        browsers will only send the cookie to the exact domain it was set from.
        Otherwise, they will send it to any subdomain of the given value as well.

        Uses the :data:`SESSION_COOKIE_DOMAIN` config.

        .. versionchanged:: 2.3
            Not set by default, does not fall back to ``SERVER_NAME``.
        """
        return app.config["SESSION_COOKIE_DOMAIN"]  # type: ignore[no-any-return]
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get_cookie_path
Type: function
Parent Type: SessionInterface
Location: /home/yuesheng/flask/src/flask/sessions.py,7599,8031
Arguments: ['self', 'app: Flask']
Code: def get_cookie_path(self, app: Flask) -> str:
        """Returns the path for which the cookie should be valid.  The
        default implementation uses the value from the ``SESSION_COOKIE_PATH``
        config var if it's set, and falls back to ``APPLICATION_ROOT`` or
        uses ``/`` if it's ``None``.
        """
        return app.config["SESSION_COOKIE_PATH"] or app.config["APPLICATION_ROOT"]  # type: ignore[no-any-return]
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get_cookie_httponly
Type: function
Parent Type: SessionInterface
Location: /home/yuesheng/flask/src/flask/sessions.py,8037,8351
Arguments: ['self', 'app: Flask']
Code: def get_cookie_httponly(self, app: Flask) -> bool:
        """Returns True if the session cookie should be httponly.  This
        currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``
        config var.
        """
        return app.config["SESSION_COOKIE_HTTPONLY"]  # type: ignore[no-any-return]
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get_cookie_secure
Type: function
Parent Type: SessionInterface
Location: /home/yuesheng/flask/src/flask/sessions.py,8357,8644
Arguments: ['self', 'app: Flask']
Code: def get_cookie_secure(self, app: Flask) -> bool:
        """Returns True if the cookie should be secure.  This currently
        just returns the value of the ``SESSION_COOKIE_SECURE`` setting.
        """
        return app.config["SESSION_COOKIE_SECURE"]  # type: ignore[no-any-return]
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get_cookie_samesite
Type: function
Parent Type: SessionInterface
Location: /home/yuesheng/flask/src/flask/sessions.py,8650,9001
Arguments: ['self', 'app: Flask']
Code: def get_cookie_samesite(self, app: Flask) -> str | None:
        """Return ``'Strict'`` or ``'Lax'`` if the cookie should use the
        ``SameSite`` attribute. This currently just returns the value of
        the :data:`SESSION_COOKIE_SAMESITE` setting.
        """
        return app.config["SESSION_COOKIE_SAMESITE"]  # type: ignore[no-any-return]
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get_cookie_partitioned
Type: function
Parent Type: SessionInterface
Location: /home/yuesheng/flask/src/flask/sessions.py,9007,9325
Arguments: ['self', 'app: Flask']
Code: def get_cookie_partitioned(self, app: Flask) -> bool:
        """Returns True if the cookie should be partitioned. By default, uses
        the value of :data:`SESSION_COOKIE_PARTITIONED`.

        .. versionadded:: 3.1
        """
        return app.config["SESSION_COOKIE_PARTITIONED"]  # type: ignore[no-any-return]
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get_expiration_time
Type: function
Parent Type: SessionInterface
Location: /home/yuesheng/flask/src/flask/sessions.py,9331,9820
Arguments: ['self', 'app: Flask', 'session: SessionMixin']
Code: def get_expiration_time(self, app: Flask, session: SessionMixin) -> datetime | None:
        """A helper method that returns an expiration date for the session
        or ``None`` if the session is linked to the browser session.  The
        default implementation returns now + the permanent session
        lifetime configured on the application.
        """
        if session.permanent:
            return datetime.now(timezone.utc) + app.permanent_session_lifetime
        return None
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: should_set_cookie
Type: function
Parent Type: SessionInterface
Location: /home/yuesheng/flask/src/flask/sessions.py,9826,10462
Arguments: ['self', 'app: Flask', 'session: SessionMixin']
Code: def should_set_cookie(self, app: Flask, session: SessionMixin) -> bool:
        """Used by session backends to determine if a ``Set-Cookie`` header
        should be set for this session cookie for this response. If the session
        has been modified, the cookie is set. If the session is permanent and
        the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is
        always set.

        This check is usually skipped if the session was deleted.

        .. versionadded:: 0.11
        """

        return session.modified or (
            session.permanent and app.config["SESSION_REFRESH_EACH_REQUEST"]
        )
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: open_session
Type: function
Parent Type: SessionInterface
Location: /home/yuesheng/flask/src/flask/sessions.py,10468,11078
Arguments: ['self', 'app: Flask', 'request: Request']
Code: def open_session(self, app: Flask, request: Request) -> SessionMixin | None:
        """This is called at the beginning of each request, after
        pushing the request context, before matching the URL.

        This must return an object which implements a dictionary-like
        interface as well as the :class:`SessionMixin` interface.

        This will return ``None`` to indicate that loading failed in
        some way that is not immediately an error. The request
        context will fall back to using :meth:`make_null_session`
        in this case.
        """
        raise NotImplementedError()
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: save_session
Type: function
Parent Type: SessionInterface
Location: /home/yuesheng/flask/src/flask/sessions.py,11084,11427
Arguments: ['self', 'app: Flask', 'session: SessionMixin', 'response: Response']
Code: def save_session(
        self, app: Flask, session: SessionMixin, response: Response
    ) -> None:
        """This is called at the end of each request, after generating
        a response, before removing the request context. It is skipped
        if :meth:`is_null_session` returns ``True``.
        """
        raise NotImplementedError()
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _lazy_sha1
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/sessions.py,11481,11769
Arguments: ['string: bytes = b""']
Code: def get_signing_serializer(self, app: Flask) -> URLSafeTimedSerializer | None:
        if not app.secret_key:
            return None

        keys: list[str | bytes] = [app.secret_key]

        if fallbacks := app.config["SECRET_KEY_FALLBACKS"]:
            keys.extend(fallbacks)

        return URLSafeTimedSerializer(
            keys,  # type: ignore[arg-type]
            salt=self.salt,
            serializer=self.serializer,
            signer_kwargs={
                "key_derivation": self.key_derivation,
                "digest_method": self.digest_method,
            },
        )
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: SecureCookieSessionInterface
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/sessions.py,11772,12603
Arguments: []
Code: // Code for Global Scope
from __future__ import annotations
import collections.abc as c
import hashlib
import typing as t
from collections.abc import MutableMapping
from datetime import datetime
from datetime import timezone
from itsdangerous import BadSignature
from itsdangerous import URLSafeTimedSerializer
from werkzeug.datastructures import CallbackDict
from .json.tag import TaggedJSONSerializer
if t.TYPE_CHECKING:  # pragma: no cover
    import typing_extensions as te

    from .app import Flask
    from .wrappers import Request
    from .wrappers import Response
# Code for class: SessionMixin()
# Code for class: SecureCookieSession(self, initial: c.Mapping[str, t.Any] | c.Iterable[tuple[str, t.Any]] | None = None, , self: te.Self)
# Code for function: SecureCookieSession.__init__(self, initial: c.Mapping[str, t.Any] | c.Iterable[tuple[str, t.Any]] | None = None, , self: te.Self)
# Code for function: SecureCookieSession.__getitem__(self, key: str)
# Code for function: SecureCookieSession.get(self, key: str, default: t.Any = None)
# Code for function: SecureCookieSession.setdefault(self, key: str, default: t.Any = None)
# Code for class: NullSession()
# Code for function: NullSession._fail(self, *args: t.Any, **kwargs: t.Any)
# Code for class: SessionInterface()
# Code for function: SessionInterface.make_null_session(self, app: Flask)
# Code for function: SessionInterface.is_null_session(self, obj: object)
# Code for function: SessionInterface.get_cookie_name(self, app: Flask)
# Code for function: SessionInterface.get_cookie_domain(self, app: Flask)
# Code for function: SessionInterface.get_cookie_path(self, app: Flask)
# Code for function: SessionInterface.get_cookie_httponly(self, app: Flask)
# Code for function: SessionInterface.get_cookie_secure(self, app: Flask)
# Code for function: SessionInterface.get_cookie_samesite(self, app: Flask)
# Code for function: SessionInterface.get_cookie_partitioned(self, app: Flask)
# Code for function: SessionInterface.get_expiration_time(self, app: Flask, session: SessionMixin)
# Code for function: SessionInterface.should_set_cookie(self, app: Flask, session: SessionMixin)
# Code for function: SessionInterface.open_session(self, app: Flask, request: Request)
# Code for function: SessionInterface.save_session(self, app: Flask, session: SessionMixin, response: Response)
session_json_serializer = TaggedJSONSerializer()
# Code for function: _lazy_sha1(string: bytes = b"")
# Code for class: SecureCookieSessionInterface()
# Code for function: SecureCookieSessionInterface.get_signing_serializer(self, app: Flask)
# Code for function: SecureCookieSessionInterface.open_session(self, app: Flask, request: Request)
# Code for function: SecureCookieSessionInterface.save_session(self, app: Flask, session: SessionMixin, response: Response)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get_signing_serializer
Type: function
Parent Type: SecureCookieSessionInterface
Location: /home/yuesheng/flask/src/flask/sessions.py,12603,13197
Arguments: ['self', 'app: Flask']
Code: def open_session(self, app: Flask, request: Request) -> SecureCookieSession | None:
        s = self.get_signing_serializer(app)
        if s is None:
            return None
        val = request.cookies.get(self.get_cookie_name(app))
        if not val:
            return self.session_class()
        max_age = int(app.permanent_session_lifetime.total_seconds())
        try:
            data = s.loads(val, max_age=max_age)
            return self.session_class(data)
        except BadSignature:
            return self.session_class()
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: open_session
Type: function
Parent Type: SecureCookieSessionInterface
Location: /home/yuesheng/flask/src/flask/sessions.py,13203,13743
Arguments: ['self', 'app: Flask', 'request: Request']
Code: def save_session(
        self, app: Flask, session: SessionMixin, response: Response
    ) -> None:
        name = self.get_cookie_name(app)
        domain = self.get_cookie_domain(app)
        path = self.get_cookie_path(app)
        secure = self.get_cookie_secure(app)
        partitioned = self.get_cookie_partitioned(app)
        samesite = self.get_cookie_samesite(app)
        httponly = self.get_cookie_httponly(app)

        # Add a "Vary: Cookie" header if the session was accessed at all.
        if session.accessed:
            response.vary.add("Cookie")

        # If the session is modified to be empty, remove the cookie.
        # If the session is empty, return without setting the cookie.
        if not session:
            if session.modified:
                response.delete_cookie(
                    name,
                    domain=domain,
                    path=path,
                    secure=secure,
                    partitioned=partitioned,
                    samesite=samesite,
                    httponly=httponly,
                )
                response.vary.add("Cookie")

            return

        if not self.should_set_cookie(app, session):
            return

        expires = self.get_expiration_time(app, session)
        val = self.get_signing_serializer(app).dumps(dict(session))  # type: ignore[union-attr]
        response.set_cookie(
            name,
            val,
            expires=expires,
            httponly=httponly,
            domain=domain,
            path=path,
            secure=secure,
            partitioned=partitioned,
            samesite=samesite,
        )
        response.vary.add("Cookie")
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: save_session
Type: function
Parent Type: SecureCookieSessionInterface
Location: /home/yuesheng/flask/src/flask/sessions.py,13749,15429
Arguments: ['self', 'app: Flask', 'session: SessionMixin', 'response: Response']
Code: class SecureCookieSessionInterface(SessionInterface):
    """The default session interface that stores sessions in signed cookies
    through the :mod:`itsdangerous` module.
    """

    #: the salt that should be applied on top of the secret key for the
    #: signing of cookie based sessions.
    salt = "cookie-session"
    #: the hash function to use for the signature.  The default is sha1
    digest_method = staticmethod(_lazy_sha1)
    #: the name of the itsdangerous supported key derivation.  The default
    #: is hmac.
    key_derivation = "hmac"
    #: A python serializer for the payload.  The default is a compact
    #: JSON derived serializer with support for some extra Python types
    #: such as datetime objects or tuples.
    serializer = session_json_serializer
    session_class = SecureCookieSession

    # Code for function: SecureCookieSessionInterface.get_signing_serializer(self, app: Flask)
# Code for function: SecureCookieSessionInterface.open_session(self, app: Flask, request: Request)
# Code for function: SecureCookieSessionInterface.save_session(self, app: Flask, session: SessionMixin, response: Response)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/src/flask/signals.py,0,749
Arguments: []
Code: // Code for Global Scope
from __future__ import annotations
from blinker import Namespace
# This namespace is only for signals provided by Flask itself.
_signals = Namespace()
template_rendered = _signals.signal("template-rendered")
before_render_template = _signals.signal("before-render-template")
request_started = _signals.signal("request-started")
request_finished = _signals.signal("request-finished")
request_tearing_down = _signals.signal("request-tearing-down")
got_request_exception = _signals.signal("got-request-exception")
appcontext_tearing_down = _signals.signal("appcontext-tearing-down")
appcontext_pushed = _signals.signal("appcontext-pushed")
appcontext_popped = _signals.signal("appcontext-popped")
message_flashed = _signals.signal("message-flashed")

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/src/flask/views.py,0,6961
Arguments: []
Code: // Code for Global Scope
from __future__ import annotations
import typing as t
from . import typing as ft
from .globals import current_app
from .globals import request
F = t.TypeVar("F", bound=t.Callable[..., t.Any])
http_method_funcs = frozenset(
    ["get", "post", "head", "options", "delete", "put", "trace", "patch"]
)
# Code for class: View()
# Code for function: View.dispatch_request(self)
# Code for class: MethodView()
# Code for function: MethodView.__init_subclass__(cls, **kwargs: t.Any)
# Code for function: MethodView.dispatch_request(self, **kwargs: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: View
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/views.py,305,2640
Arguments: []
Code: class View:
    """Subclass this class and override :meth:`dispatch_request` to
    create a generic class-based view. Call :meth:`as_view` to create a
    view function that creates an instance of the class with the given
    arguments and calls its ``dispatch_request`` method with any URL
    variables.

    See :doc:`views` for a detailed guide.

    .. code-block:: python

        class Hello(View):
            init_every_request = False

            def dispatch_request(self, name):
                return f"Hello, {name}!"

        app.add_url_rule(
            "/hello/<name>", view_func=Hello.as_view("hello")
        )

    Set :attr:`methods` on the class to change what methods the view
    accepts.

    Set :attr:`decorators` on the class to apply a list of decorators to
    the generated view function. Decorators applied to the class itself
    will not be applied to the generated view function!

    Set :attr:`init_every_request` to ``False`` for efficiency, unless
    you need to store request-global data on ``self``.
    """

    #: The methods this view is registered for. Uses the same default
    #: (``["GET", "HEAD", "OPTIONS"]``) as ``route`` and
    #: ``add_url_rule`` by default.
    methods: t.ClassVar[t.Collection[str] | None] = None

    #: Control whether the ``OPTIONS`` method is handled automatically.
    #: Uses the same default (``True``) as ``route`` and
    #: ``add_url_rule`` by default.
    provide_automatic_options: t.ClassVar[bool | None] = None

    #: A list of decorators to apply, in order, to the generated view
    #: function. Remember that ``@decorator`` syntax is applied bottom
    #: to top, so the first decorator in the list would be the bottom
    #: decorator.
    #:
    #: .. versionadded:: 0.8
    decorators: t.ClassVar[list[t.Callable[..., t.Any]]] = []

    #: Create a new instance of this view class for every request by
    #: default. If a view subclass sets this to ``False``, the same
    #: instance is used for every request.
    #:
    #: A single instance is more efficient, especially if complex setup
    #: is done during init. However, storing data on ``self`` is no
    #: longer safe across requests, and :data:`~flask.g` should be used
    #: instead.
    #:
    #: .. versionadded:: 2.2
    init_every_request: t.ClassVar[bool] = True

    # Code for function: View.dispatch_request(self)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: dispatch_request
Type: function
Parent Type: View
Location: /home/yuesheng/flask/src/flask/views.py,2640,2927
Arguments: ['self']
Code: def dispatch_request(self) -> ft.ResponseReturnValue:
        """The actual view function behavior. Subclasses must override
        this and return a valid response. Any variables from the URL
        rule are passed as keyword arguments.
        """
        raise NotImplementedError()
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: MethodView
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/views.py,5146,5935
Arguments: []
Code: class MethodView(View):
    """Dispatches request methods to the corresponding instance methods.
    For example, if you implement a ``get`` method, it will be used to
    handle ``GET`` requests.

    This can be useful for defining a REST API.

    :attr:`methods` is automatically set based on the methods defined on
    the class.

    See :doc:`views` for a detailed guide.

    .. code-block:: python

        class CounterAPI(MethodView):
            def get(self):
                return str(session.get("counter", 0))

            def post(self):
                session["counter"] = session.get("counter", 0) + 1
                return redirect(url_for("counter"))

        app.add_url_rule(
            "/counter", view_func=CounterAPI.as_view("counter")
        )
    """

    # Code for function: MethodView.__init_subclass__(cls, **kwargs: t.Any)
# Code for function: MethodView.dispatch_request(self, **kwargs: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init_subclass__
Type: function
Parent Type: MethodView
Location: /home/yuesheng/flask/src/flask/views.py,5935,6461
Arguments: ['cls', '**kwargs: t.Any']
Code: def __init_subclass__(cls, **kwargs: t.Any) -> None:
        super().__init_subclass__(**kwargs)

        if "methods" not in cls.__dict__:
            methods = set()

            for base in cls.__bases__:
                if getattr(base, "methods", None):
                    methods.update(base.methods)  # type: ignore[attr-defined]

            for key in http_method_funcs:
                if hasattr(cls, key):
                    methods.add(key.upper())

            if methods:
                cls.methods = methods
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: dispatch_request
Type: function
Parent Type: MethodView
Location: /home/yuesheng/flask/src/flask/views.py,6467,6961
Arguments: ['self', '**kwargs: t.Any']
Code: def dispatch_request(self, **kwargs: t.Any) -> ft.ResponseReturnValue:
        meth = getattr(self, request.method.lower(), None)

        # If the request method is HEAD and we don't have a handler for it
        # retry with GET.
        if meth is None and request.method == "HEAD":
            meth = getattr(self, "get", None)

        assert meth is not None, f"Unimplemented method {request.method!r}"
        return current_app.ensure_sync(meth)(**kwargs)  # type: ignore[no-any-return]
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/src/flask/sansio/blueprints.py,0,24636
Arguments: []
Code: // Code for Global Scope
from __future__ import annotations
import os
import typing as t
from collections import defaultdict
from functools import update_wrapper
from .. import typing as ft
from .scaffold import _endpoint_from_view_func
from .scaffold import _sentinel
from .scaffold import Scaffold
from .scaffold import setupmethod
if t.TYPE_CHECKING:  # pragma: no cover
    from .app import App
DeferredSetupFunction = t.Callable[["BlueprintSetupState"], None]
T_after_request = t.TypeVar("T_after_request", bound=ft.AfterRequestCallable[t.Any])
T_before_request = t.TypeVar("T_before_request", bound=ft.BeforeRequestCallable)
T_error_handler = t.TypeVar("T_error_handler", bound=ft.ErrorHandlerCallable)
T_teardown = t.TypeVar("T_teardown", bound=ft.TeardownCallable)
T_template_context_processor = t.TypeVar(
    "T_template_context_processor", bound=ft.TemplateContextProcessorCallable
)
T_template_filter = t.TypeVar("T_template_filter", bound=ft.TemplateFilterCallable)
T_template_global = t.TypeVar("T_template_global", bound=ft.TemplateGlobalCallable)
T_template_test = t.TypeVar("T_template_test", bound=ft.TemplateTestCallable)
T_url_defaults = t.TypeVar("T_url_defaults", bound=ft.URLDefaultCallable)
T_url_value_preprocessor = t.TypeVar(
    "T_url_value_preprocessor", bound=ft.URLValuePreprocessorCallable
)
# Code for class: BlueprintSetupState(self, blueprint: Blueprint, app: App, options: t.Any, first_registration: bool, )
# Code for function: BlueprintSetupState.__init__(self, blueprint: Blueprint, app: App, options: t.Any, first_registration: bool, )
# Code for function: BlueprintSetupState.add_url_rule(self, rule: str, endpoint: str | None = None, view_func: ft.RouteCallable | None = None, **options: t.Any, )
# Code for class: Blueprint(self, name: str, import_name: str, static_folder: str | os.PathLike[str] | None = None, static_url_path: str | None = None, template_folder: str | os.PathLike[str] | None = None, url_prefix: str | None = None, subdomain: str | None = None, url_defaults: dict[str, t.Any] | None = None, root_path: str | None = None, cli_group: str | None = _sentinel, # type: ignore[assignment])
# Code for function: Blueprint.__init__(self, name: str, import_name: str, static_folder: str | os.PathLike[str] | None = None, static_url_path: str | None = None, template_folder: str | os.PathLike[str] | None = None, url_prefix: str | None = None, subdomain: str | None = None, url_defaults: dict[str, t.Any] | None = None, root_path: str | None = None, cli_group: str | None = _sentinel, # type: ignore[assignment])
# Code for function: Blueprint._check_setup_finished(self, f_name: str)
# Code for function: Blueprint.make_setup_state(self, app: App, options: dict[str, t.Any], first_registration: bool = False)
# Code for function: Blueprint.register(self, app: App, options: dict[str, t.Any])
# Code for function: Blueprint._merge_blueprint_funcs(self, app: App, name: str, bp_dict: dict[ft.AppOrBlueprintKey, list[t.Any]], parent_dict: dict[ft.AppOrBlueprintKey, list[t.Any]], )

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: BlueprintSetupState
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/sansio/blueprints.py,1306,1586
Arguments: ['self', 'blueprint: Blueprint', 'app: App', 'options: t.Any', 'first_registration: bool', '']
Code: class BlueprintSetupState:
    """Temporary holder object for registering a blueprint with the
    application.  An instance of this class is created by the
    :meth:`~flask.Blueprint.make_setup_state` method and later passed
    to all register callback functions.
    """

    # Code for function: BlueprintSetupState.__init__(self, blueprint: Blueprint, app: App, options: t.Any, first_registration: bool, )
# Code for function: BlueprintSetupState.add_url_rule(self, rule: str, endpoint: str | None = None, view_func: ft.RouteCallable | None = None, **options: t.Any, )

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: BlueprintSetupState
Location: /home/yuesheng/flask/src/flask/sansio/blueprints.py,1586,3313
Arguments: ['self', 'blueprint: Blueprint', 'app: App', 'options: t.Any', 'first_registration: bool', '']
Code: def __init__(
        self,
        blueprint: Blueprint,
        app: App,
        options: t.Any,
        first_registration: bool,
    ) -> None:
        #: a reference to the current application
        self.app = app

        #: a reference to the blueprint that created this setup state.
        self.blueprint = blueprint

        #: a dictionary with all options that were passed to the
        #: :meth:`~flask.Flask.register_blueprint` method.
        self.options = options

        #: as blueprints can be registered multiple times with the
        #: application and not everything wants to be registered
        #: multiple times on it, this attribute can be used to figure
        #: out if the blueprint was registered in the past already.
        self.first_registration = first_registration

        subdomain = self.options.get("subdomain")
        if subdomain is None:
            subdomain = self.blueprint.subdomain

        #: The subdomain that the blueprint should be active for, ``None``
        #: otherwise.
        self.subdomain = subdomain

        url_prefix = self.options.get("url_prefix")
        if url_prefix is None:
            url_prefix = self.blueprint.url_prefix
        #: The prefix that should be used for all URLs defined on the
        #: blueprint.
        self.url_prefix = url_prefix

        self.name = self.options.get("name", blueprint.name)
        self.name_prefix = self.options.get("name_prefix", "")

        #: A dictionary with URL defaults that is added to each and every
        #: URL that was defined with the blueprint.
        self.url_defaults = dict(self.blueprint.url_values_defaults)
        self.url_defaults.update(self.options.get("url_defaults", ()))
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: add_url_rule
Type: function
Parent Type: BlueprintSetupState
Location: /home/yuesheng/flask/src/flask/sansio/blueprints.py,3319,4394
Arguments: ['self', 'rule: str', 'endpoint: str | None = None', 'view_func: ft.RouteCallable | None = None', '**options: t.Any', '']
Code: def add_url_rule(
        self,
        rule: str,
        endpoint: str | None = None,
        view_func: ft.RouteCallable | None = None,
        **options: t.Any,
    ) -> None:
        """A helper method to register a rule (and optionally a view function)
        to the application.  The endpoint is automatically prefixed with the
        blueprint's name.
        """
        if self.url_prefix is not None:
            if rule:
                rule = "/".join((self.url_prefix.rstrip("/"), rule.lstrip("/")))
            else:
                rule = self.url_prefix
        options.setdefault("subdomain", self.subdomain)
        if endpoint is None:
            endpoint = _endpoint_from_view_func(view_func)  # type: ignore
        defaults = self.url_defaults
        if "defaults" in options:
            defaults = dict(defaults, **options.pop("defaults"))

        self.app.add_url_rule(
            rule,
            f"{self.name_prefix}.{self.name}.{endpoint}".lstrip("."),
            view_func,
            defaults=defaults,
            **options,
        )
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Blueprint
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/sansio/blueprints.py,4397,7005
Arguments: ['self', 'name: str', 'import_name: str', 'static_folder: str | os.PathLike[str] | None = None', 'static_url_path: str | None = None', 'template_folder: str | os.PathLike[str] | None = None', 'url_prefix: str | None = None', 'subdomain: str | None = None', 'url_defaults: dict[str', 't.Any] | None = None', 'root_path: str | None = None', 'cli_group: str | None = _sentinel', '# type: ignore[assignment]']
Code: class Blueprint(Scaffold):
    """Represents a blueprint, a collection of routes and other
    app-related functions that can be registered on a real application
    later.

    A blueprint is an object that allows defining application functions
    without requiring an application object ahead of time. It uses the
    same decorators as :class:`~flask.Flask`, but defers the need for an
    application by recording them for later registration.

    Decorating a function with a blueprint creates a deferred function
    that is called with :class:`~flask.blueprints.BlueprintSetupState`
    when the blueprint is registered on an application.

    See :doc:`/blueprints` for more information.

    :param name: The name of the blueprint. Will be prepended to each
        endpoint name.
    :param import_name: The name of the blueprint package, usually
        ``__name__``. This helps locate the ``root_path`` for the
        blueprint.
    :param static_folder: A folder with static files that should be
        served by the blueprint's static route. The path is relative to
        the blueprint's root path. Blueprint static files are disabled
        by default.
    :param static_url_path: The url to serve static files from.
        Defaults to ``static_folder``. If the blueprint does not have
        a ``url_prefix``, the app's static route will take precedence,
        and the blueprint's static files won't be accessible.
    :param template_folder: A folder with templates that should be added
        to the app's template search path. The path is relative to the
        blueprint's root path. Blueprint templates are disabled by
        default. Blueprint templates have a lower precedence than those
        in the app's templates folder.
    :param url_prefix: A path to prepend to all of the blueprint's URLs,
        to make them distinct from the rest of the app's routes.
    :param subdomain: A subdomain that blueprint routes will match on by
        default.
    :param url_defaults: A dict of default values that blueprint routes
        will receive by default.
    :param root_path: By default, the blueprint will automatically set
        this based on ``import_name``. In certain situations this
        automatic detection can fail, so the path can be specified
        manually instead.

    .. versionchanged:: 1.1.0
        Blueprints have a ``cli`` group to register nested CLI commands.
        The ``cli_group`` parameter controls the name of the group under
        the ``flask`` command.

    .. versionadded:: 0.7
    """

    _got_registered_once = False

    # Code for function: Blueprint.__init__(self, name: str, import_name: str, static_folder: str | os.PathLike[str] | None = None, static_url_path: str | None = None, template_folder: str | os.PathLike[str] | None = None, url_prefix: str | None = None, subdomain: str | None = None, url_defaults: dict[str, t.Any] | None = None, root_path: str | None = None, cli_group: str | None = _sentinel, # type: ignore[assignment])
# Code for function: Blueprint._check_setup_finished(self, f_name: str)
# Code for function: Blueprint.make_setup_state(self, app: App, options: dict[str, t.Any], first_registration: bool = False)
# Code for function: Blueprint.register(self, app: App, options: dict[str, t.Any])
# Code for function: Blueprint._merge_blueprint_funcs(self, app: App, name: str, bp_dict: dict[ft.AppOrBlueprintKey, list[t.Any]], parent_dict: dict[ft.AppOrBlueprintKey, list[t.Any]], )

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: Blueprint
Location: /home/yuesheng/flask/src/flask/sansio/blueprints.py,7005,8293
Arguments: ['self', 'name: str', 'import_name: str', 'static_folder: str | os.PathLike[str] | None = None', 'static_url_path: str | None = None', 'template_folder: str | os.PathLike[str] | None = None', 'url_prefix: str | None = None', 'subdomain: str | None = None', 'url_defaults: dict[str', 't.Any] | None = None', 'root_path: str | None = None', 'cli_group: str | None = _sentinel', '# type: ignore[assignment]']
Code: def __init__(
        self,
        name: str,
        import_name: str,
        static_folder: str | os.PathLike[str] | None = None,
        static_url_path: str | None = None,
        template_folder: str | os.PathLike[str] | None = None,
        url_prefix: str | None = None,
        subdomain: str | None = None,
        url_defaults: dict[str, t.Any] | None = None,
        root_path: str | None = None,
        cli_group: str | None = _sentinel,  # type: ignore[assignment]
    ):
        super().__init__(
            import_name=import_name,
            static_folder=static_folder,
            static_url_path=static_url_path,
            template_folder=template_folder,
            root_path=root_path,
        )

        if not name:
            raise ValueError("'name' may not be empty.")

        if "." in name:
            raise ValueError("'name' may not contain a dot '.' character.")

        self.name = name
        self.url_prefix = url_prefix
        self.subdomain = subdomain
        self.deferred_functions: list[DeferredSetupFunction] = []

        if url_defaults is None:
            url_defaults = {}

        self.url_values_defaults = url_defaults
        self.cli_group = cli_group
        self._blueprints: list[tuple[Blueprint, dict[str, t.Any]]] = []
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _check_setup_finished
Type: function
Parent Type: Blueprint
Location: /home/yuesheng/flask/src/flask/sansio/blueprints.py,8299,8825
Arguments: ['self', 'f_name: str']
Code: def _check_setup_finished(self, f_name: str) -> None:
        if self._got_registered_once:
            raise AssertionError(
                f"The setup method '{f_name}' can no longer be called on the blueprint"
                f" '{self.name}'. It has already been registered at least once, any"
                " changes will not be applied consistently.\n"
                "Make sure all imports, decorators, functions, etc. needed to set up"
                " the blueprint are done before registering it."
            )
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: make_setup_state
Type: function
Parent Type: Blueprint
Location: /home/yuesheng/flask/src/flask/sansio/blueprints.py,9722,10174
Arguments: ['self', 'app: App', 'options: dict[str', 't.Any]', 'first_registration: bool = False']
Code: def make_setup_state(
        self, app: App, options: dict[str, t.Any], first_registration: bool = False
    ) -> BlueprintSetupState:
        """Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`
        object that is later passed to the register callback functions.
        Subclasses can override this to return a subclass of the setup state.
        """
        return BlueprintSetupState(self, app, options, first_registration)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: register
Type: function
Parent Type: Blueprint
Location: /home/yuesheng/flask/src/flask/sansio/blueprints.py,10928,15259
Arguments: ['self', 'app: App', 'options: dict[str', 't.Any]']
Code: def register(self, app: App, options: dict[str, t.Any]) -> None:
        """Called by :meth:`Flask.register_blueprint` to register all
        views and callbacks registered on the blueprint with the
        application. Creates a :class:`.BlueprintSetupState` and calls
        each :meth:`record` callback with it.

        :param app: The application this blueprint is being registered
            with.
        :param options: Keyword arguments forwarded from
            :meth:`~Flask.register_blueprint`.

        .. versionchanged:: 2.3
            Nested blueprints now correctly apply subdomains.

        .. versionchanged:: 2.1
            Registering the same blueprint with the same name multiple
            times is an error.

        .. versionchanged:: 2.0.1
            Nested blueprints are registered with their dotted name.
            This allows different blueprints with the same name to be
            nested at different locations.

        .. versionchanged:: 2.0.1
            The ``name`` option can be used to change the (pre-dotted)
            name the blueprint is registered with. This allows the same
            blueprint to be registered multiple times with unique names
            for ``url_for``.
        """
        name_prefix = options.get("name_prefix", "")
        self_name = options.get("name", self.name)
        name = f"{name_prefix}.{self_name}".lstrip(".")

        if name in app.blueprints:
            bp_desc = "this" if app.blueprints[name] is self else "a different"
            existing_at = f" '{name}'" if self_name != name else ""

            raise ValueError(
                f"The name '{self_name}' is already registered for"
                f" {bp_desc} blueprint{existing_at}. Use 'name=' to"
                f" provide a unique name."
            )

        first_bp_registration = not any(bp is self for bp in app.blueprints.values())
        first_name_registration = name not in app.blueprints

        app.blueprints[name] = self
        self._got_registered_once = True
        state = self.make_setup_state(app, options, first_bp_registration)

        if self.has_static_folder:
            state.add_url_rule(
                f"{self.static_url_path}/<path:filename>",
                view_func=self.send_static_file,  # type: ignore[attr-defined]
                endpoint="static",
            )

        # Merge blueprint data into parent.
        if first_bp_registration or first_name_registration:
            self._merge_blueprint_funcs(app, name)

        for deferred in self.deferred_functions:
            deferred(state)

        cli_resolved_group = options.get("cli_group", self.cli_group)

        if self.cli.commands:
            if cli_resolved_group is None:
                app.cli.commands.update(self.cli.commands)
            elif cli_resolved_group is _sentinel:
                self.cli.name = name
                app.cli.add_command(self.cli)
            else:
                self.cli.name = cli_resolved_group
                app.cli.add_command(self.cli)

        for blueprint, bp_options in self._blueprints:
            bp_options = bp_options.copy()
            bp_url_prefix = bp_options.get("url_prefix")
            bp_subdomain = bp_options.get("subdomain")

            if bp_subdomain is None:
                bp_subdomain = blueprint.subdomain

            if state.subdomain is not None and bp_subdomain is not None:
                bp_options["subdomain"] = bp_subdomain + "." + state.subdomain
            elif bp_subdomain is not None:
                bp_options["subdomain"] = bp_subdomain
            elif state.subdomain is not None:
                bp_options["subdomain"] = state.subdomain

            if bp_url_prefix is None:
                bp_url_prefix = blueprint.url_prefix

            if state.url_prefix is not None and bp_url_prefix is not None:
                bp_options["url_prefix"] = (
                    state.url_prefix.rstrip("/") + "/" + bp_url_prefix.lstrip("/")
                )
            elif bp_url_prefix is not None:
                bp_options["url_prefix"] = bp_url_prefix
            elif state.url_prefix is not None:
                bp_options["url_prefix"] = state.url_prefix

            bp_options["name_prefix"] = name
            blueprint.register(app, bp_options)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _merge_blueprint_funcs
Type: function
Parent Type: Blueprint
Location: /home/yuesheng/flask/src/flask/sansio/blueprints.py,15265,16648
Arguments: ['self', 'app: App', 'name: str', 'bp_dict: dict[ft.AppOrBlueprintKey', 'list[t.Any]]', 'parent_dict: dict[ft.AppOrBlueprintKey', 'list[t.Any]]', '']
Code: def _merge_blueprint_funcs(self, app: App, name: str) -> None:
        def extend(
            bp_dict: dict[ft.AppOrBlueprintKey, list[t.Any]],
            parent_dict: dict[ft.AppOrBlueprintKey, list[t.Any]],
        ) -> None:
            for key, values in bp_dict.items():
                key = name if key is None else f"{name}.{key}"
                parent_dict[key].extend(values)

        for key, value in self.error_handler_spec.items():
            key = name if key is None else f"{name}.{key}"
            value = defaultdict(
                dict,
                {
                    code: {exc_class: func for exc_class, func in code_values.items()}
                    for code, code_values in value.items()
                },
            )
            app.error_handler_spec[key] = value

        for endpoint, func in self.view_functions.items():
            app.view_functions[endpoint] = func

        extend(self.before_request_funcs, app.before_request_funcs)
        extend(self.after_request_funcs, app.after_request_funcs)
        extend(
            self.teardown_request_funcs,
            app.teardown_request_funcs,
        )
        extend(self.url_default_functions, app.url_default_functions)
        extend(self.url_value_preprocessors, app.url_value_preprocessors)
        extend(self.template_context_processors, app.template_context_processors)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _make_timedelta
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/sansio/app.py,1742,1925
Arguments: ['value: timedelta | int | None']
Code: def __init__(
        self,
        import_name: str,
        static_url_path: str | None = None,
        static_folder: str | os.PathLike[str] | None = "static",
        static_host: str | None = None,
        host_matching: bool = False,
        subdomain_matching: bool = False,
        template_folder: str | os.PathLike[str] | None = "templates",
        instance_path: str | None = None,
        instance_relative_config: bool = False,
        root_path: str | None = None,
    ) -> None:
        super().__init__(
            import_name=import_name,
            static_folder=static_folder,
            static_url_path=static_url_path,
            template_folder=template_folder,
            root_path=root_path,
        )

        if instance_path is None:
            instance_path = self.auto_find_instance_path()
        elif not os.path.isabs(instance_path):
            raise ValueError(
                "If an instance path is provided it must be absolute."
                " A relative path was given instead."
            )

        #: Holds the path to the instance folder.
        #:
        #: .. versionadded:: 0.8
        self.instance_path = instance_path

        #: The configuration dictionary as :class:`Config`.  This behaves
        #: exactly like a regular dictionary but supports additional methods
        #: to load a config from files.
        self.config = self.make_config(instance_relative_config)

        #: An instance of :attr:`aborter_class` created by
        #: :meth:`make_aborter`. This is called by :func:`flask.abort`
        #: to raise HTTP errors, and can be called directly as well.
        #:
        #: .. versionadded:: 2.2
        #:     Moved from ``flask.abort``, which calls this object.
        self.aborter = self.make_aborter()

        self.json: JSONProvider = self.json_provider_class(self)
        """Provides access to JSON methods. Functions in ``flask.json``
        will call methods on this provider when the application context
        is active. Used for handling JSON requests and responses.

        An instance of :attr:`json_provider_class`. Can be customized by
        changing that attribute on a subclass, or by assigning to this
        attribute afterwards.

        The default, :class:`~flask.json.provider.DefaultJSONProvider`,
        uses Python's built-in :mod:`json` library. A different provider
        can use a different JSON library.

        .. versionadded:: 2.2
        """

        #: A list of functions that are called by
        #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a
        #: :exc:`~werkzeug.routing.BuildError`. Each function is called
        #: with ``error``, ``endpoint`` and ``values``. If a function
        #: returns ``None`` or raises a ``BuildError``, it is skipped.
        #: Otherwise, its return value is returned by ``url_for``.
        #:
        #: .. versionadded:: 0.9
        self.url_build_error_handlers: list[
            t.Callable[[Exception, str, dict[str, t.Any]], str]
        ] = []

        #: A list of functions that are called when the application context
        #: is destroyed.  Since the application context is also torn down
        #: if the request ends this is the place to store code that disconnects
        #: from databases.
        #:
        #: .. versionadded:: 0.9
        self.teardown_appcontext_funcs: list[ft.TeardownCallable] = []

        #: A list of shell context processor functions that should be run
        #: when a shell context is created.
        #:
        #: .. versionadded:: 0.11
        self.shell_context_processors: list[ft.ShellContextProcessorCallable] = []

        #: Maps registered blueprint names to blueprint objects. The
        #: dict retains the order the blueprints were registered in.
        #: Blueprints can be registered multiple times, this dict does
        #: not track how often they were attached.
        #:
        #: .. versionadded:: 0.7
        self.blueprints: dict[str, Blueprint] = {}

        #: a place where extensions can store application specific state.  For
        #: example this is where an extension could store database engines and
        #: similar things.
        #:
        #: The key must match the name of the extension module. For example in
        #: case of a "Flask-Foo" extension in `flask_foo`, the key would be
        #: ``'foo'``.
        #:
        #: .. versionadded:: 0.7
        self.extensions: dict[str, t.Any] = {}

        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug.routing import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(super(ListConverter, self).to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = self.url_map_class(host_matching=host_matching)

        self.subdomain_matching = subdomain_matching

        # tracks internally if the application already handled at least one
        # request.
        self._got_first_request = False
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: App
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/sansio/app.py,1928,11788
Arguments: ['self', 'import_name: str', 'static_url_path: str | None = None', 'static_folder: str | os.PathLike[str] | None = "static"', 'static_host: str | None = None', 'host_matching: bool = False', 'subdomain_matching: bool = False', 'template_folder: str | os.PathLike[str] | None = "templates"', 'instance_path: str | None = None', 'instance_relative_config: bool = False', 'root_path: str | None = None', '']
Code: // Code for Global Scope
from __future__ import annotations
import logging
import os
import sys
import typing as t
from datetime import timedelta
from itertools import chain
from werkzeug.exceptions import Aborter
from werkzeug.exceptions import BadRequest
from werkzeug.exceptions import BadRequestKeyError
from werkzeug.routing import BuildError
from werkzeug.routing import Map
from werkzeug.routing import Rule
from werkzeug.sansio.response import Response
from werkzeug.utils import cached_property
from werkzeug.utils import redirect as _wz_redirect
from .. import typing as ft
from ..config import Config
from ..config import ConfigAttribute
from ..ctx import _AppCtxGlobals
from ..helpers import _split_blueprint_path
from ..helpers import get_debug_flag
from ..json.provider import DefaultJSONProvider
from ..json.provider import JSONProvider
from ..logging import create_logger
from ..templating import DispatchingJinjaLoader
from ..templating import Environment
from .scaffold import _endpoint_from_view_func
from .scaffold import find_package
from .scaffold import Scaffold
from .scaffold import setupmethod
if t.TYPE_CHECKING:  # pragma: no cover
    from werkzeug.wrappers import Response as BaseResponse

    from ..testing import FlaskClient
    from ..testing import FlaskCliRunner
    from .blueprints import Blueprint
T_shell_context_processor = t.TypeVar(
    "T_shell_context_processor", bound=ft.ShellContextProcessorCallable
)
T_teardown = t.TypeVar("T_teardown", bound=ft.TeardownCallable)
T_template_filter = t.TypeVar("T_template_filter", bound=ft.TemplateFilterCallable)
T_template_global = t.TypeVar("T_template_global", bound=ft.TemplateGlobalCallable)
T_template_test = t.TypeVar("T_template_test", bound=ft.TemplateTestCallable)
# Code for function: _make_timedelta(value: timedelta | int | None)
# Code for class: App(self, import_name: str, static_url_path: str | None = None, static_folder: str | os.PathLike[str] | None = "static", static_host: str | None = None, host_matching: bool = False, subdomain_matching: bool = False, template_folder: str | os.PathLike[str] | None = "templates", instance_path: str | None = None, instance_relative_config: bool = False, root_path: str | None = None, )
# Code for function: App.__init__(self, import_name: str, static_url_path: str | None = None, static_folder: str | os.PathLike[str] | None = "static", static_host: str | None = None, host_matching: bool = False, subdomain_matching: bool = False, template_folder: str | os.PathLike[str] | None = "templates", instance_path: str | None = None, instance_relative_config: bool = False, root_path: str | None = None, )
# Code for function: App._check_setup_finished(self, f_name: str)
# Code for function: App.create_jinja_environment(self)
# Code for function: App.make_config(self, instance_relative: bool = False)
# Code for function: App.make_aborter(self)
# Code for function: App.auto_find_instance_path(self)
# Code for function: App.create_global_jinja_loader(self)
# Code for function: App.select_jinja_autoescape(self, filename: str)
# Code for function: App.iter_blueprints(self)
# Code for function: App._find_error_handler(self, e: Exception, blueprints: list[str])
# Code for function: App.trap_http_exception(self, e: Exception)
# Code for function: App.should_ignore_error(self, error: BaseException | None)
# Code for function: App.redirect(self, location: str, code: int = 302)
# Code for function: App.inject_url_defaults(self, endpoint: str, values: dict[str, t.Any])
# Code for function: App.handle_url_build_error(self, error: BuildError, endpoint: str, values: dict[str, t.Any])

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: App
Location: /home/yuesheng/flask/src/flask/sansio/app.py,11788,17261
Arguments: ['self', 'import_name: str', 'static_url_path: str | None = None', 'static_folder: str | os.PathLike[str] | None = "static"', 'static_host: str | None = None', 'host_matching: bool = False', 'subdomain_matching: bool = False', 'template_folder: str | os.PathLike[str] | None = "templates"', 'instance_path: str | None = None', 'instance_relative_config: bool = False', 'root_path: str | None = None', '']
Code: def _check_setup_finished(self, f_name: str) -> None:
        if self._got_first_request:
            raise AssertionError(
                f"The setup method '{f_name}' can no longer be called"
                " on the application. It has already handled its first"
                " request, any changes will not be applied"
                " consistently.\n"
                "Make sure all imports, decorators, functions, etc."
                " needed to set up the application are done before"
                " running it."
            )
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _check_setup_finished
Type: function
Parent Type: App
Location: /home/yuesheng/flask/src/flask/sansio/app.py,17267,17810
Arguments: ['self', 'f_name: str']
Code: def create_jinja_environment(self) -> Environment:
        raise NotImplementedError()
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: create_jinja_environment
Type: function
Parent Type: App
Location: /home/yuesheng/flask/src/flask/sansio/app.py,19926,20012
Arguments: ['self']
Code: def make_config(self, instance_relative: bool = False) -> Config:
        """Used to create the config attribute by the Flask constructor.
        The `instance_relative` parameter is passed in from the constructor
        of Flask (there named `instance_relative_config`) and indicates if
        the config should be relative to the instance path or the root path
        of the application.

        .. versionadded:: 0.8
        """
        root_path = self.root_path
        if instance_relative:
            root_path = self.instance_path
        defaults = dict(self.default_config)
        defaults["DEBUG"] = get_debug_flag()
        return self.config_class(root_path, defaults)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: make_config
Type: function
Parent Type: App
Location: /home/yuesheng/flask/src/flask/sansio/app.py,20018,20706
Arguments: ['self', 'instance_relative: bool = False']
Code: def make_aborter(self) -> Aborter:
        """Create the object to assign to :attr:`aborter`. That object
        is called by :func:`flask.abort` to raise HTTP errors, and can
        be called directly as well.

        By default, this creates an instance of :attr:`aborter_class`,
        which defaults to :class:`werkzeug.exceptions.Aborter`.

        .. versionadded:: 2.2
        """
        return self.aborter_class()
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: make_aborter
Type: function
Parent Type: App
Location: /home/yuesheng/flask/src/flask/sansio/app.py,20712,21139
Arguments: ['self']
Code: def auto_find_instance_path(self) -> str:
        """Tries to locate the instance path if it was not provided to the
        constructor of the application class.  It will basically calculate
        the path to a folder named ``instance`` next to your main file or
        the package.

        .. versionadded:: 0.8
        """
        prefix, package_path = find_package(self.import_name)
        if prefix is None:
            return os.path.join(package_path, "instance")
        return os.path.join(prefix, "var", f"{self.name}-instance")
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: auto_find_instance_path
Type: function
Parent Type: App
Location: /home/yuesheng/flask/src/flask/sansio/app.py,21145,21689
Arguments: ['self']
Code: def create_global_jinja_loader(self) -> DispatchingJinjaLoader:
        """Creates the loader for the Jinja2 environment.  Can be used to
        override just the loader and keeping the rest unchanged.  It's
        discouraged to override this function.  Instead one should override
        the :meth:`jinja_loader` function instead.

        The global loader dispatches between the loaders of the application
        and the individual blueprints.

        .. versionadded:: 0.7
        """
        return DispatchingJinjaLoader(self)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: create_global_jinja_loader
Type: function
Parent Type: App
Location: /home/yuesheng/flask/src/flask/sansio/app.py,21695,22233
Arguments: ['self']
Code: def select_jinja_autoescape(self, filename: str) -> bool:
        """Returns ``True`` if autoescaping should be active for the given
        template name. If no template name is given, returns `True`.

        .. versionchanged:: 2.2
            Autoescaping is now enabled by default for ``.svg`` files.

        .. versionadded:: 0.5
        """
        if filename is None:
            return True
        return filename.endswith((".html", ".htm", ".xml", ".xhtml", ".svg"))
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: select_jinja_autoescape
Type: function
Parent Type: App
Location: /home/yuesheng/flask/src/flask/sansio/app.py,22239,22718
Arguments: ['self', 'filename: str']
Code: def iter_blueprints(self) -> t.ValuesView[Blueprint]:
        """Iterates over all blueprints by the order they were registered.

        .. versionadded:: 0.11
        """
        return self.blueprints.values()
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: iter_blueprints
Type: function
Parent Type: App
Location: /home/yuesheng/flask/src/flask/sansio/app.py,24772,24984
Arguments: ['self']
Code: def _find_error_handler(
        self, e: Exception, blueprints: list[str]
    ) -> ft.ErrorHandlerCallable | None:
        """Return a registered error handler for an exception in this order:
        blueprint handler for a specific code, app handler for a specific code,
        blueprint handler for an exception class, app handler for an exception
        class, or ``None`` if a suitable handler is not found.
        """
        exc_class, code = self._get_exc_class_and_code(type(e))
        names = (*blueprints, None)

        for c in (code, None) if code is not None else (None,):
            for name in names:
                handler_map = self.error_handler_spec[name][c]

                if not handler_map:
                    continue

                for cls in exc_class.__mro__:
                    handler = handler_map.get(cls)

                    if handler is not None:
                        return handler
        return None
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _find_error_handler
Type: function
Parent Type: App
Location: /home/yuesheng/flask/src/flask/sansio/app.py,32777,33730
Arguments: ['self', 'e: Exception', 'blueprints: list[str]']
Code: def trap_http_exception(self, e: Exception) -> bool:
        """Checks if an HTTP exception should be trapped or not.  By default
        this will return ``False`` for all exceptions except for a bad request
        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It
        also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.

        This is called for all HTTP exceptions raised by a view function.
        If it returns ``True`` for any exception the error handler for this
        exception is not called and it shows up as regular exception in the
        traceback.  This is helpful for debugging implicitly raised HTTP
        exceptions.

        .. versionchanged:: 1.0
            Bad request errors are not trapped by default in debug mode.

        .. versionadded:: 0.8
        """
        if self.config["TRAP_HTTP_EXCEPTIONS"]:
            return True

        trap_bad_request = self.config["TRAP_BAD_REQUEST_ERRORS"]

        # if unset, trap key errors in debug mode
        if (
            trap_bad_request is None
            and self.debug
            and isinstance(e, BadRequestKeyError)
        ):
            return True

        if trap_bad_request:
            return isinstance(e, BadRequest)

        return False
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: trap_http_exception
Type: function
Parent Type: App
Location: /home/yuesheng/flask/src/flask/sansio/app.py,33736,35013
Arguments: ['self', 'e: Exception']
Code: def should_ignore_error(self, error: BaseException | None) -> bool:
        """This is called to figure out if an error should be ignored
        or not as far as the teardown system is concerned.  If this
        function returns ``True`` then the teardown handlers will not be
        passed the error.

        .. versionadded:: 0.10
        """
        return False
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: should_ignore_error
Type: function
Parent Type: App
Location: /home/yuesheng/flask/src/flask/sansio/app.py,35019,35388
Arguments: ['self', 'error: BaseException | None']
Code: def redirect(self, location: str, code: int = 302) -> BaseResponse:
        """Create a redirect response object.

        This is called by :func:`flask.redirect`, and can be called
        directly as well.

        :param location: The URL to redirect to.
        :param code: The status code for the redirect.

        .. versionadded:: 2.2
            Moved from ``flask.redirect``, which calls this method.
        """
        return _wz_redirect(
            location,
            code=code,
            Response=self.response_class,  # type: ignore[arg-type]
        )
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: redirect
Type: function
Parent Type: App
Location: /home/yuesheng/flask/src/flask/sansio/app.py,35394,35970
Arguments: ['self', 'location: str', 'code: int = 302']
Code: def inject_url_defaults(self, endpoint: str, values: dict[str, t.Any]) -> None:
        """Injects the URL defaults for the given endpoint directly into
        the values dictionary passed.  This is used internally and
        automatically called on URL building.

        .. versionadded:: 0.7
        """
        names: t.Iterable[str | None] = (None,)

        # url_for may be called outside a request context, parse the
        # passed endpoint instead of using request.blueprints.
        if "." in endpoint:
            names = chain(
                names, reversed(_split_blueprint_path(endpoint.rpartition(".")[0]))
            )

        for name in names:
            if name in self.url_default_functions:
                for func in self.url_default_functions[name]:
                    func(endpoint, values)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: inject_url_defaults
Type: function
Parent Type: App
Location: /home/yuesheng/flask/src/flask/sansio/app.py,35976,36802
Arguments: ['self', 'endpoint: str', 'values: dict[str', 't.Any]']
Code: def handle_url_build_error(
        self, error: BuildError, endpoint: str, values: dict[str, t.Any]
    ) -> str:
        """Called by :meth:`.url_for` if a
        :exc:`~werkzeug.routing.BuildError` was raised. If this returns
        a value, it will be returned by ``url_for``, otherwise the error
        will be re-raised.

        Each function in :attr:`url_build_error_handlers` is called with
        ``error``, ``endpoint`` and ``values``. If a function returns
        ``None`` or raises a ``BuildError``, it is skipped. Otherwise,
        its return value is returned by ``url_for``.

        :param error: The active ``BuildError`` being handled.
        :param endpoint: The endpoint being built.
        :param values: The keyword arguments passed to ``url_for``.
        """
        for handler in self.url_build_error_handlers:
            try:
                rv = handler(error, endpoint, values)
            except BuildError as e:
                # make error available outside except block
                error = e
            else:
                if rv is not None:
                    return rv

        # Re-raise if called with an active exception, otherwise raise
        # the passed in exception.
        if error is sys.exc_info()[1]:
            raise

        raise error
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: handle_url_build_error
Type: function
Parent Type: App
Location: /home/yuesheng/flask/src/flask/sansio/app.py,36808,38115
Arguments: ['self', 'error: BuildError', 'endpoint: str', 'values: dict[str', 't.Any]']
Code: class App(Scaffold):
    """The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the :file:`__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)

    .. admonition:: About the First Parameter

        The idea of the first parameter is to give Flask an idea of what
        belongs to your application.  This name is used to find resources
        on the filesystem, can be used by extensions to improve debugging
        information and a lot more.

        So it's important what you provide there.  If you are using a single
        module, `__name__` is always the correct value.  If you however are
        using a package, it's usually recommended to hardcode the name of
        your package there.

        For example if your application is defined in :file:`yourapplication/app.py`
        you should create it with one of the two versions below::

            app = Flask('yourapplication')
            app = Flask(__name__.split('.')[0])

        Why is that?  The application will work even with `__name__`, thanks
        to how resources are looked up.  However it will make debugging more
        painful.  Certain extensions can make assumptions based on the
        import name of your application.  For example the Flask-SQLAlchemy
        extension will look for the code in your application that triggered
        an SQL query in debug mode.  If the import name is not properly set
        up, that debugging information is lost.  (For example it would only
        pick up SQL queries in `yourapplication.app` and not
        `yourapplication.views.frontend`)

    .. versionadded:: 0.7
       The `static_url_path`, `static_folder`, and `template_folder`
       parameters were added.

    .. versionadded:: 0.8
       The `instance_path` and `instance_relative_config` parameters were
       added.

    .. versionadded:: 0.11
       The `root_path` parameter was added.

    .. versionadded:: 1.0
       The ``host_matching`` and ``static_host`` parameters were added.

    .. versionadded:: 1.0
       The ``subdomain_matching`` parameter was added. Subdomain
       matching needs to be enabled manually now. Setting
       :data:`SERVER_NAME` does not implicitly enable it.

    :param import_name: the name of the application package
    :param static_url_path: can be used to specify a different path for the
                            static files on the web.  Defaults to the name
                            of the `static_folder` folder.
    :param static_folder: The folder with static files that is served at
        ``static_url_path``. Relative to the application ``root_path``
        or an absolute path. Defaults to ``'static'``.
    :param static_host: the host to use when adding the static route.
        Defaults to None. Required when using ``host_matching=True``
        with a ``static_folder`` configured.
    :param host_matching: set ``url_map.host_matching`` attribute.
        Defaults to False.
    :param subdomain_matching: consider the subdomain relative to
        :data:`SERVER_NAME` when matching routes. Defaults to False.
    :param template_folder: the folder that contains the templates that should
                            be used by the application.  Defaults to
                            ``'templates'`` folder in the root path of the
                            application.
    :param instance_path: An alternative instance path for the application.
                          By default the folder ``'instance'`` next to the
                          package or module is assumed to be the instance
                          path.
    :param instance_relative_config: if set to ``True`` relative filenames
                                     for loading the config are assumed to
                                     be relative to the instance path instead
                                     of the application root.
    :param root_path: The path to the root of the application files.
        This should only be set manually when it can't be detected
        automatically, such as for namespace packages.
    """

    #: The class of the object assigned to :attr:`aborter`, created by
    #: :meth:`create_aborter`. That object is called by
    #: :func:`flask.abort` to raise HTTP errors, and can be
    #: called directly as well.
    #:
    #: Defaults to :class:`werkzeug.exceptions.Aborter`.
    #:
    #: .. versionadded:: 2.2
    aborter_class = Aborter

    #: The class that is used for the Jinja environment.
    #:
    #: .. versionadded:: 0.11
    jinja_environment = Environment

    #: The class that is used for the :data:`~flask.g` instance.
    #:
    #: Example use cases for a custom class:
    #:
    #: 1. Store arbitrary attributes on flask.g.
    #: 2. Add a property for lazy per-request database connectors.
    #: 3. Return None instead of AttributeError on unexpected attributes.
    #: 4. Raise exception if an unexpected attr is set, a "controlled" flask.g.
    #:
    #: In Flask 0.9 this property was called `request_globals_class` but it
    #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the
    #: flask.g object is now application context scoped.
    #:
    #: .. versionadded:: 0.10
    app_ctx_globals_class = _AppCtxGlobals

    #: The class that is used for the ``config`` attribute of this app.
    #: Defaults to :class:`~flask.Config`.
    #:
    #: Example use cases for a custom class:
    #:
    #: 1. Default values for certain config options.
    #: 2. Access to config values through attributes in addition to keys.
    #:
    #: .. versionadded:: 0.11
    config_class = Config

    #: The testing flag.  Set this to ``True`` to enable the test mode of
    #: Flask extensions (and in the future probably also Flask itself).
    #: For example this might activate test helpers that have an
    #: additional runtime cost which should not be enabled by default.
    #:
    #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the
    #: default it's implicitly enabled.
    #:
    #: This attribute can also be configured from the config with the
    #: ``TESTING`` configuration key.  Defaults to ``False``.
    testing = ConfigAttribute[bool]("TESTING")

    #: If a secret key is set, cryptographic components can use this to
    #: sign cookies and other things. Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    #:
    #: This attribute can also be configured from the config with the
    #: :data:`SECRET_KEY` configuration key. Defaults to ``None``.
    secret_key = ConfigAttribute[t.Union[str, bytes, None]]("SECRET_KEY")

    #: A :class:`~datetime.timedelta` which is used to set the expiration
    #: date of a permanent session.  The default is 31 days which makes a
    #: permanent session survive for roughly one month.
    #:
    #: This attribute can also be configured from the config with the
    #: ``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to
    #: ``timedelta(days=31)``
    permanent_session_lifetime = ConfigAttribute[timedelta](
        "PERMANENT_SESSION_LIFETIME",
        get_converter=_make_timedelta,  # type: ignore[arg-type]
    )

    json_provider_class: type[JSONProvider] = DefaultJSONProvider
    """A subclass of :class:`~flask.json.provider.JSONProvider`. An
    instance is created and assigned to :attr:`app.json` when creating
    the app.

    The default, :class:`~flask.json.provider.DefaultJSONProvider`, uses
    Python's built-in :mod:`json` library. A different provider can use
    a different JSON library.

    .. versionadded:: 2.2
    """

    #: Options that are passed to the Jinja environment in
    #: :meth:`create_jinja_environment`. Changing these options after
    #: the environment is created (accessing :attr:`jinja_env`) will
    #: have no effect.
    #:
    #: .. versionchanged:: 1.1.0
    #:     This is a ``dict`` instead of an ``ImmutableDict`` to allow
    #:     easier configuration.
    #:
    jinja_options: dict[str, t.Any] = {}

    #: The rule object to use for URL rules created.  This is used by
    #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.
    #:
    #: .. versionadded:: 0.7
    url_rule_class = Rule

    #: The map object to use for storing the URL rules and routing
    #: configuration parameters. Defaults to :class:`werkzeug.routing.Map`.
    #:
    #: .. versionadded:: 1.1.0
    url_map_class = Map

    #: The :meth:`test_client` method creates an instance of this test
    #: client class. Defaults to :class:`~flask.testing.FlaskClient`.
    #:
    #: .. versionadded:: 0.7
    test_client_class: type[FlaskClient] | None = None

    #: The :class:`~click.testing.CliRunner` subclass, by default
    #: :class:`~flask.testing.FlaskCliRunner` that is used by
    #: :meth:`test_cli_runner`. Its ``__init__`` method should take a
    #: Flask app object as the first argument.
    #:
    #: .. versionadded:: 1.0
    test_cli_runner_class: type[FlaskCliRunner] | None = None

    default_config: dict[str, t.Any]
    response_class: type[Response]

    # Code for function: App.__init__(self, import_name: str, static_url_path: str | None = None, static_folder: str | os.PathLike[str] | None = "static", static_host: str | None = None, host_matching: bool = False, subdomain_matching: bool = False, template_folder: str | os.PathLike[str] | None = "templates", instance_path: str | None = None, instance_relative_config: bool = False, root_path: str | None = None, )
# Code for function: App._check_setup_finished(self, f_name: str)
# Code for function: App.create_jinja_environment(self)
# Code for function: App.make_config(self, instance_relative: bool = False)
# Code for function: App.make_aborter(self)
# Code for function: App.auto_find_instance_path(self)
# Code for function: App.create_global_jinja_loader(self)
# Code for function: App.select_jinja_autoescape(self, filename: str)
# Code for function: App.iter_blueprints(self)
# Code for function: App._find_error_handler(self, e: Exception, blueprints: list[str])
# Code for function: App.trap_http_exception(self, e: Exception)
# Code for function: App.should_ignore_error(self, error: BaseException | None)
# Code for function: App.redirect(self, location: str, code: int = 302)
# Code for function: App.inject_url_defaults(self, endpoint: str, values: dict[str, t.Any])
# Code for function: App.handle_url_build_error(self, error: BuildError, endpoint: str, values: dict[str, t.Any])

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: setupmethod
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/sansio/scaffold.py,1379,1647
Arguments: ['f: F', 'self: Scaffold', '*args: t.Any', '**kwargs: t.Any']
Code: def __init__(
        self,
        import_name: str,
        static_folder: str | os.PathLike[str] | None = None,
        static_url_path: str | None = None,
        template_folder: str | os.PathLike[str] | None = None,
        root_path: str | None = None,
    ):
        #: The name of the package or module that this object belongs
        #: to. Do not change this once it is set by the constructor.
        self.import_name = import_name

        self.static_folder = static_folder  # type: ignore
        self.static_url_path = static_url_path

        #: The path to the templates folder, relative to
        #: :attr:`root_path`, to add to the template loader. ``None`` if
        #: templates should not be added.
        self.template_folder = template_folder

        if root_path is None:
            root_path = get_root_path(self.import_name)

        #: Absolute path to the package on the filesystem. Used to look
        #: up resources contained in the package.
        self.root_path = root_path

        #: A dictionary mapping endpoint names to view functions.
        #:
        #: To register a view function, use the :meth:`route` decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.view_functions: dict[str, ft.RouteCallable] = {}

        #: A data structure of registered error handlers, in the format
        #: ``{scope: {code: {class: handler}}}``. The ``scope`` key is
        #: the name of a blueprint the handlers are active for, or
        #: ``None`` for all requests. The ``code`` key is the HTTP
        #: status code for ``HTTPException``, or ``None`` for
        #: other exceptions. The innermost dictionary maps exception
        #: classes to handler functions.
        #:
        #: To register an error handler, use the :meth:`errorhandler`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.error_handler_spec: dict[
            ft.AppOrBlueprintKey,
            dict[int | None, dict[type[Exception], ft.ErrorHandlerCallable]],
        ] = defaultdict(lambda: defaultdict(dict))

        #: A data structure of functions to call at the beginning of
        #: each request, in the format ``{scope: [functions]}``. The
        #: ``scope`` key is the name of a blueprint the functions are
        #: active for, or ``None`` for all requests.
        #:
        #: To register a function, use the :meth:`before_request`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.before_request_funcs: dict[
            ft.AppOrBlueprintKey, list[ft.BeforeRequestCallable]
        ] = defaultdict(list)

        #: A data structure of functions to call at the end of each
        #: request, in the format ``{scope: [functions]}``. The
        #: ``scope`` key is the name of a blueprint the functions are
        #: active for, or ``None`` for all requests.
        #:
        #: To register a function, use the :meth:`after_request`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.after_request_funcs: dict[
            ft.AppOrBlueprintKey, list[ft.AfterRequestCallable[t.Any]]
        ] = defaultdict(list)

        #: A data structure of functions to call at the end of each
        #: request even if an exception is raised, in the format
        #: ``{scope: [functions]}``. The ``scope`` key is the name of a
        #: blueprint the functions are active for, or ``None`` for all
        #: requests.
        #:
        #: To register a function, use the :meth:`teardown_request`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.teardown_request_funcs: dict[
            ft.AppOrBlueprintKey, list[ft.TeardownCallable]
        ] = defaultdict(list)

        #: A data structure of functions to call to pass extra context
        #: values when rendering templates, in the format
        #: ``{scope: [functions]}``. The ``scope`` key is the name of a
        #: blueprint the functions are active for, or ``None`` for all
        #: requests.
        #:
        #: To register a function, use the :meth:`context_processor`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.template_context_processors: dict[
            ft.AppOrBlueprintKey, list[ft.TemplateContextProcessorCallable]
        ] = defaultdict(list, {None: [_default_template_ctx_processor]})

        #: A data structure of functions to call to modify the keyword
        #: arguments passed to the view function, in the format
        #: ``{scope: [functions]}``. The ``scope`` key is the name of a
        #: blueprint the functions are active for, or ``None`` for all
        #: requests.
        #:
        #: To register a function, use the
        #: :meth:`url_value_preprocessor` decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.url_value_preprocessors: dict[
            ft.AppOrBlueprintKey,
            list[ft.URLValuePreprocessorCallable],
        ] = defaultdict(list)

        #: A data structure of functions to call to modify the keyword
        #: arguments when generating URLs, in the format
        #: ``{scope: [functions]}``. The ``scope`` key is the name of a
        #: blueprint the functions are active for, or ``None`` for all
        #: requests.
        #:
        #: To register a function, use the :meth:`url_defaults`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.url_default_functions: dict[
            ft.AppOrBlueprintKey, list[ft.URLDefaultCallable]
        ] = defaultdict(list)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Scaffold
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/sansio/scaffold.py,1650,2551
Arguments: ['self', 'import_name: str', 'static_folder: str | os.PathLike[str] | None = None', 'static_url_path: str | None = None', 'template_folder: str | os.PathLike[str] | None = None', 'root_path: str | None = None', '']
Code: // Code for Global Scope
from __future__ import annotations
import importlib.util
import os
import pathlib
import sys
import typing as t
from collections import defaultdict
from functools import update_wrapper
from jinja2 import BaseLoader
from jinja2 import FileSystemLoader
from werkzeug.exceptions import default_exceptions
from werkzeug.exceptions import HTTPException
from werkzeug.utils import cached_property
from .. import typing as ft
from ..helpers import get_root_path
from ..templating import _default_template_ctx_processor
if t.TYPE_CHECKING:  # pragma: no cover
    from click import Group
# a singleton sentinel value for parameter defaults
_sentinel = object()
F = t.TypeVar("F", bound=t.Callable[..., t.Any])
T_after_request = t.TypeVar("T_after_request", bound=ft.AfterRequestCallable[t.Any])
T_before_request = t.TypeVar("T_before_request", bound=ft.BeforeRequestCallable)
T_error_handler = t.TypeVar("T_error_handler", bound=ft.ErrorHandlerCallable)
T_teardown = t.TypeVar("T_teardown", bound=ft.TeardownCallable)
T_template_context_processor = t.TypeVar(
    "T_template_context_processor", bound=ft.TemplateContextProcessorCallable
)
T_url_defaults = t.TypeVar("T_url_defaults", bound=ft.URLDefaultCallable)
T_url_value_preprocessor = t.TypeVar(
    "T_url_value_preprocessor", bound=ft.URLValuePreprocessorCallable
)
T_route = t.TypeVar("T_route", bound=ft.RouteCallable)
# Code for function: setupmethod(f: F, self: Scaffold, *args: t.Any, **kwargs: t.Any)
# Code for class: Scaffold(self, import_name: str, static_folder: str | os.PathLike[str] | None = None, static_url_path: str | None = None, template_folder: str | os.PathLike[str] | None = None, root_path: str | None = None, )
# Code for function: Scaffold.__init__(self, import_name: str, static_folder: str | os.PathLike[str] | None = None, static_url_path: str | None = None, template_folder: str | os.PathLike[str] | None = None, root_path: str | None = None, )
# Code for function: Scaffold.__repr__(self)
# Code for function: Scaffold._check_setup_finished(self, f_name: str)
# Code for function: Scaffold._method_route(self, method: str, rule: str, options: dict[str, t.Any], )
# Code for function: _endpoint_from_view_func(view_func: ft.RouteCallable)
# Code for function: _find_package_path(import_name: str)
# Code for function: find_package(import_name: str)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: Scaffold
Location: /home/yuesheng/flask/src/flask/sansio/scaffold.py,2551,8862
Arguments: ['self', 'import_name: str', 'static_folder: str | os.PathLike[str] | None = None', 'static_url_path: str | None = None', 'template_folder: str | os.PathLike[str] | None = None', 'root_path: str | None = None', '']
Code: def __repr__(self) -> str:
        return f"<{type(self).__name__} {self.name!r}>"
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __repr__
Type: function
Parent Type: Scaffold
Location: /home/yuesheng/flask/src/flask/sansio/scaffold.py,8868,8950
Arguments: ['self']
Code: def _check_setup_finished(self, f_name: str) -> None:
        raise NotImplementedError
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _check_setup_finished
Type: function
Parent Type: Scaffold
Location: /home/yuesheng/flask/src/flask/sansio/scaffold.py,8956,9043
Arguments: ['self', 'f_name: str']
Code: def _method_route(
        self,
        method: str,
        rule: str,
        options: dict[str, t.Any],
    ) -> t.Callable[[T_route], T_route]:
        if "methods" in options:
            raise TypeError("Use the 'route' decorator to use the 'methods' argument.")

        return self.route(rule, methods=[method], **options)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _method_route
Type: function
Parent Type: Scaffold
Location: /home/yuesheng/flask/src/flask/sansio/scaffold.py,10956,11287
Arguments: ['self', 'method: str', 'rule: str', 'options: dict[str', 't.Any]', '']
Code: class Scaffold:
    """Common behavior shared between :class:`~flask.Flask` and
    :class:`~flask.blueprints.Blueprint`.

    :param import_name: The import name of the module where this object
        is defined. Usually :attr:`__name__` should be used.
    :param static_folder: Path to a folder of static files to serve.
        If this is set, a static route will be added.
    :param static_url_path: URL prefix for the static route.
    :param template_folder: Path to a folder containing template files.
        for rendering. If this is set, a Jinja loader will be added.
    :param root_path: The path that static, template, and resource files
        are relative to. Typically not set, it is discovered based on
        the ``import_name``.

    .. versionadded:: 2.0
    """

    cli: Group
    name: str
    _static_folder: str | None = None
    _static_url_path: str | None = None

    # Code for function: Scaffold.__init__(self, import_name: str, static_folder: str | os.PathLike[str] | None = None, static_url_path: str | None = None, template_folder: str | os.PathLike[str] | None = None, root_path: str | None = None, )
# Code for function: Scaffold.__repr__(self)
# Code for function: Scaffold._check_setup_finished(self, f_name: str)
# Code for function: Scaffold._method_route(self, method: str, rule: str, options: dict[str, t.Any], )

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: dumps
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/json/__init__.py,221,1271
Arguments: ['obj: t.Any', '**kwargs: t.Any']
Code: // Code for Global Scope
from __future__ import annotations
import json as _json
import typing as t
from ..globals import current_app
from .provider import _default
if t.TYPE_CHECKING:  # pragma: no cover
    from ..wrappers import Response
# Code for function: dumps(obj: t.Any, **kwargs: t.Any)
# Code for function: dump(obj: t.Any, fp: t.IO[str], **kwargs: t.Any)
# Code for function: loads(s: str | bytes, **kwargs: t.Any)
# Code for function: load(fp: t.IO[t.AnyStr], **kwargs: t.Any)
# Code for function: jsonify(*args: t.Any, **kwargs: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/src/flask/json/tag.py,0,9280
Arguments: []
Code: // Code for Global Scope
"""
Tagged JSON
~~~~~~~~~~~

A compact representation for lossless serialization of non-standard JSON
types. :class:`~flask.sessions.SecureCookieSessionInterface` uses this
to serialize the session data, but it may be useful in other places. It
can be extended to support other types.

.. autoclass:: TaggedJSONSerializer
    :members:

.. autoclass:: JSONTag
    :members:

Let's see an example that adds support for
:class:`~collections.OrderedDict`. Dicts don't have an order in JSON, so
to handle this we will dump the items as a list of ``[key, value]``
pairs. Subclass :class:`JSONTag` and give it the new key ``' od'`` to
identify the type. The session serializer processes dicts first, so
insert the new tag at the front of the order since ``OrderedDict`` must
be processed before ``dict``.

.. code-block:: python

    from flask.json.tag import JSONTag

    class TagOrderedDict(JSONTag):
        __slots__ = ('serializer',)
        key = ' od'

        def check(self, value):
            return isinstance(value, OrderedDict)

        def to_json(self, value):
            return [[k, self.serializer.tag(v)] for k, v in iteritems(value)]

        def to_python(self, value):
            return OrderedDict(value)

    app.session_interface.serializer.register(TagOrderedDict, index=0)
"""
from __future__ import annotations
import typing as t
from base64 import b64decode
from base64 import b64encode
from datetime import datetime
from uuid import UUID
from markupsafe import Markup
from werkzeug.http import http_date
from werkzeug.http import parse_date
from ..json import dumps
from ..json import loads
# Code for class: JSONTag(self, serializer: TaggedJSONSerializer)
# Code for function: JSONTag.__init__(self, serializer: TaggedJSONSerializer)
# Code for function: JSONTag.check(self, value: t.Any)
# Code for function: JSONTag.to_json(self, value: t.Any)
# Code for function: JSONTag.to_python(self, value: t.Any)
# Code for function: JSONTag.tag(self, value: t.Any)
# Code for class: TagDict()
# Code for function: TagDict.check(self, value: t.Any)
# Code for function: TagDict.to_json(self, value: t.Any)
# Code for function: TagDict.to_python(self, value: t.Any)
# Code for class: PassDict()
# Code for function: PassDict.check(self, value: t.Any)
# Code for function: PassDict.to_json(self, value: t.Any)
# Code for class: TagTuple()
# Code for function: TagTuple.check(self, value: t.Any)
# Code for function: TagTuple.to_json(self, value: t.Any)
# Code for function: TagTuple.to_python(self, value: t.Any)
# Code for class: PassList()
# Code for function: PassList.check(self, value: t.Any)
# Code for function: PassList.to_json(self, value: t.Any)
# Code for class: TagBytes()
# Code for function: TagBytes.check(self, value: t.Any)
# Code for function: TagBytes.to_json(self, value: t.Any)
# Code for function: TagBytes.to_python(self, value: t.Any)
# Code for class: TagMarkup()
# Code for function: TagMarkup.check(self, value: t.Any)
# Code for function: TagMarkup.to_json(self, value: t.Any)
# Code for function: TagMarkup.to_python(self, value: t.Any)
# Code for class: TagUUID()
# Code for function: TagUUID.check(self, value: t.Any)
# Code for function: TagUUID.to_json(self, value: t.Any)
# Code for function: TagUUID.to_python(self, value: t.Any)
# Code for class: TagDateTime()
# Code for function: TagDateTime.check(self, value: t.Any)
# Code for function: TagDateTime.to_json(self, value: t.Any)
# Code for function: TagDateTime.to_python(self, value: t.Any)
# Code for class: TaggedJSONSerializer(self)
# Code for function: TaggedJSONSerializer.__init__(self)
# Code for function: TaggedJSONSerializer.register(self, tag_class: type[JSONTag], force: bool = False, index: int | None = None, )
# Code for function: TaggedJSONSerializer.tag(self, value: t.Any)
# Code for function: TaggedJSONSerializer.untag(self, value: dict[str, t.Any])
# Code for function: TaggedJSONSerializer._untag_scan(self, value: t.Any)
# Code for function: TaggedJSONSerializer.dumps(self, value: t.Any)
# Code for function: TaggedJSONSerializer.loads(self, value: str)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: JSONTag
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/json/tag.py,1625,1906
Arguments: ['self', 'serializer: TaggedJSONSerializer']
Code: class JSONTag:
    """Base class for defining type tags for :class:`TaggedJSONSerializer`."""

    __slots__ = ("serializer",)

    #: The tag to mark the serialized object with. If empty, this tag is
    #: only used as an intermediate step during tagging.
    key: str = ""

    # Code for function: JSONTag.__init__(self, serializer: TaggedJSONSerializer)
# Code for function: JSONTag.check(self, value: t.Any)
# Code for function: JSONTag.to_json(self, value: t.Any)
# Code for function: JSONTag.to_python(self, value: t.Any)
# Code for function: JSONTag.tag(self, value: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: JSONTag
Location: /home/yuesheng/flask/src/flask/json/tag.py,1906,2060
Arguments: ['self', 'serializer: TaggedJSONSerializer']
Code: def __init__(self, serializer: TaggedJSONSerializer) -> None:
        """Create a tagger for the given serializer."""
        self.serializer = serializer
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: check
Type: function
Parent Type: JSONTag
Location: /home/yuesheng/flask/src/flask/json/tag.py,2066,2207
Arguments: ['self', 'value: t.Any']
Code: def check(self, value: t.Any) -> bool:
        """Check if the given value should be tagged by this tag."""
        raise NotImplementedError
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: to_json
Type: function
Parent Type: JSONTag
Location: /home/yuesheng/flask/src/flask/json/tag.py,2213,2405
Arguments: ['self', 'value: t.Any']
Code: def to_json(self, value: t.Any) -> t.Any:
        """Convert the Python object to an object that is a valid JSON type.
        The tag will be added later."""
        raise NotImplementedError
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: to_python
Type: function
Parent Type: JSONTag
Location: /home/yuesheng/flask/src/flask/json/tag.py,2411,2601
Arguments: ['self', 'value: t.Any']
Code: def to_python(self, value: t.Any) -> t.Any:
        """Convert the JSON representation back to the correct type. The tag
        will already be removed."""
        raise NotImplementedError
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: tag
Type: function
Parent Type: JSONTag
Location: /home/yuesheng/flask/src/flask/json/tag.py,2607,2800
Arguments: ['self', 'value: t.Any']
Code: def tag(self, value: t.Any) -> dict[str, t.Any]:
        """Convert the value to a valid JSON type and add the tag structure
        around it."""
        return {self.key: self.to_json(value)}
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: TagDict
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/json/tag.py,2803,3048
Arguments: []
Code: class TagDict(JSONTag):
    """Tag for 1-item dicts whose only key matches a registered tag.

    Internally, the dict key is suffixed with `__`, and the suffix is removed
    when deserializing.
    """

    __slots__ = ()
    key = " di"

    # Code for function: TagDict.check(self, value: t.Any)
# Code for function: TagDict.to_json(self, value: t.Any)
# Code for function: TagDict.to_python(self, value: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: check
Type: function
Parent Type: TagDict
Location: /home/yuesheng/flask/src/flask/json/tag.py,3048,3239
Arguments: ['self', 'value: t.Any']
Code: def check(self, value: t.Any) -> bool:
        return (
            isinstance(value, dict)
            and len(value) == 1
            and next(iter(value)) in self.serializer.tags
        )
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: to_json
Type: function
Parent Type: TagDict
Location: /home/yuesheng/flask/src/flask/json/tag.py,3245,3379
Arguments: ['self', 'value: t.Any']
Code: def to_json(self, value: t.Any) -> t.Any:
        key = next(iter(value))
        return {f"{key}__": self.serializer.tag(value[key])}
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: to_python
Type: function
Parent Type: TagDict
Location: /home/yuesheng/flask/src/flask/json/tag.py,3385,3498
Arguments: ['self', 'value: t.Any']
Code: def to_python(self, value: t.Any) -> t.Any:
        key = next(iter(value))
        return {key[:-2]: value[key]}
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: PassDict
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/json/tag.py,3501,3550
Arguments: []
Code: class PassDict(JSONTag):
    __slots__ = ()

    # Code for function: PassDict.check(self, value: t.Any)
# Code for function: PassDict.to_json(self, value: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: check
Type: function
Parent Type: PassDict
Location: /home/yuesheng/flask/src/flask/json/tag.py,3550,3627
Arguments: ['self', 'value: t.Any']
Code: def check(self, value: t.Any) -> bool:
        return isinstance(value, dict)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: to_json
Type: function
Parent Type: PassDict
Location: /home/yuesheng/flask/src/flask/json/tag.py,3633,3841
Arguments: ['self', 'value: t.Any']
Code: def to_json(self, value: t.Any) -> t.Any:
        # JSON objects may only have string keys, so don't bother tagging the
        # key here.
        return {k: self.serializer.tag(v) for k, v in value.items()}
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: TagTuple
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/json/tag.py,3863,3927
Arguments: []
Code: class TagTuple(JSONTag):
    __slots__ = ()
    key = " t"

    # Code for function: TagTuple.check(self, value: t.Any)
# Code for function: TagTuple.to_json(self, value: t.Any)
# Code for function: TagTuple.to_python(self, value: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: check
Type: function
Parent Type: TagTuple
Location: /home/yuesheng/flask/src/flask/json/tag.py,3927,4005
Arguments: ['self', 'value: t.Any']
Code: def check(self, value: t.Any) -> bool:
        return isinstance(value, tuple)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: to_json
Type: function
Parent Type: TagTuple
Location: /home/yuesheng/flask/src/flask/json/tag.py,4011,4113
Arguments: ['self', 'value: t.Any']
Code: def to_json(self, value: t.Any) -> t.Any:
        return [self.serializer.tag(item) for item in value]
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: to_python
Type: function
Parent Type: TagTuple
Location: /home/yuesheng/flask/src/flask/json/tag.py,4119,4190
Arguments: ['self', 'value: t.Any']
Code: def to_python(self, value: t.Any) -> t.Any:
        return tuple(value)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: PassList
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/json/tag.py,4193,4242
Arguments: []
Code: class PassList(JSONTag):
    __slots__ = ()

    # Code for function: PassList.check(self, value: t.Any)
# Code for function: PassList.to_json(self, value: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: check
Type: function
Parent Type: PassList
Location: /home/yuesheng/flask/src/flask/json/tag.py,4242,4319
Arguments: ['self', 'value: t.Any']
Code: def check(self, value: t.Any) -> bool:
        return isinstance(value, list)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: to_json
Type: function
Parent Type: PassList
Location: /home/yuesheng/flask/src/flask/json/tag.py,4325,4427
Arguments: ['self', 'value: t.Any']
Code: def to_json(self, value: t.Any) -> t.Any:
        return [self.serializer.tag(item) for item in value]
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: TagBytes
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/json/tag.py,4449,4513
Arguments: []
Code: class TagBytes(JSONTag):
    __slots__ = ()
    key = " b"

    # Code for function: TagBytes.check(self, value: t.Any)
# Code for function: TagBytes.to_json(self, value: t.Any)
# Code for function: TagBytes.to_python(self, value: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: check
Type: function
Parent Type: TagBytes
Location: /home/yuesheng/flask/src/flask/json/tag.py,4513,4591
Arguments: ['self', 'value: t.Any']
Code: def check(self, value: t.Any) -> bool:
        return isinstance(value, bytes)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: to_json
Type: function
Parent Type: TagBytes
Location: /home/yuesheng/flask/src/flask/json/tag.py,4597,4686
Arguments: ['self', 'value: t.Any']
Code: def to_json(self, value: t.Any) -> t.Any:
        return b64encode(value).decode("ascii")
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: to_python
Type: function
Parent Type: TagBytes
Location: /home/yuesheng/flask/src/flask/json/tag.py,4692,4767
Arguments: ['self', 'value: t.Any']
Code: def to_python(self, value: t.Any) -> t.Any:
        return b64decode(value)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: TagMarkup
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/json/tag.py,4770,5047
Arguments: []
Code: class TagMarkup(JSONTag):
    """Serialize anything matching the :class:`~markupsafe.Markup` API by
    having a ``__html__`` method to the result of that method. Always
    deserializes to an instance of :class:`~markupsafe.Markup`."""

    __slots__ = ()
    key = " m"

    # Code for function: TagMarkup.check(self, value: t.Any)
# Code for function: TagMarkup.to_json(self, value: t.Any)
# Code for function: TagMarkup.to_python(self, value: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: check
Type: function
Parent Type: TagMarkup
Location: /home/yuesheng/flask/src/flask/json/tag.py,5047,5143
Arguments: ['self', 'value: t.Any']
Code: def check(self, value: t.Any) -> bool:
        return callable(getattr(value, "__html__", None))
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: to_json
Type: function
Parent Type: TagMarkup
Location: /home/yuesheng/flask/src/flask/json/tag.py,5149,5227
Arguments: ['self', 'value: t.Any']
Code: def to_json(self, value: t.Any) -> t.Any:
        return str(value.__html__())
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: to_python
Type: function
Parent Type: TagMarkup
Location: /home/yuesheng/flask/src/flask/json/tag.py,5233,5305
Arguments: ['self', 'value: t.Any']
Code: def to_python(self, value: t.Any) -> t.Any:
        return Markup(value)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: TagUUID
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/json/tag.py,5308,5371
Arguments: []
Code: class TagUUID(JSONTag):
    __slots__ = ()
    key = " u"

    # Code for function: TagUUID.check(self, value: t.Any)
# Code for function: TagUUID.to_json(self, value: t.Any)
# Code for function: TagUUID.to_python(self, value: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: check
Type: function
Parent Type: TagUUID
Location: /home/yuesheng/flask/src/flask/json/tag.py,5371,5448
Arguments: ['self', 'value: t.Any']
Code: def check(self, value: t.Any) -> bool:
        return isinstance(value, UUID)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: to_json
Type: function
Parent Type: TagUUID
Location: /home/yuesheng/flask/src/flask/json/tag.py,5454,5520
Arguments: ['self', 'value: t.Any']
Code: def to_json(self, value: t.Any) -> t.Any:
        return value.hex
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: to_python
Type: function
Parent Type: TagUUID
Location: /home/yuesheng/flask/src/flask/json/tag.py,5526,5596
Arguments: ['self', 'value: t.Any']
Code: def to_python(self, value: t.Any) -> t.Any:
        return UUID(value)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: TagDateTime
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/json/tag.py,5599,5666
Arguments: []
Code: class TagDateTime(JSONTag):
    __slots__ = ()
    key = " d"

    # Code for function: TagDateTime.check(self, value: t.Any)
# Code for function: TagDateTime.to_json(self, value: t.Any)
# Code for function: TagDateTime.to_python(self, value: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: check
Type: function
Parent Type: TagDateTime
Location: /home/yuesheng/flask/src/flask/json/tag.py,5666,5747
Arguments: ['self', 'value: t.Any']
Code: def check(self, value: t.Any) -> bool:
        return isinstance(value, datetime)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: to_json
Type: function
Parent Type: TagDateTime
Location: /home/yuesheng/flask/src/flask/json/tag.py,5753,5826
Arguments: ['self', 'value: t.Any']
Code: def to_json(self, value: t.Any) -> t.Any:
        return http_date(value)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: to_python
Type: function
Parent Type: TagDateTime
Location: /home/yuesheng/flask/src/flask/json/tag.py,5832,5908
Arguments: ['self', 'value: t.Any']
Code: def to_python(self, value: t.Any) -> t.Any:
        return parse_date(value)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: TaggedJSONSerializer
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/json/tag.py,5911,6663
Arguments: ['self']
Code: class TaggedJSONSerializer:
    """Serializer that uses a tag system to compactly represent objects that
    are not JSON types. Passed as the intermediate serializer to
    :class:`itsdangerous.Serializer`.

    The following extra types are supported:

    * :class:`dict`
    * :class:`tuple`
    * :class:`bytes`
    * :class:`~markupsafe.Markup`
    * :class:`~uuid.UUID`
    * :class:`~datetime.datetime`
    """

    __slots__ = ("tags", "order")

    #: Tag classes to bind when creating the serializer. Other tags can be
    #: added later using :meth:`~register`.
    default_tags = [
        TagDict,
        PassDict,
        TagTuple,
        PassList,
        TagBytes,
        TagMarkup,
        TagUUID,
        TagDateTime,
    ]

    # Code for function: TaggedJSONSerializer.__init__(self)
# Code for function: TaggedJSONSerializer.register(self, tag_class: type[JSONTag], force: bool = False, index: int | None = None, )
# Code for function: TaggedJSONSerializer.tag(self, value: t.Any)
# Code for function: TaggedJSONSerializer.untag(self, value: dict[str, t.Any])
# Code for function: TaggedJSONSerializer._untag_scan(self, value: t.Any)
# Code for function: TaggedJSONSerializer.dumps(self, value: t.Any)
# Code for function: TaggedJSONSerializer.loads(self, value: str)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: TaggedJSONSerializer
Location: /home/yuesheng/flask/src/flask/json/tag.py,6663,6842
Arguments: ['self']
Code: def __init__(self) -> None:
        self.tags: dict[str, JSONTag] = {}
        self.order: list[JSONTag] = []

        for cls in self.default_tags:
            self.register(cls)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: register
Type: function
Parent Type: TaggedJSONSerializer
Location: /home/yuesheng/flask/src/flask/json/tag.py,6848,7937
Arguments: ['self', 'tag_class: type[JSONTag]', 'force: bool = False', 'index: int | None = None', '']
Code: def register(
        self,
        tag_class: type[JSONTag],
        force: bool = False,
        index: int | None = None,
    ) -> None:
        """Register a new tag with this serializer.

        :param tag_class: tag class to register. Will be instantiated with this
            serializer instance.
        :param force: overwrite an existing tag. If false (default), a
            :exc:`KeyError` is raised.
        :param index: index to insert the new tag in the tag order. Useful when
            the new tag is a special case of an existing tag. If ``None``
            (default), the tag is appended to the end of the order.

        :raise KeyError: if the tag key is already registered and ``force`` is
            not true.
        """
        tag = tag_class(self)
        key = tag.key

        if key:
            if not force and key in self.tags:
                raise KeyError(f"Tag '{key}' is already registered.")

            self.tags[key] = tag

        if index is None:
            self.order.append(tag)
        else:
            self.order.insert(index, tag)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: tag
Type: function
Parent Type: TaggedJSONSerializer
Location: /home/yuesheng/flask/src/flask/json/tag.py,7943,8175
Arguments: ['self', 'value: t.Any']
Code: def tag(self, value: t.Any) -> t.Any:
        """Convert a value to a tagged representation if necessary."""
        for tag in self.order:
            if tag.check(value):
                return tag.tag(value)

        return value
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: untag
Type: function
Parent Type: TaggedJSONSerializer
Location: /home/yuesheng/flask/src/flask/json/tag.py,8181,8502
Arguments: ['self', 'value: dict[str', 't.Any]']
Code: def untag(self, value: dict[str, t.Any]) -> t.Any:
        """Convert a tagged representation back to the original type."""
        if len(value) != 1:
            return value

        key = next(iter(value))

        if key not in self.tags:
            return value

        return self.tags[key].to_python(value[key])
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _untag_scan
Type: function
Parent Type: TaggedJSONSerializer
Location: /home/yuesheng/flask/src/flask/json/tag.py,8508,8941
Arguments: ['self', 'value: t.Any']
Code: def _untag_scan(self, value: t.Any) -> t.Any:
        if isinstance(value, dict):
            # untag each item recursively
            value = {k: self._untag_scan(v) for k, v in value.items()}
            # untag the dict itself
            value = self.untag(value)
        elif isinstance(value, list):
            # untag each item recursively
            value = [self._untag_scan(item) for item in value]

        return value
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: dumps
Type: function
Parent Type: TaggedJSONSerializer
Location: /home/yuesheng/flask/src/flask/json/tag.py,8947,9111
Arguments: ['self', 'value: t.Any']
Code: def dumps(self, value: t.Any) -> str:
        """Tag the value and dump it to a compact JSON string."""
        return dumps(self.tag(value), separators=(",", ":"))
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: loads
Type: function
Parent Type: TaggedJSONSerializer
Location: /home/yuesheng/flask/src/flask/json/tag.py,9117,9280
Arguments: ['self', 'value: str']
Code: def loads(self, value: str) -> t.Any:
        """Load data from a JSON string and deserialized any tagged objects."""
        return self._untag_scan(loads(value))
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: JSONProvider
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/json/provider.py,318,1067
Arguments: ['self', 'app: App']
Code: class JSONProvider:
    """A standard set of JSON operations for an application. Subclasses
    of this can be used to customize JSON behavior or use different
    JSON libraries.

    To implement a provider for a specific library, subclass this base
    class and implement at least :meth:`dumps` and :meth:`loads`. All
    other methods have default implementations.

    To use a different provider, either subclass ``Flask`` and set
    :attr:`~flask.Flask.json_provider_class` to a provider class, or set
    :attr:`app.json <flask.Flask.json>` to an instance of the class.

    :param app: An application instance. This will be stored as a
        :class:`weakref.proxy` on the :attr:`_app` attribute.

    .. versionadded:: 2.2
    """

    # Code for function: JSONProvider.__init__(self, app: App)
# Code for function: JSONProvider.dumps(self, obj: t.Any, **kwargs: t.Any)
# Code for function: JSONProvider.dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any)
# Code for function: JSONProvider.loads(self, s: str | bytes, **kwargs: t.Any)
# Code for function: JSONProvider.load(self, fp: t.IO[t.AnyStr], **kwargs: t.Any)
# Code for function: JSONProvider._prepare_response_obj(self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any])
# Code for function: JSONProvider.response(self, *args: t.Any, **kwargs: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: JSONProvider
Location: /home/yuesheng/flask/src/flask/json/provider.py,1067,1148
Arguments: ['self', 'app: App']
Code: def __init__(self, app: App) -> None:
        self._app: App = weakref.proxy(app)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: dumps
Type: function
Parent Type: JSONProvider
Location: /home/yuesheng/flask/src/flask/json/provider.py,1154,1400
Arguments: ['self', 'obj: t.Any', '**kwargs: t.Any']
Code: def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:
        """Serialize data as JSON.

        :param obj: The data to serialize.
        :param kwargs: May be passed to the underlying JSON library.
        """
        raise NotImplementedError
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: dump
Type: function
Parent Type: JSONProvider
Location: /home/yuesheng/flask/src/flask/json/provider.py,1406,1808
Arguments: ['self', 'obj: t.Any', 'fp: t.IO[str]', '**kwargs: t.Any']
Code: def dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:
        """Serialize data as JSON and write to a file.

        :param obj: The data to serialize.
        :param fp: A file opened for writing text. Should use the UTF-8
            encoding to be valid JSON.
        :param kwargs: May be passed to the underlying JSON library.
        """
        fp.write(self.dumps(obj, **kwargs))
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: loads
Type: function
Parent Type: JSONProvider
Location: /home/yuesheng/flask/src/flask/json/provider.py,1814,2064
Arguments: ['self', 's: str | bytes', '**kwargs: t.Any']
Code: def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:
        """Deserialize data as JSON.

        :param s: Text or UTF-8 bytes.
        :param kwargs: May be passed to the underlying JSON library.
        """
        raise NotImplementedError
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: load
Type: function
Parent Type: JSONProvider
Location: /home/yuesheng/flask/src/flask/json/provider.py,2070,2380
Arguments: ['self', 'fp: t.IO[t.AnyStr]', '**kwargs: t.Any']
Code: def load(self, fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:
        """Deserialize data as JSON read from a file.

        :param fp: A file opened for reading text or UTF-8 bytes.
        :param kwargs: May be passed to the underlying JSON library.
        """
        return self.loads(fp.read(), **kwargs)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _prepare_response_obj
Type: function
Parent Type: JSONProvider
Location: /home/yuesheng/flask/src/flask/json/provider.py,2386,2756
Arguments: ['self', 'args: tuple[t.Any', '...]', 'kwargs: dict[str', 't.Any]']
Code: def _prepare_response_obj(
        self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any]
    ) -> t.Any:
        if args and kwargs:
            raise TypeError("app.json.response() takes either args or kwargs, not both")

        if not args and not kwargs:
            return None

        if len(args) == 1:
            return args[0]

        return args or kwargs
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: response
Type: function
Parent Type: JSONProvider
Location: /home/yuesheng/flask/src/flask/json/provider.py,2762,3532
Arguments: ['self', '*args: t.Any', '**kwargs: t.Any']
Code: def response(self, *args: t.Any, **kwargs: t.Any) -> Response:
        """Serialize the given arguments as JSON, and return a
        :class:`~flask.Response` object with the ``application/json``
        mimetype.

        The :func:`~flask.json.jsonify` function calls this method for
        the current application.

        Either positional or keyword arguments can be given, not both.
        If no arguments are given, ``None`` is serialized.

        :param args: A single value to serialize, or multiple values to
            treat as a list to serialize.
        :param kwargs: Treat as a dict to serialize.
        """
        obj = self._prepare_response_obj(args, kwargs)
        return self._app.response_class(self.dumps(obj), mimetype="application/json")
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: _default
Type: function
Parent Type: 
Location: /home/yuesheng/flask/src/flask/json/provider.py,3535,3963
Arguments: ['o: t.Any']
Code: def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:
        """Serialize data as JSON to a string.

        Keyword arguments are passed to :func:`json.dumps`. Sets some
        parameter defaults from the :attr:`default`,
        :attr:`ensure_ascii`, and :attr:`sort_keys` attributes.

        :param obj: The data to serialize.
        :param kwargs: Passed to :func:`json.dumps`.
        """
        kwargs.setdefault("default", self.default)
        kwargs.setdefault("ensure_ascii", self.ensure_ascii)
        kwargs.setdefault("sort_keys", self.sort_keys)
        return json.dumps(obj, **kwargs)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: DefaultJSONProvider
Type: class
Parent Type: 
Location: /home/yuesheng/flask/src/flask/json/provider.py,3966,5655
Arguments: []
Code: // Code for Global Scope
from __future__ import annotations
import dataclasses
import decimal
import json
import typing as t
import uuid
import weakref
from datetime import date
from werkzeug.http import http_date
if t.TYPE_CHECKING:  # pragma: no cover
    from werkzeug.sansio.response import Response

    from ..sansio.app import App
# Code for class: JSONProvider(self, app: App)
# Code for function: JSONProvider.__init__(self, app: App)
# Code for function: JSONProvider.dumps(self, obj: t.Any, **kwargs: t.Any)
# Code for function: JSONProvider.dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any)
# Code for function: JSONProvider.loads(self, s: str | bytes, **kwargs: t.Any)
# Code for function: JSONProvider.load(self, fp: t.IO[t.AnyStr], **kwargs: t.Any)
# Code for function: JSONProvider._prepare_response_obj(self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any])
# Code for function: JSONProvider.response(self, *args: t.Any, **kwargs: t.Any)
# Code for function: _default(o: t.Any)
# Code for class: DefaultJSONProvider()
# Code for function: DefaultJSONProvider.dumps(self, obj: t.Any, **kwargs: t.Any)
# Code for function: DefaultJSONProvider.loads(self, s: str | bytes, **kwargs: t.Any)
# Code for function: DefaultJSONProvider.response(self, *args: t.Any, **kwargs: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: dumps
Type: function
Parent Type: DefaultJSONProvider
Location: /home/yuesheng/flask/src/flask/json/provider.py,5655,6259
Arguments: ['self', 'obj: t.Any', '**kwargs: t.Any']
Code: def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:
        """Deserialize data as JSON from a string or bytes.

        :param s: Text or UTF-8 bytes.
        :param kwargs: Passed to :func:`json.loads`.
        """
        return json.loads(s, **kwargs)
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: loads
Type: function
Parent Type: DefaultJSONProvider
Location: /home/yuesheng/flask/src/flask/json/provider.py,6265,6527
Arguments: ['self', 's: str | bytes', '**kwargs: t.Any']
Code: def response(self, *args: t.Any, **kwargs: t.Any) -> Response:
        """Serialize the given arguments as JSON, and return a
        :class:`~flask.Response` object with it. The response mimetype
        will be "application/json" and can be changed with
        :attr:`mimetype`.

        If :attr:`compact` is ``False`` or debug mode is enabled, the
        output will be formatted to be easier to read.

        Either positional or keyword arguments can be given, not both.
        If no arguments are given, ``None`` is serialized.

        :param args: A single value to serialize, or multiple values to
            treat as a list to serialize.
        :param kwargs: Treat as a dict to serialize.
        """
        obj = self._prepare_response_obj(args, kwargs)
        dump_args: dict[str, t.Any] = {}

        if (self.compact is None and self._app.debug) or self.compact is False:
            dump_args.setdefault("indent", 2)
        else:
            dump_args.setdefault("separators", (",", ":"))

        return self._app.response_class(
            f"{self.dumps(obj, **dump_args)}\n", mimetype=self.mimetype
        )
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: response
Type: function
Parent Type: DefaultJSONProvider
Location: /home/yuesheng/flask/src/flask/json/provider.py,6533,7671
Arguments: ['self', '*args: t.Any', '**kwargs: t.Any']
Code: class DefaultJSONProvider(JSONProvider):
    """Provide JSON operations using Python's built-in :mod:`json`
    library. Serializes the following additional data types:

    -   :class:`datetime.datetime` and :class:`datetime.date` are
        serialized to :rfc:`822` strings. This is the same as the HTTP
        date format.
    -   :class:`uuid.UUID` is serialized to a string.
    -   :class:`dataclasses.dataclass` is passed to
        :func:`dataclasses.asdict`.
    -   :class:`~markupsafe.Markup` (or any object with a ``__html__``
        method) will call the ``__html__`` method to get a string.
    """

    default: t.Callable[[t.Any], t.Any] = staticmethod(_default)  # type: ignore[assignment]
    """Apply this function to any object that :meth:`json.dumps` does
    not know how to serialize. It should return a valid JSON type or
    raise a ``TypeError``.
    """

    ensure_ascii = True
    """Replace non-ASCII characters with escape sequences. This may be
    more compatible with some clients, but can be disabled for better
    performance and size.
    """

    sort_keys = True
    """Sort the keys in any serialized dicts. This may be useful for
    some caching situations, but can be disabled for better performance.
    When enabled, keys must all be strings, they are not converted
    before sorting.
    """

    compact: bool | None = None
    """If ``True``, or ``None`` out of debug mode, the :meth:`response`
    output will not add indentation, newlines, or spaces. If ``False``,
    or ``None`` in debug mode, it will use a non-compact representation.
    """

    mimetype = "application/json"
    """The mimetype set in :meth:`response`."""

    # Code for function: DefaultJSONProvider.dumps(self, obj: t.Any, **kwargs: t.Any)
# Code for function: DefaultJSONProvider.loads(self, s: str | bytes, **kwargs: t.Any)
# Code for function: DefaultJSONProvider.response(self, *args: t.Any, **kwargs: t.Any)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/examples/javascript/js_example/__init__.py,0,96
Arguments: []
Code: // Code for Global Scope
from flask import Flask
app = Flask(__name__)
from js_example import views
# noqa: E402, F401

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/examples/javascript/js_example/views.py,0,428
Arguments: []
Code: // Code for Global Scope
from flask import jsonify
from flask import render_template
from flask import request
from . import app
@app.route("/", defaults={"js": "fetch"})
@app.route("/<any(xhr, jquery, fetch):js>")
def index(js):
    return render_template(f"{js}.html", js=js)
@app.route("/add", methods=["POST"])
def add():
    a = request.form.get("a", 0, type=float)
    b = request.form.get("b", 0, type=float)
    return jsonify(result=a + b)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/examples/javascript/tests/conftest.py,0,215
Arguments: []
Code: // Code for Global Scope
import pytest
from js_example import app
@pytest.fixture(name="app")
def fixture_app():
    app.testing = True
    yield app
    app.testing = False
@pytest.fixture
def client(app):
    return app.test_client()

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/examples/javascript/tests/test_js_example.py,0,726
Arguments: []
Code: // Code for Global Scope
import pytest
from flask import template_rendered
@pytest.mark.parametrize(
    ("path", "template_name"),
    (
        ("/", "fetch.html"),
        ("/plain", "xhr.html"),
        ("/fetch", "fetch.html"),
        ("/jquery", "jquery.html"),
    ),
)
def test_index(app, client, path, template_name):
    def check(sender, template, context):
        assert template.name == template_name

    with template_rendered.connected_to(check, app):
        client.get(path)
@pytest.mark.parametrize(
    ("a", "b", "result"), ((2, 3, 5), (2.5, 3, 5.5), (2, None, 2), (2, "b", 2))
)
def test_add(client, a, b, result):
    response = client.post("/add", data={"a": a, "b": b})
    assert response.get_json()["result"] == result

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: create_app
Type: function
Parent Type: 
Location: /home/yuesheng/flask/examples/tutorial/flaskr/__init__.py,37,1436
Arguments: ['test_config=None', '']
Code: // Code for Global Scope
import os
from flask import Flask
# Code for function: create_app(test_config=None, )

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get_post
Type: function
Parent Type: 
Location: /home/yuesheng/flask/examples/tutorial/flaskr/blog.py,668,1530
Arguments: ['id', 'check_author=True']
Code: // Code for Global Scope
from flask import Blueprint
from flask import flash
from flask import g
from flask import redirect
from flask import render_template
from flask import request
from flask import url_for
from werkzeug.exceptions import abort
from .auth import login_required
from .db import get_db
bp = Blueprint("blog", __name__)
@bp.route("/")
def index():
    """Show all the posts, most recent first."""
    db = get_db()
    posts = db.execute(
        "SELECT p.id, title, body, created, author_id, username"
        " FROM post p JOIN user u ON p.author_id = u.id"
        " ORDER BY created DESC"
    ).fetchall()
    return render_template("blog/index.html", posts=posts)
# Code for function: get_post(id, check_author=True)
@bp.route("/create", methods=("GET", "POST"))
@login_required
def create():
    """Create a new post for the current user."""
    if request.method == "POST":
        title = request.form["title"]
        body = request.form["body"]
        error = None

        if not title:
            error = "Title is required."

        if error is not None:
            flash(error)
        else:
            db = get_db()
            db.execute(
                "INSERT INTO post (title, body, author_id) VALUES (?, ?, ?)",
                (title, body, g.user["id"]),
            )
            db.commit()
            return redirect(url_for("blog.index"))

    return render_template("blog/create.html")
@bp.route("/<int:id>/update", methods=("GET", "POST"))
@login_required
def update(id):
    """Update a post if the current user is the author."""
    post = get_post(id)

    if request.method == "POST":
        title = request.form["title"]
        body = request.form["body"]
        error = None

        if not title:
            error = "Title is required."

        if error is not None:
            flash(error)
        else:
            db = get_db()
            db.execute(
                "UPDATE post SET title = ?, body = ? WHERE id = ?", (title, body, id)
            )
            db.commit()
            return redirect(url_for("blog.index"))

    return render_template("blog/update.html", post=post)
@bp.route("/<int:id>/delete", methods=("POST",))
@login_required
def delete(id):
    """Delete a post.

    Ensures that the post exists and that the logged in user is the
    author of the post.
    """
    get_post(id)
    db = get_db()
    db.execute("DELETE FROM post WHERE id = ?", (id,))
    db.commit()
    return redirect(url_for("blog.index"))

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: get_db
Type: function
Parent Type: 
Location: /home/yuesheng/flask/examples/tutorial/flaskr/db.py,111,484
Arguments: ['']
Code: // Code for Global Scope
import sqlite3
from datetime import datetime
import click
from flask import current_app
from flask import g
# Code for function: get_db()
# Code for function: close_db(e=None)
# Code for function: init_db()
@click.command("init-db")
def init_db_command():
    """Clear existing data and create new tables."""
    init_db()
    click.echo("Initialized the database.")
sqlite3.register_converter("timestamp", lambda v: datetime.fromisoformat(v.decode()))
# Code for function: init_app(app)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: login_required
Type: function
Parent Type: 
Location: /home/yuesheng/flask/examples/tutorial/flaskr/auth.py,412,706
Arguments: ['view', '**kwargs']
Code: // Code for Global Scope
import functools
from flask import Blueprint
from flask import flash
from flask import g
from flask import redirect
from flask import render_template
from flask import request
from flask import session
from flask import url_for
from werkzeug.security import check_password_hash
from werkzeug.security import generate_password_hash
from .db import get_db
bp = Blueprint("auth", __name__, url_prefix="/auth")
# Code for function: login_required(view, **kwargs)
@bp.before_app_request
def load_logged_in_user():
    """If a user id is stored in the session, load the user object from
    the database into ``g.user``."""
    user_id = session.get("user_id")

    if user_id is None:
        g.user = None
    else:
        g.user = (
            get_db().execute("SELECT * FROM user WHERE id = ?", (user_id,)).fetchone()
        )
@bp.route("/register", methods=("GET", "POST"))
def register():
    """Register a new user.

    Validates that the username is not already taken. Hashes the
    password for security.
    """
    if request.method == "POST":
        username = request.form["username"]
        password = request.form["password"]
        db = get_db()
        error = None

        if not username:
            error = "Username is required."
        elif not password:
            error = "Password is required."

        if error is None:
            try:
                db.execute(
                    "INSERT INTO user (username, password) VALUES (?, ?)",
                    (username, generate_password_hash(password)),
                )
                db.commit()
            except db.IntegrityError:
                # The username was already taken, which caused the
                # commit to fail. Show a validation error.
                error = f"User {username} is already registered."
            else:
                # Success, go to the login page.
                return redirect(url_for("auth.login"))

        flash(error)

    return render_template("auth/register.html")
@bp.route("/login", methods=("GET", "POST"))
def login():
    """Log in a registered user by adding the user id to the session."""
    if request.method == "POST":
        username = request.form["username"]
        password = request.form["password"]
        db = get_db()
        error = None
        user = db.execute(
            "SELECT * FROM user WHERE username = ?", (username,)
        ).fetchone()

        if user is None:
            error = "Incorrect username."
        elif not check_password_hash(user["password"], password):
            error = "Incorrect password."

        if error is None:
            # store the user id in a new session and return to the index
            session.clear()
            session["user_id"] = user["id"]
            return redirect(url_for("index"))

        flash(error)

    return render_template("auth/login.html")
@bp.route("/logout")
def logout():
    """Clear the current session, including the stored user id."""
    session.clear()
    return redirect(url_for("index"))

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_index
Type: function
Parent Type: 
Location: /home/yuesheng/flask/examples/tutorial/tests/test_blog.py,46,418
Arguments: ['client', 'auth']
Code: // Code for Global Scope
import pytest
from flaskr.db import get_db
# Code for function: test_index(client, auth)
@pytest.mark.parametrize("path", ("/create", "/1/update", "/1/delete"))
def test_login_required(client, path):
    response = client.post(path)
    assert response.headers["Location"] == "/auth/login"
# Code for function: test_author_required(app, client, auth)
@pytest.mark.parametrize("path", ("/2/update", "/2/delete"))
def test_exists_required(client, auth, path):
    auth.login()
    assert client.post(path).status_code == 404
# Code for function: test_create(client, auth, app)
# Code for function: test_update(client, auth, app)
@pytest.mark.parametrize("path", ("/create", "/1/update"))
def test_create_update_validate(client, auth, path):
    auth.login()
    response = client.post(path, data={"title": "", "body": ""})
    assert b"Title is required." in response.data
# Code for function: test_delete(client, auth, app)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_register
Type: function
Parent Type: 
Location: /home/yuesheng/flask/examples/tutorial/tests/test_auth.py,92,678
Arguments: ['client', 'app']
Code: // Code for Global Scope
import pytest
from flask import g
from flask import session
from flaskr.db import get_db
# Code for function: test_register(client, app)
@pytest.mark.parametrize(
    ("username", "password", "message"),
    (
        ("", "", b"Username is required."),
        ("a", "", b"Password is required."),
        ("test", "test", b"already registered"),
    ),
)
def test_register_validate_input(client, username, password, message):
    response = client.post(
        "/auth/register", data={"username": username, "password": password}
    )
    assert message in response.data
# Code for function: test_login(client, auth)
@pytest.mark.parametrize(
    ("username", "password", "message"),
    (("a", "test", b"Incorrect username."), ("test", "a", b"Incorrect password.")),
)
def test_login_validate_input(auth, username, password, message):
    response = auth.login(username, password)
    assert message in response.data
# Code for function: test_logout(client, auth)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/examples/tutorial/tests/conftest.py,0,1453
Arguments: []
Code: // Code for Global Scope
import os
import tempfile
import pytest
from flaskr import create_app
from flaskr.db import get_db
from flaskr.db import init_db
# read in SQL for populating test data
with open(os.path.join(os.path.dirname(__file__), "data.sql"), "rb") as f:
    _data_sql = f.read().decode("utf8")
@pytest.fixture
def app():
    """Create and configure a new app instance for each test."""
    # create a temporary file to isolate the database for each test
    db_fd, db_path = tempfile.mkstemp()
    # create the app with common test config
    app = create_app({"TESTING": True, "DATABASE": db_path})

    # create the database and load test data
    with app.app_context():
        init_db()
        get_db().executescript(_data_sql)

    yield app

    # close and remove the temporary database
    os.close(db_fd)
    os.unlink(db_path)
@pytest.fixture
def client(app):
    """A test client for the app."""
    return app.test_client()
@pytest.fixture
def runner(app):
    """A test runner for the app's Click commands."""
    return app.test_cli_runner()
# Code for class: AuthActions(self, client)
# Code for function: AuthActions.__init__(self, client)
# Code for function: AuthActions.login(self, username="test", password="test")
# Code for function: AuthActions.logout(self)
@pytest.fixture
def auth(client):
    return AuthActions(client)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: AuthActions
Type: class
Parent Type: 
Location: /home/yuesheng/flask/examples/tutorial/tests/conftest.py,1058,1081
Arguments: ['self', 'client']
Code: class AuthActions:
    # Code for function: AuthActions.__init__(self, client)
# Code for function: AuthActions.login(self, username="test", password="test")
# Code for function: AuthActions.logout(self)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: __init__
Type: function
Parent Type: AuthActions
Location: /home/yuesheng/flask/examples/tutorial/tests/conftest.py,1081,1138
Arguments: ['self', 'client']
Code: def __init__(self, client):
        self._client = client
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: login
Type: function
Parent Type: AuthActions
Location: /home/yuesheng/flask/examples/tutorial/tests/conftest.py,1144,1315
Arguments: ['self', 'username="test"', 'password="test"']
Code: def login(self, username="test", password="test"):
        return self._client.post(
            "/auth/login", data={"username": username, "password": password}
        )
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: logout
Type: function
Parent Type: AuthActions
Location: /home/yuesheng/flask/examples/tutorial/tests/conftest.py,1321,1386
Arguments: ['self']
Code: def logout(self):
        return self._client.get("/auth/logout")
____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_config
Type: function
Parent Type: 
Location: /home/yuesheng/flask/examples/tutorial/tests/test_factory.py,32,190
Arguments: ['']
Code: // Code for Global Scope
from flaskr import create_app
# Code for function: test_config()
# Code for function: test_hello(client)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: test_get_close_db
Type: function
Parent Type: 
Location: /home/yuesheng/flask/examples/tutorial/tests/test_db.py,62,293
Arguments: ['app']
Code: // Code for Global Scope
import sqlite3
import pytest
from flaskr.db import get_db
# Code for function: test_get_close_db(app)
# Code for function: test_init_db_command(runner, monkeypatch, )

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/examples/celery/make_celery.py,0,101
Arguments: []
Code: // Code for Global Scope
from task_app import create_app
flask_app = create_app()
celery_app = flask_app.extensions["celery"]

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: create_app
Type: function
Parent Type: 
Location: /home/yuesheng/flask/examples/celery/src/task_app/__init__.py,110,586
Arguments: ['', '']
Code: // Code for Global Scope
from celery import Celery
from celery import Task
from flask import Flask
from flask import render_template
# Code for function: create_app(, )
# Code for function: celery_init_app(app: Flask, self, *args: object, **kwargs: object)

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/examples/celery/src/task_app/tasks.py,0,483
Arguments: []
Code: // Code for Global Scope
import time
from celery import shared_task
from celery import Task
@shared_task(ignore_result=False)
def add(a: int, b: int) -> int:
    return a + b
@shared_task()
def block() -> None:
    time.sleep(5)
@shared_task(bind=True, ignore_result=False)
def process(self: Task, total: int) -> object:
    for i in range(total):
        self.update_state(state="PROGRESS", meta={"current": i + 1, "total": total})
        time.sleep(1)

    return {"current": total, "total": total}

____________________________________________________________________________________________________
____________________________________________________________________________________________________
Name: Global Scope
Type: others
Parent Type: root
Location: /home/yuesheng/flask/examples/celery/src/task_app/views.py,0,953
Arguments: []
Code: // Code for Global Scope
from celery.result import AsyncResult
from flask import Blueprint
from flask import request
from . import tasks
bp = Blueprint("tasks", __name__, url_prefix="/tasks")
@bp.get("/result/<id>")
def result(id: str) -> dict[str, object]:
    result = AsyncResult(id)
    ready = result.ready()
    return {
        "ready": ready,
        "successful": result.successful() if ready else None,
        "value": result.get() if ready else result.result,
    }
@bp.post("/add")
def add() -> dict[str, object]:
    a = request.form.get("a", type=int)
    b = request.form.get("b", type=int)
    result = tasks.add.delay(a, b)
    return {"result_id": result.id}
@bp.post("/block")
def block() -> dict[str, object]:
    result = tasks.block.delay()
    return {"result_id": result.id}
@bp.post("/process")
def process() -> dict[str, object]:
    result = tasks.process.delay(total=request.form.get("total", type=int))
    return {"result_id": result.id}

____________________________________________________________________________________________________
