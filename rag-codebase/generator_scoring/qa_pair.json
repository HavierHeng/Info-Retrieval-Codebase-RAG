[
    {
        "context": [
            "def __init__(self, app: App) -> None:\n        self.app = app",
            "class Blueprint(Scaffold):\n    \"\"\"Represents a blueprint, a collection of routes and other\n    app-related functions that can be registered on a real application\n    later.\n\n    A blueprint is an object that allows defining application functions\n    without requiring an application object ahead of time. It uses the\n    same decorators as :class:`~flask.Flask`, but defers the need for an\n    application by recording them for later registration.\n\n    Decorating a function with a blueprint creates a deferred function\n    that is called with :class:`~flask.blueprints.BlueprintSetupState`\n    when the blueprint is registered on an application.\n\n    See :doc:`/blueprints` for more information.\n\n    :param name: The name of the blueprint. Will be prepended to each\n        endpoint name.\n    :param import_name: The name of the blueprint package, usually\n        ``__name__``. This helps locate the ``root_path`` for the\n        blueprint.\n    :param static_folder: A folder with static files that should be\n        served by the blueprint's static route. The path is relative to\n        the blueprint's root path. Blueprint static files are disabled\n        by default.\n    :param static_url_path: The url to serve static files from.\n        Defaults to ``static_folder``. If the blueprint does not have\n        a ``url_prefix``, the app's static route will take precedence,\n        and the blueprint's static files won't be accessible.\n    :param template_folder: A folder with templates that should be added\n        to the app's template search path. The path is relative to the\n        blueprint's root path. Blueprint templates are disabled by\n        default. Blueprint templates have a lower precedence than those\n        in the app's templates folder.\n    :param url_prefix: A path to prepend to all of the blueprint's URLs,\n        to make them distinct from the rest of the app's routes.\n    :param subdomain: A subdomain that blueprint routes will match on by\n        default.\n    :param url_defaults: A dict of default values that blueprint routes\n        will receive by default.\n    :param root_path: By default, the blueprint will automatically set\n        this based on ``import_name``. In certain situations this\n        automatic detection can fail, so the path can be specified\n        manually instead.\n\n    .. versionchanged:: 1.1.0\n        Blueprints have a ``cli`` group to register nested CLI commands.\n        The ``cli_group`` parameter controls the name of the group under\n        the ``flask`` command.\n\n    .. versionadded:: 0.7\n    \"\"\"\n\n    _got_registered_once = False\n\n    # Code for function: Blueprint.__init__(self, name: str, import_name: str, static_folder: str | os.PathLike[str] | None = None, static_url_path: str | None = None, template_folder: str | os.PathLike[str] | None = None, url_prefix: str | None = None, subdomain: str | None = None, url_defaults: dict[str, t.Any] | None = None, root_path: str | None = None, cli_group: str | None = _sentinel, # type: ignore[assignment])\n# Code for function: Blueprint._check_setup_finished(self, f_name: str)\n# Code for function: Blueprint.make_setup_state(self, app: App, options: dict[str, t.Any], first_registration: bool = False)\n# Code for function: Blueprint.register(self, app: App, options: dict[str, t.Any])\n# Code for function: Blueprint._merge_blueprint_funcs(self, app: App, name: str, bp_dict: dict[ft.AppOrBlueprintKey, list[t.Any]], parent_dict: dict[ft.AppOrBlueprintKey, list[t.Any]], )\n",
            "class BlueprintSetupState:\n    \"\"\"Temporary holder object for registering a blueprint with the\n    application.  An instance of this class is created by the\n    :meth:`~flask.Blueprint.make_setup_state` method and later passed\n    to all register callback functions.\n    \"\"\"\n\n    # Code for function: BlueprintSetupState.__init__(self, blueprint: Blueprint, app: App, options: t.Any, first_registration: bool, )\n# Code for function: BlueprintSetupState.add_url_rule(self, rule: str, endpoint: str | None = None, view_func: ft.RouteCallable | None = None, **options: t.Any, )\n"
        ],
        "question": "What is the purpose of a blueprint in Flask?\n",
        "answer": "A blueprint in Flask represents a collection of routes and other app-related functions that can be registered on a real application later. It allows defining application functions without requiring an application object ahead of time.",
        "reference_file": [
            "/home/javier/Documents/flask/src/flask/templating.py",
            "/home/javier/Documents/flask/src/flask/sansio/blueprints.py",
            "/home/javier/Documents/flask/src/flask/sansio/blueprints.py"
        ]
    },
    {
        "context": [
            "def create_jinja_environment(self) -> Environment:\n        raise NotImplementedError()",
            "class AsyncMethodView(MethodView):\n    # Code for function: AsyncMethodView.get(self)\n# Code for function: AsyncMethodView.post(self)\n",
            "def async_to_sync(\n        self, func: t.Callable[..., t.Coroutine[t.Any, t.Any, t.Any]]\n    ) -> t.Callable[..., t.Any]:\n        \"\"\"Return a sync function that will run the coroutine function.\n\n        .. code-block:: python\n\n            result = app.async_to_sync(func)(*args, **kwargs)\n\n        Override this method to change how the app converts async code\n        to be synchronously callable.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        try:\n            from asgiref.sync import async_to_sync as asgiref_async_to_sync\n        except ImportError:\n            raise RuntimeError(\n                \"Install Flask with the 'async' extra in order to use async views.\"\n            ) from None\n\n        return asgiref_async_to_sync(func)"
        ],
        "question": "What is the name of the exception raised when trying to install Flask with the 'async' extra?\n\n",
        "answer": "RuntimeError.",
        "reference_file": [
            "/home/javier/Documents/flask/src/flask/sansio/app.py",
            "/home/javier/Documents/flask/tests/test_async.py",
            "/home/javier/Documents/flask/src/flask/app.py"
        ]
    },
    {
        "context": [
            "class View:\n    \"\"\"Subclass this class and override :meth:`dispatch_request` to\n    create a generic class-based view. Call :meth:`as_view` to create a\n    view function that creates an instance of the class with the given\n    arguments and calls its ``dispatch_request`` method with any URL\n    variables.\n\n    See :doc:`views` for a detailed guide.\n\n    .. code-block:: python\n\n        class Hello(View):\n            init_every_request = False\n\n            def dispatch_request(self, name):\n                return f\"Hello, {name}!\"\n\n        app.add_url_rule(\n            \"/hello/<name>\", view_func=Hello.as_view(\"hello\")\n        )\n\n    Set :attr:`methods` on the class to change what methods the view\n    accepts.\n\n    Set :attr:`decorators` on the class to apply a list of decorators to\n    the generated view function. Decorators applied to the class itself\n    will not be applied to the generated view function!\n\n    Set :attr:`init_every_request` to ``False`` for efficiency, unless\n    you need to store request-global data on ``self``.\n    \"\"\"\n\n    #: The methods this view is registered for. Uses the same default\n    #: (``[\"GET\", \"HEAD\", \"OPTIONS\"]``) as ``route`` and\n    #: ``add_url_rule`` by default.\n    methods: t.ClassVar[t.Collection[str] | None] = None\n\n    #: Control whether the ``OPTIONS`` method is handled automatically.\n    #: Uses the same default (``True``) as ``route`` and\n    #: ``add_url_rule`` by default.\n    provide_automatic_options: t.ClassVar[bool | None] = None\n\n    #: A list of decorators to apply, in order, to the generated view\n    #: function. Remember that ``@decorator`` syntax is applied bottom\n    #: to top, so the first decorator in the list would be the bottom\n    #: decorator.\n    #:\n    #: .. versionadded:: 0.8\n    decorators: t.ClassVar[list[t.Callable[..., t.Any]]] = []\n\n    #: Create a new instance of this view class for every request by\n    #: default. If a view subclass sets this to ``False``, the same\n    #: instance is used for every request.\n    #:\n    #: A single instance is more efficient, especially if complex setup\n    #: is done during init. However, storing data on ``self`` is no\n    #: longer safe across requests, and :data:`~flask.g` should be used\n    #: instead.\n    #:\n    #: .. versionadded:: 2.2\n    init_every_request: t.ClassVar[bool] = True\n\n    # Code for function: View.dispatch_request(self)\n",
            "class Scaffold:\n    \"\"\"Common behavior shared between :class:`~flask.Flask` and\n    :class:`~flask.blueprints.Blueprint`.\n\n    :param import_name: The import name of the module where this object\n        is defined. Usually :attr:`__name__` should be used.\n    :param static_folder: Path to a folder of static files to serve.\n        If this is set, a static route will be added.\n    :param static_url_path: URL prefix for the static route.\n    :param template_folder: Path to a folder containing template files.\n        for rendering. If this is set, a Jinja loader will be added.\n    :param root_path: The path that static, template, and resource files\n        are relative to. Typically not set, it is discovered based on\n        the ``import_name``.\n\n    .. versionadded:: 2.0\n    \"\"\"\n\n    cli: Group\n    name: str\n    _static_folder: str | None = None\n    _static_url_path: str | None = None\n\n    # Code for function: Scaffold.__init__(self, import_name: str, static_folder: str | os.PathLike[str] | None = None, static_url_path: str | None = None, template_folder: str | os.PathLike[str] | None = None, root_path: str | None = None, )\n# Code for function: Scaffold.__repr__(self)\n# Code for function: Scaffold._check_setup_finished(self, f_name: str)\n# Code for function: Scaffold._method_route(self, method: str, rule: str, options: dict[str, t.Any], )\n",
            "class SessionInterface:\n    \"\"\"The basic interface you have to implement in order to replace the\n    default session interface which uses werkzeug's securecookie\n    implementation.  The only methods you have to implement are\n    :meth:`open_session` and :meth:`save_session`, the others have\n    useful defaults which you don't need to change.\n\n    The session object returned by the :meth:`open_session` method has to\n    provide a dictionary like interface plus the properties and methods\n    from the :class:`SessionMixin`.  We recommend just subclassing a dict\n    and adding that mixin::\n\n        class Session(dict, SessionMixin):\n            pass\n\n    If :meth:`open_session` returns ``None`` Flask will call into\n    :meth:`make_null_session` to create a session that acts as replacement\n    if the session support cannot work because some requirement is not\n    fulfilled.  The default :class:`NullSession` class that is created\n    will complain that the secret key was not set.\n\n    To replace the session interface on an application all you have to do\n    is to assign :attr:`flask.Flask.session_interface`::\n\n        app = Flask(__name__)\n        app.session_interface = MySessionInterface()\n\n    Multiple requests with the same session may be sent and handled\n    concurrently. When implementing a new session interface, consider\n    whether reads or writes to the backing store must be synchronized.\n    There is no guarantee on the order in which the session for each\n    request is opened or saved, it will occur in the order that requests\n    begin and end processing.\n\n    .. versionadded:: 0.8\n    \"\"\"\n\n    #: :meth:`make_null_session` will look here for the class that should\n    #: be created when a null session is requested.  Likewise the\n    #: :meth:`is_null_session` method will perform a typecheck against\n    #: this type.\n    null_session_class = NullSession\n\n    #: A flag that indicates if the session interface is pickle based.\n    #: This can be used by Flask extensions to make a decision in regards\n    #: to how to deal with the session object.\n    #:\n    #: .. versionadded:: 0.10\n    pickle_based = False\n\n    # Code for function: SessionInterface.make_null_session(self, app: Flask)\n# Code for function: SessionInterface.is_null_session(self, obj: object)\n# Code for function: SessionInterface.get_cookie_name(self, app: Flask)\n# Code for function: SessionInterface.get_cookie_domain(self, app: Flask)\n# Code for function: SessionInterface.get_cookie_path(self, app: Flask)\n# Code for function: SessionInterface.get_cookie_httponly(self, app: Flask)\n# Code for function: SessionInterface.get_cookie_secure(self, app: Flask)\n# Code for function: SessionInterface.get_cookie_samesite(self, app: Flask)\n# Code for function: SessionInterface.get_cookie_partitioned(self, app: Flask)\n# Code for function: SessionInterface.get_expiration_time(self, app: Flask, session: SessionMixin)\n# Code for function: SessionInterface.should_set_cookie(self, app: Flask, session: SessionMixin)\n# Code for function: SessionInterface.open_session(self, app: Flask, request: Request)\n# Code for function: SessionInterface.save_session(self, app: Flask, session: SessionMixin, response: Response)\n"
        ],
        "question": "What is the default behavior of a view subclass when it comes to creating a new instance of itself for every request?\n\n",
        "answer": "By default, a view subclass creates a new instance of itself for every request. This can be controlled by setting the `init_every_request` attribute on the class to either `True` (the default) or `False`. If set to `False`, the same instance is used for every request.",
        "reference_file": [
            "/home/javier/Documents/flask/src/flask/views.py",
            "/home/javier/Documents/flask/src/flask/sansio/scaffold.py",
            "/home/javier/Documents/flask/src/flask/sessions.py"
        ]
    },
    {
        "context": [
            "def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)",
            "def dumps(self, value: t.Any) -> str:\n        \"\"\"Tag the value and dump it to a compact JSON string.\"\"\"\n        return dumps(self.tag(value), separators=(\",\", \":\"))",
            "class DispatchingJinjaLoader(BaseLoader):\n    \"\"\"A loader that looks for templates in the application and all\n    the blueprint folders.\n    \"\"\"\n\n    # Code for function: DispatchingJinjaLoader.__init__(self, app: App)\n# Code for function: DispatchingJinjaLoader.get_source(self, environment: BaseEnvironment, template: str)\n# Code for function: DispatchingJinjaLoader._get_source_explained(self, environment: BaseEnvironment, template: str)\n# Code for function: DispatchingJinjaLoader._get_source_fast(self, environment: BaseEnvironment, template: str)\n# Code for function: DispatchingJinjaLoader._iter_loaders(self, template: str)\n# Code for function: DispatchingJinjaLoader.list_templates(self)\n"
        ],
        "question": "What is the purpose of the `push` method in this code?\n\n",
        "answer": "The `push` method binds the app context to the current context.",
        "reference_file": [
            "/home/javier/Documents/flask/src/flask/ctx.py",
            "/home/javier/Documents/flask/src/flask/json/tag.py",
            "/home/javier/Documents/flask/src/flask/templating.py"
        ]
    },
    {
        "context": [
            "def finalize_request(\n        self,\n        rv: ft.ResponseReturnValue | HTTPException,\n        from_error_handler: bool = False,\n    ) -> Response:\n        \"\"\"Given the return value from a view function this finalizes\n        the request by converting it into a response and invoking the\n        postprocessing functions.  This is invoked for both normal\n        request dispatching as well as error handlers.\n\n        Because this means that it might be called as a result of a\n        failure a special safe mode is available which can be enabled\n        with the `from_error_handler` flag.  If enabled, failures in\n        response processing will be logged and otherwise ignored.\n\n        :internal:\n        \"\"\"\n        response = self.make_response(rv)\n        try:\n            response = self.process_response(response)\n            request_finished.send(\n                self, _async_wrapper=self.ensure_sync, response=response\n            )\n        except Exception:\n            if not from_error_handler:\n                raise\n            self.logger.exception(\n                \"Request finalizing failed with an error while handling an error\"\n            )\n        return response",
            "def dispatch_request(self) -> ft.ResponseReturnValue:\n        \"\"\"Does the request dispatching.  Matches the URL and returns the\n        return value of the view or error handler.  This does not have to\n        be a response object.  In order to convert the return value to a\n        proper response object, call :func:`make_response`.\n\n        .. versionchanged:: 0.7\n           This no longer does the exception handling, this code was\n           moved to the new :meth:`full_dispatch_request`.\n        \"\"\"\n        req = request_ctx.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule: Rule = req.url_rule  # type: ignore[assignment]\n        # if we provide automatic options for this URL and the\n        # request came with the OPTIONS method, reply automatically\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        # otherwise dispatch to the handler for that endpoint\n        view_args: dict[str, t.Any] = req.view_args  # type: ignore[assignment]\n        return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]",
            "def from_prefixed_env(\n        self, prefix: str = \"FLASK\", *, loads: t.Callable[[str], t.Any] = json.loads\n    ) -> bool:\n        \"\"\"Load any environment variables that start with ``FLASK_``,\n        dropping the prefix from the env key for the config key. Values\n        are passed through a loading function to attempt to convert them\n        to more specific types than strings.\n\n        Keys are loaded in :func:`sorted` order.\n\n        The default loading function attempts to parse values as any\n        valid JSON type, including dicts and lists.\n\n        Specific items in nested dicts can be set by separating the\n        keys with double underscores (``__``). If an intermediate key\n        doesn't exist, it will be initialized to an empty dict.\n\n        :param prefix: Load env vars that start with this prefix,\n            separated with an underscore (``_``).\n        :param loads: Pass each string value to this function and use\n            the returned value as the config value. If any error is\n            raised it is ignored and the value remains a string. The\n            default is :func:`json.loads`.\n\n        .. versionadded:: 2.1\n        \"\"\"\n        prefix = f\"{prefix}_\"\n\n        for key in sorted(os.environ):\n            if not key.startswith(prefix):\n                continue\n\n            value = os.environ[key]\n            key = key.removeprefix(prefix)\n\n            try:\n                value = loads(value)\n            except Exception:\n                # Keep the value as a string if loading failed.\n                pass\n\n            if \"__\" not in key:\n                # A non-nested key, set directly.\n                self[key] = value\n                continue\n\n            # Traverse nested dictionaries with keys separated by \"__\".\n            current = self\n            *parts, tail = key.split(\"__\")\n\n            for part in parts:\n                # If an intermediate dict does not exist, create it.\n                if part not in current:\n                    current[part] = {}\n\n                current = current[part]\n\n            current[tail] = value\n\n        return True"
        ],
        "question": "What happens when the `finalize_request` function encounters an exception while processing a response?\n",
        "answer": "If the exception occurs and the `from_error_handler` flag is False, it will be re-raised. Otherwise, it will be logged as an exception in safe mode.",
        "reference_file": [
            "/home/javier/Documents/flask/src/flask/app.py",
            "/home/javier/Documents/flask/src/flask/app.py",
            "/home/javier/Documents/flask/src/flask/config.py"
        ]
    },
    {
        "context": [
            "def from_envvar(self, variable_name: str, silent: bool = False) -> bool:\n        \"\"\"Loads a configuration from an environment variable pointing to\n        a configuration file.  This is basically just a shortcut with nicer\n        error messages for this line of code::\n\n            app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])\n\n        :param variable_name: name of the environment variable\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n        :return: ``True`` if the file was loaded successfully.\n        \"\"\"\n        rv = os.environ.get(variable_name)\n        if not rv:\n            if silent:\n                return False\n            raise RuntimeError(\n                f\"The environment variable {variable_name!r} is not set\"\n                \" and as such configuration could not be loaded. Set\"\n                \" this variable and make it point to a configuration\"\n                \" file\"\n            )\n        return self.from_pyfile(rv, silent=silent)",
            "def invoke(  # type: ignore\n        self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any\n    ) -> Result:\n        \"\"\"Invokes a CLI command in an isolated environment. See\n        :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for\n        full method documentation. See :ref:`testing-cli` for examples.\n\n        If the ``obj`` argument is not given, passes an instance of\n        :class:`~flask.cli.ScriptInfo` that knows how to load the Flask\n        app being tested.\n\n        :param cli: Command object to invoke. Default is the app's\n            :attr:`~flask.app.Flask.cli` group.\n        :param args: List of strings to invoke the command with.\n\n        :return: a :class:`~click.testing.Result` object.\n        \"\"\"\n        if cli is None:\n            cli = self.app.cli\n\n        if \"obj\" not in kwargs:\n            kwargs[\"obj\"] = ScriptInfo(create_app=lambda: self.app)\n\n        return super().invoke(cli, args, **kwargs)",
            "def from_file(\n        self,\n        filename: str | os.PathLike[str],\n        load: t.Callable[[t.IO[t.Any]], t.Mapping[str, t.Any]],\n        silent: bool = False,\n        text: bool = True,\n    ) -> bool:\n        \"\"\"Update the values in the config from a file that is loaded\n        using the ``load`` parameter. The loaded data is passed to the\n        :meth:`from_mapping` method.\n\n        .. code-block:: python\n\n            import json\n            app.config.from_file(\"config.json\", load=json.load)\n\n            import tomllib\n            app.config.from_file(\"config.toml\", load=tomllib.load, text=False)\n\n        :param filename: The path to the data file. This can be an\n            absolute path or relative to the config root path.\n        :param load: A callable that takes a file handle and returns a\n            mapping of loaded data from the file.\n        :type load: ``Callable[[Reader], Mapping]`` where ``Reader``\n            implements a ``read`` method.\n        :param silent: Ignore the file if it doesn't exist.\n        :param text: Open the file in text or binary mode.\n        :return: ``True`` if the file was loaded successfully.\n\n        .. versionchanged:: 2.3\n            The ``text`` parameter was added.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n\n        try:\n            with open(filename, \"r\" if text else \"rb\") as f:\n                obj = load(f)\n        except OSError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR):\n                return False\n\n            e.strerror = f\"Unable to load configuration file ({e.strerror})\"\n            raise\n\n        return self.from_mapping(obj)"
        ],
        "question": "What happens when the environment variable specified by `variable_name` is not set?\n",
        "answer": "If the silent parameter is True, it returns False; otherwise, it raises a RuntimeError with an error message indicating that the environment variable is not set.",
        "reference_file": [
            "/home/javier/Documents/flask/src/flask/config.py",
            "/home/javier/Documents/flask/src/flask/testing.py",
            "/home/javier/Documents/flask/src/flask/config.py"
        ]
    },
    {
        "context": [
            "def __enter__(self) -> RequestContext:\n        self.push()\n        return self",
            "def process_response(self, response: Response) -> Response:\n        \"\"\"Can be overridden in order to modify the response object\n        before it's sent to the WSGI server.  By default this will\n        call all the :meth:`after_request` decorated functions.\n\n        .. versionchanged:: 0.5\n           As of Flask 0.5 the functions registered for after request\n           execution are called in reverse order of registration.\n\n        :param response: a :attr:`response_class` object.\n        :return: a new response object or the same, has to be an\n                 instance of :attr:`response_class`.\n        \"\"\"\n        ctx = request_ctx._get_current_object()  # type: ignore[attr-defined]\n\n        for func in ctx._after_request_functions:\n            response = self.ensure_sync(func)(response)\n\n        for name in chain(request.blueprints, (None,)):\n            if name in self.after_request_funcs:\n                for func in reversed(self.after_request_funcs[name]):\n                    response = self.ensure_sync(func)(response)\n\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n\n        return response",
            "class MethodView(View):\n    \"\"\"Dispatches request methods to the corresponding instance methods.\n    For example, if you implement a ``get`` method, it will be used to\n    handle ``GET`` requests.\n\n    This can be useful for defining a REST API.\n\n    :attr:`methods` is automatically set based on the methods defined on\n    the class.\n\n    See :doc:`views` for a detailed guide.\n\n    .. code-block:: python\n\n        class CounterAPI(MethodView):\n            def get(self):\n                return str(session.get(\"counter\", 0))\n\n            def post(self):\n                session[\"counter\"] = session.get(\"counter\", 0) + 1\n                return redirect(url_for(\"counter\"))\n\n        app.add_url_rule(\n            \"/counter\", view_func=CounterAPI.as_view(\"counter\")\n        )\n    \"\"\"\n\n    # Code for function: MethodView.__init_subclass__(cls, **kwargs: t.Any)\n# Code for function: MethodView.dispatch_request(self, **kwargs: t.Any)\n"
        ],
        "question": "What is the purpose of the `process_response` method in Flask?\n",
        "answer": "The `process_response` method in Flask is used to modify the response object before it's sent to the WSGI server. It calls all the after-request decorated functions, which can be overridden by subclasses to perform custom processing on the response.",
        "reference_file": [
            "/home/javier/Documents/flask/src/flask/ctx.py",
            "/home/javier/Documents/flask/src/flask/app.py",
            "/home/javier/Documents/flask/src/flask/views.py"
        ]
    },
    {
        "context": [
            "def get_send_file_max_age(self, filename: str | None) -> int | None:\n        \"\"\"Used by :func:`send_file` to determine the ``max_age`` cache\n        value for a given file path if it wasn't passed.\n\n        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from\n        the configuration of :data:`~flask.current_app`. This defaults\n        to ``None``, which tells the browser to use conditional requests\n        instead of a timed cache, which is usually preferable.\n\n        Note this is a duplicate of the same method in the Flask\n        class.\n\n        .. versionchanged:: 2.0\n            The default configuration is ``None`` instead of 12 hours.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        value = current_app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n\n        if value is None:\n            return None\n\n        if isinstance(value, timedelta):\n            return int(value.total_seconds())\n\n        return value  # type: ignore[no-any-return]",
            "def to_json(self, value: t.Any) -> t.Any:\n        key = next(iter(value))\n        return {f\"{key}__\": self.serializer.tag(value[key])}",
            "def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)"
        ],
        "question": "What is the default value for SEND_FILE_MAX_AGE_DEFAULT in Flask?\n\n",
        "answer": "The default value for SEND_FILE_MAX_AGE_DEFAULT in Flask is None.",
        "reference_file": [
            "/home/javier/Documents/flask/src/flask/app.py",
            "/home/javier/Documents/flask/src/flask/json/tag.py",
            "/home/javier/Documents/flask/src/flask/ctx.py"
        ]
    },
    {
        "context": [
            "class JSONTag:\n    \"\"\"Base class for defining type tags for :class:`TaggedJSONSerializer`.\"\"\"\n\n    __slots__ = (\"serializer\",)\n\n    #: The tag to mark the serialized object with. If empty, this tag is\n    #: only used as an intermediate step during tagging.\n    key: str = \"\"\n\n    # Code for function: JSONTag.__init__(self, serializer: TaggedJSONSerializer)\n# Code for function: JSONTag.check(self, value: t.Any)\n# Code for function: JSONTag.to_json(self, value: t.Any)\n# Code for function: JSONTag.to_python(self, value: t.Any)\n# Code for function: JSONTag.tag(self, value: t.Any)\n",
            "def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:\n        super().__init__(*args, **kwargs)\n        self.preserve_context = False\n        self._new_contexts: list[t.ContextManager[t.Any]] = []\n        self._context_stack = ExitStack()\n        self.environ_base = {\n            \"REMOTE_ADDR\": \"127.0.0.1\",\n            \"HTTP_USER_AGENT\": f\"Werkzeug/{_get_werkzeug_version()}\",\n        }",
            "def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)"
        ],
        "question": "What is the default value of `REMOTE_ADDR` in the `environ_base` dictionary?\n\n",
        "answer": "The default value of `REMOTE_ADDR` in the `environ_base` dictionary is `\"127.0.0.1\"`.",
        "reference_file": [
            "/home/javier/Documents/flask/src/flask/json/tag.py",
            "/home/javier/Documents/flask/src/flask/testing.py",
            "/home/javier/Documents/flask/src/flask/ctx.py"
        ]
    },
    {
        "context": [
            "def run(\n        self,\n        host: str | None = None,\n        port: int | None = None,\n        debug: bool | None = None,\n        load_dotenv: bool = True,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Runs the application on a local development server.\n\n        Do not use ``run()`` in a production setting. It is not intended to\n        meet security and performance requirements for a production server.\n        Instead, see :doc:`/deploying/index` for WSGI server recommendations.\n\n        If the :attr:`debug` flag is set the server will automatically reload\n        for code changes and show a debugger in case an exception happened.\n\n        If you want to run the application in debug mode, but disable the\n        code execution on the interactive debugger, you can pass\n        ``use_evalex=False`` as parameter.  This will keep the debugger's\n        traceback screen active, but disable code execution.\n\n        It is not recommended to use this function for development with\n        automatic reloading as this is badly supported.  Instead you should\n        be using the :command:`flask` command line script's ``run`` support.\n\n        .. admonition:: Keep in Mind\n\n           Flask will suppress any server error with a generic error page\n           unless it is in debug mode.  As such to enable just the\n           interactive debugger without the code reloading, you have to\n           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.\n           Setting ``use_debugger`` to ``True`` without being in debug mode\n           won't catch any exceptions because there won't be any to\n           catch.\n\n        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to\n            have the server available externally as well. Defaults to\n            ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable\n            if present.\n        :param port: the port of the webserver. Defaults to ``5000`` or the\n            port defined in the ``SERVER_NAME`` config variable if present.\n        :param debug: if given, enable or disable debug mode. See\n            :attr:`debug`.\n        :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n            files to set environment variables. Will also change the working\n            directory to the directory containing the first file found.\n        :param options: the options to be forwarded to the underlying Werkzeug\n            server. See :func:`werkzeug.serving.run_simple` for more\n            information.\n\n        .. versionchanged:: 1.0\n            If installed, python-dotenv will be used to load environment\n            variables from :file:`.env` and :file:`.flaskenv` files.\n\n            The :envvar:`FLASK_DEBUG` environment variable will override :attr:`debug`.\n\n            Threaded mode is enabled by default.\n\n        .. versionchanged:: 0.10\n            The default port is now picked from the ``SERVER_NAME``\n            variable.\n        \"\"\"\n        # Ignore this call so that it doesn't start another server if\n        # the 'flask run' command is used.\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            if not is_running_from_reloader():\n                click.secho(\n                    \" * Ignoring a call to 'app.run()' that would block\"\n                    \" the current 'flask' CLI command.\\n\"\n                    \"   Only call 'app.run()' in an 'if __name__ ==\"\n                    ' \"__main__\"\\' guard.',\n                    fg=\"red\",\n                )\n\n            return\n\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n\n            # if set, env var overrides existing value\n            if \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n\n        # debug passed to method overrides all other sources\n        if debug is not None:\n            self.debug = bool(debug)\n\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n\n        cli.show_server_banner(self.debug, self.name)\n\n        from werkzeug.serving import run_simple\n\n        try:\n            run_simple(t.cast(str, host), port, self, **options)\n        finally:\n            # reset the first request information if the development server\n            # reset normally.  This makes it possible to restart the server\n            # without reloader and that stuff from an interactive shell.\n            self._got_first_request = False",
            "class AppError(Exception):\n    pass",
            "class BlueprintSetupState:\n    \"\"\"Temporary holder object for registering a blueprint with the\n    application.  An instance of this class is created by the\n    :meth:`~flask.Blueprint.make_setup_state` method and later passed\n    to all register callback functions.\n    \"\"\"\n\n    # Code for function: BlueprintSetupState.__init__(self, blueprint: Blueprint, app: App, options: t.Any, first_registration: bool, )\n# Code for function: BlueprintSetupState.add_url_rule(self, rule: str, endpoint: str | None = None, view_func: ft.RouteCallable | None = None, **options: t.Any, )\n"
        ],
        "question": "What is the default port used by Flask when running a development server?\n",
        "answer": "The default port used by Flask when running a development server is 5000.",
        "reference_file": [
            "/home/javier/Documents/flask/src/flask/app.py",
            "/home/javier/Documents/flask/tests/test_async.py",
            "/home/javier/Documents/flask/src/flask/sansio/blueprints.py"
        ]
    }
]